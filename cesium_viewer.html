<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GSSE Cesium 3DGS查看器</title>
    
    <!-- Cesium CSS - 使用本地文件 -->
    <link href="./lib/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <!-- Three.js - 使用unpkg CDN（备用：本地文件） -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js" 
            onerror="console.error('[Cesium JS Error] THREE.js CDN加载失败，尝试使用本地文件'); loadLocalThree();"></script>
    
    <!-- Cesium JS - 使用本地文件 -->
    <script src="./lib/Cesium/Cesium.js"
            onerror="console.error('[Cesium JS Error] Cesium.js本地文件加载失败，请检查文件路径')"></script>
    
    <!-- 备用：本地Three.js加载函数 -->
    <script>
        function loadLocalThree() {
            // 如果CDN加载失败，尝试加载本地文件
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                // 尝试使用本地的three.min.js (匹配wget命令下载的路径)
                script.src = './lib/threejs/three.min.js';
                script.onerror = function() {
                    console.error('[Cesium JS Error] 本地THREE.js文件也无法加载，请检查网络连接或文件路径: ./lib/threejs/three.min.js');
                };
                script.onload = function() {
                    console.log('[Cesium JS Info] 已从本地文件加载THREE.js');
                };
                document.head.appendChild(script);
            }
        }
    </script>
    
    <!-- Gaussian Splats 3D - 使用lib目录中的UMD库文件 -->
    <!-- 注意：必须在THREE.js加载之后加载，因为UMD文件依赖THREE -->
    <script>
        // 等待THREE.js加载完成后再加载GaussianSplats3D
        function loadGaussianSplats3D() {
            if (typeof THREE === 'undefined') {
                console.log('[Cesium JS Info] 等待THREE.js加载...');
                setTimeout(loadGaussianSplats3D, 100);
                return;
            }
            
            // THREE.js已加载，现在加载GaussianSplats3D
            const script = document.createElement('script');
            script.src = './lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs';
            script.onload = function() {
                // UMD文件将库导出为全局变量 "Gaussian Splats 3D"（带空格）
                const GaussianSplats3D = window["Gaussian Splats 3D"] || window.GaussianSplats3D;
                
                if (GaussianSplats3D && typeof GaussianSplats3D.Viewer !== 'undefined') {
                    // 将其设置为全局变量，以便其他脚本可以使用（使用无空格版本）
                    window.GaussianSplats3D = GaussianSplats3D;
                    console.log('[Cesium JS Info] GaussianSplats3D库已加载');
                    console.log('[Cesium JS Info] 可用的GaussianSplats3D属性:', Object.keys(GaussianSplats3D));
                    console.log('[Cesium JS Info] GaussianSplats3D.Viewer类已正确加载');
                    
                    // 检查Raycaster是否可用
                    if (typeof GaussianSplats3D.Raycaster !== 'undefined') {
                        console.log('[Cesium JS Info] GaussianSplats3D.Raycaster类已正确加载');
                    } else {
                        console.warn('[Cesium JS Warning] GaussianSplats3D.Raycaster类不可用，可能需要更新库文件');
                    }
                } else {
                    console.error('[Cesium JS Error] GaussianSplats3D库未加载或Viewer类未定义');
                    console.log('[Cesium JS Info] 检查全局对象:', {
                        'Gaussian Splats 3D': typeof window["Gaussian Splats 3D"],
                        'GaussianSplats3D': typeof window.GaussianSplats3D,
                        'THREE': typeof window.THREE,
                        'window keys': Object.keys(window).filter(k => k.includes('Gaussian') || k.includes('Splat'))
                    });
                }
            };
            script.onerror = function() {
                console.error('[Cesium JS Error] 加载GaussianSplats3D库文件失败，请检查文件路径: ./lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs');
            };
            document.head.appendChild(script);
        }
        
        // 开始加载
        loadGaussianSplats3D();
    </script>
    
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: sans-serif;
        }
        
        #cesiumContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #threeContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        #threeContainer canvas {
            pointer-events: none;
        }
        
        #toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(42, 42, 42, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: white;
            max-width: 300px;
        }
        
        .toolbar-section {
            margin-bottom: 10px;
        }
        
        .toolbar-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .toolbar-section input, .toolbar-section select {
            width: 100%;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #555;
            background: #333;
            color: white;
        }
        
        .toolbar-section button {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: none;
            border-radius: 3px;
            background: #0E639C;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        
        .toolbar-section button:hover {
            background: #1177BB;
        }
        
        #info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(42, 42, 42, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            min-width: 200px;
        }
        
        .info-item {
            margin: 3px 0;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .content {
            display: block;
        }
        
        .content.collapsed {
            display: none;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="threeContainer"></div>
    
    <div id="toolbar">
        <div class="toolbar-section">
            <h3 style="margin: 0 0 10px 0;">GSSE GIS视图</h3>
        </div>
        
        <div class="toolbar-section">
            <label>地形设置</label>
            <select id="terrainSelect">
                <option value="none">无地形</option>
                <option value="world" selected>全球地形</option>
            </select>
        </div>
        
        <div class="toolbar-section">
            <label>影像图层</label>
            <select id="imagerySelect">
                <option value="bing" selected>Bing Maps</option>
                <option value="osm">OpenStreetMap</option>
                <option value="arcgis">ArcGIS World Imagery</option>
            </select>
        </div>
        
        <div class="toolbar-section">
            <label>相机操作</label>
            <button onclick="resetCamera()">重置相机</button>
        </div>
        
        <div class="toolbar-section">
            <label>模型管理</label>
            <select id="modelList" size="3" style="width: 100%; margin-bottom: 5px;" onchange="onModelSelected()">
                <option value="">无模型</option>
            </select>
            <button onclick="removeSelectedModel()">删除选中模型</button>
            <button onclick="toggleModelVisibility()">显示/隐藏</button>
        </div>
    </div>
    
    <!-- 模型属性控制面板 -->
    <div id="modelProperties" style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(42, 42, 42, 0.9); padding: 10px; border-radius: 5px; color: white; max-width: 300px; display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">模型属性</h3>
            <button onclick="closeModelProperties()" style="background: none; border: none; color: white; cursor: pointer; font-size: 16px;">✕</button>
        </div>
        <div id="modelPropsContent">
            <div class="toolbar-section">
                <label>位置</label>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">经度:</label>
                    <input type="number" id="propLon" step="0.000001" style="width: 100%;" onchange="updateModelProperty('location')" />
                </div>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">纬度:</label>
                    <input type="number" id="propLat" step="0.000001" style="width: 100%;" onchange="updateModelProperty('location')" />
                </div>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">高度 (m):</label>
                    <input type="number" id="propHeight" step="0.1" style="width: 100%;" onchange="updateModelProperty('location')" />
                </div>
            </div>
            
            <div class="toolbar-section">
                <label>旋转 (弧度)</label>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">X轴:</label>
                    <input type="range" id="propRotX" min="-3.14159" max="3.14159" step="0.01" value="0" style="width: 80%;" oninput="updateModelProperty('rotation')" />
                    <span id="propRotXValue" style="font-size: 11px;">0.00</span>
                </div>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">Y轴:</label>
                    <input type="range" id="propRotY" min="-3.14159" max="3.14159" step="0.01" value="0" style="width: 80%;" oninput="updateModelProperty('rotation')" />
                    <span id="propRotYValue" style="font-size: 11px;">0.00</span>
                </div>
                <div style="margin-bottom: 5px;">
                    <label style="font-size: 11px;">Z轴:</label>
                    <input type="range" id="propRotZ" min="-3.14159" max="3.14159" step="0.01" value="0" style="width: 80%;" oninput="updateModelProperty('rotation')" />
                    <span id="propRotZValue" style="font-size: 11px;">0.00</span>
                </div>
            </div>
            
            <div class="toolbar-section">
                <label>缩放</label>
                <input type="range" id="propScale" min="0.1" max="5" step="0.05" value="1" style="width: 80%;" oninput="updateModelProperty('scale')" />
                <span id="propScaleValue">1.00</span>
            </div>
            
            <div class="toolbar-section">
                <button onclick="resetModelTransform()" style="width: 100%;">重置变换</button>
                <button onclick="flyToSelectedModel()" style="width: 100%;">飞到此模型</button>
            </div>
        </div>
    </div>
    
    <div id="info-panel">
        <div class="collapsible" onclick="toggleInfoPanel()">
            <strong>▼ 场景信息</strong>
        </div>
        <div id="info-content" class="content">
            <div class="info-item">相机高度: <span id="cameraHeight">-</span>m</div>
            <div class="info-item">经度: <span id="longitude">-</span>°</div>
            <div class="info-item">纬度: <span id="latitude">-</span>°</div>
            <div class="info-item">已加载模型: <span id="modelCount">0</span></div>
        </div>
    </div>

    <!-- Qt WebChannel - 仅在Qt环境中加载 -->
    <script>
        // 动态加载Qt WebChannel脚本，避免在浏览器中报错
        if (typeof qt !== 'undefined' && qt.webChannelTransport) {
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            script.onerror = function() {
                console.log('[Cesium JS Info] Qt WebChannel不可用（浏览器环境）');
            };
            document.head.appendChild(script);
        }
    </script>
    <script>
        // 全局变量
        let cesiumViewer = null;
        let threeScene = null;
        let threeCamera = null;
        let threeRenderer = null;
        let gaussianSplatLayers = [];
        let modelBoundingSphere = null;
        let pyBridge = null;
        
        // 消息队列，用于存储初始化前收到的消息
        const messageQueue = [];
        let initRetryCount = 0;
        const MAX_INIT_RETRIES = 100; // 最多重试10秒
        
        // 预先定义 receiveMessageFromPython 函数，避免未定义错误
        window.receiveMessageFromPython = function(messageStr) {
            if (!cesiumViewer) {
                console.log('[Cesium JS Info] 收到Python消息，但viewer还未初始化，加入队列');
                messageQueue.push(messageStr);
                // 如果初始化重试次数过多，强制尝试初始化
                if (initRetryCount < MAX_INIT_RETRIES) {
                    initRetryCount++;
                    setTimeout(function() {
                        if (window.receiveMessageFromPython) {
                            window.receiveMessageFromPython(messageStr);
                        }
                    }, 100);
                } else {
                    console.error('[Cesium JS Error] 初始化超时，强制处理消息');
                    // 强制处理消息
                    if (cesiumViewer) {
                        const message = JSON.parse(messageStr);
                        console.log('收到Python消息:', message);
                    }
                }
                return;
            }
            
            // viewer已初始化，处理消息
            const message = JSON.parse(messageStr);
            console.log('[Cesium JS Info] 收到Python消息:', message);
            
            switch(message.type) {
                case 'load3DGS':
                    load3DGS(message.data);
                    break;
                case 'loadSegment':
                    loadSegment(message.data);
                    break;
                case 'clearAll':
                    clearAllModels();
                    break;
                case 'setCamera':
                    setCameraPosition(message.data);
                    break;
                case 'highlightSegment':
                    highlightSegment(message.data);
                    break;
                case 'removeModel':
                    removeModel(message.data);
                    break;
                case 'getModelInfo':
                    getModelInfo(message.data);
                    break;
                case 'moveCamera':
                    moveCamera(message.data);
                    break;
                case 'zoomCamera':
                    zoomCamera(message.data);
                    break;
                case 'rotateCamera':
                    rotateCamera(message.data);
                    break;
                case 'resetView':
                    resetView();
                    break;
                case 'setTopView':
                    setTopView();
                    break;
                case 'captureScreenshot':
                    captureScreenshot(message.data);
                    break;
                case 'calculateCornerPoints3D':
                    calculateCornerPoints3D(message.data);
                    break;
                case 'calculateContourPoints3D':
                    calculateContourPoints3D(message.data);
                    break;
                case 'getCameraMatrices':
                    getCameraMatrices();
                    break;
                case 'addPointLabels':
                    addPointLabels(message.data);
                    break;
                default:
                    console.log('[Cesium JS Info] 未知消息类型:', message.type);
            }
        };
        
        // 初始化标志，防止重复初始化
        let isInitializing = false;
        let isInitialized = false;
        
        // 初始化Cesium Viewer - 在Cesium库加载完成后调用
        window.initCesiumViewer = function() {
            // 防止重复初始化
            if (isInitializing || isInitialized) {
                console.log('[Cesium JS Info] 初始化已在进行或已完成，跳过');
                return;
            }
            
            // 检查DOM元素是否存在
            const cesiumContainer = document.getElementById('cesiumContainer');
            if (!cesiumContainer) {
                console.error('[Cesium JS Error] 找不到cesiumContainer元素');
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            // 检查Cesium是否已加载
            if (typeof Cesium === 'undefined') {
                console.error('[Cesium JS Error] Cesium库未加载，请检查文件路径');
                // 延迟重试
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            // 检查THREE是否已加载
            if (typeof THREE === 'undefined') {
                console.log('[Cesium JS Info] 等待Three.js加载...');
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            isInitializing = true;
            console.log('[Cesium JS Info] Cesium和THREE库已加载，开始初始化...');
            if (typeof THREE !== 'undefined') {
                console.log('[Cesium JS Info] THREE.REVISION:', THREE.REVISION);
            }
            
            try {
            
            // 配置Cesium使用本地资源路径（避免CORS问题）
            // 获取当前HTML文件的目录路径
            const currentPath = window.location.href;
            const isFileProtocol = currentPath.startsWith('file://');
            
            // 设置Cesium Ion访问令牌
            Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiOTE1YmRiZi1hM2E3LTQ5NGUtYTI4Yy0yYTI1YjRmNmZiMzMiLCJpZCI6MjgyOTIwLCJpYXQiOjE3NDE2MTA2NTB9.bNbSodak59xJkrGIOiPcaAjaRQ3H4iJExEQiHjXDdqo';
            
            // 在file://协议下，静默处理Ion API的CORS错误
            // 这样即使Ion API请求失败，也不会影响Cesium的正常显示
            if (isFileProtocol) {
                // 拦截并静默处理Ion API的CORS错误
                const originalError = console.error;
                console.error = function(...args) {
                    // 如果是Ion API的CORS错误，静默处理
                    const message = args.join(' ');
                    if (message.includes('api.cesium.com') && message.includes('CORS')) {
                        // 静默处理，不输出错误
                        return;
                    }
                    // 其他错误正常输出
                    originalError.apply(console, args);
                };
                
                // 捕获未处理的Promise错误（Ion API请求失败）
                window.addEventListener('unhandledrejection', function(event) {
                    const reason = event.reason;
                    if (reason && typeof reason === 'object') {
                        const reasonStr = JSON.stringify(reason);
                        if (reasonStr.includes('api.cesium.com') || reasonStr.includes('CORS')) {
                            // 静默处理Ion API的CORS错误
                            event.preventDefault();
                            return;
                        }
                    }
                });
            }
            
            // 配置Cesium使用本地资源路径（避免CORS问题）
            let basePath = '';
            if (isFileProtocol) {
                // 从file://路径中提取目录
                // file:///home/xyh/GSSE/cesium_viewer.html -> file:///home/xyh/GSSE/
                const pathMatch = currentPath.match(/file:\/\/\/.*\//);
                if (pathMatch) {
                    basePath = pathMatch[0];
                } else {
                    // 如果匹配失败，尝试另一种格式 file:///path/to/file.html
                    const lastSlash = currentPath.lastIndexOf('/');
                    if (lastSlash > 0) {
                        basePath = currentPath.substring(0, lastSlash + 1);
                    }
                }
            } else {
                // 对于HTTP/HTTPS，使用相对路径
                basePath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
            }
            
            // 设置Cesium资源路径为本地lib/Cesium目录
            if (typeof Cesium !== 'undefined' && basePath) {
                const cesiumBasePath = basePath + 'lib/Cesium/';
                // 重写buildModuleUrl以使用本地路径
                const originalBuildModuleUrl = Cesium.buildModuleUrl;
                Cesium.buildModuleUrl = function(module) {
                    // 检查module参数是否有效
                    if (!module || typeof module !== 'string') {
                        return originalBuildModuleUrl ? originalBuildModuleUrl(module) : module;
                    }
                    // 如果模块路径是绝对URL，直接返回
                    if (module.startsWith('http://') || module.startsWith('https://') || module.startsWith('data:')) {
                        return originalBuildModuleUrl ? originalBuildModuleUrl(module) : module;
                    }
                    // 否则使用本地路径
                    const localPath = cesiumBasePath + module;
                    // 只在调试时输出日志
                    // console.log('[Cesium JS Info] 使用本地资源:', module, '->', localPath);
                    return localPath;
                };
                console.log('[Cesium JS Info] Cesium资源路径设置为:', cesiumBasePath);
            }
            
            // 初始化WebChannel
            // 在Qt WebEngine中，WebChannel需要等待页面完全加载
            function initWebChannel() {
                if (typeof QWebChannel !== 'undefined' && typeof qt !== 'undefined' && qt.webChannelTransport) {
                    try {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            if (channel && channel.objects && channel.objects.pyBridge) {
                                pyBridge = channel.objects.pyBridge;
                                window.pyBridge = pyBridge;
                                console.log('[Cesium JS Info] WebChannel已连接');
                            } else {
                                console.log('[Cesium JS Info] WebChannel对象未找到');
                            }
                        });
                    } catch (e) {
                        console.log('[Cesium JS Info] WebChannel初始化失败:', e);
                    }
                } else {
                    // 备用方案：直接使用window.pyBridge（如果已设置）
                    if (window.pyBridge) {
                        pyBridge = window.pyBridge;
                        console.log('[Cesium JS Info] 使用window.pyBridge');
                    } else {
                        console.log('[Cesium JS Info] WebChannel不可用，使用备用方案');
                    }
                }
            }
            
            // 延迟初始化WebChannel，确保Qt环境已准备好
            setTimeout(initWebChannel, 100);
            
            cesiumViewer = new Cesium.Viewer('cesiumContainer', {
                scene3DOnly: true,
                // 使用简化的地形以避免依赖外部服务
                terrainProvider: new Cesium.EllipsoidTerrainProvider(),
                timeline: false,
                animation: false,
                baseLayerPicker: true, 
                geocoder: false,
                homeButton: true,
                sceneModePicker: true,
                navigationHelpButton: false,
                fullscreenButton: true,
                // 在file://协议下，禁用一些需要远程服务的功能
                requestRenderMode: false, // 禁用按需渲染，确保渲染循环持续运行，以便SplatViewer更新
                maximumRenderTimeChange: undefined
            });
            
            // 在file://协议下，配置错误处理，使Ion API错误不影响显示
            if (isFileProtocol) {
                // 延迟添加事件监听器，确保globe已初始化
                setTimeout(function() {
                    if (cesiumViewer && cesiumViewer.scene && cesiumViewer.scene.globe && cesiumViewer.scene.globe.tileLoadErrorEvent) {
                        // 监听Cesium的错误事件，静默处理Ion API相关错误
                        cesiumViewer.scene.globe.tileLoadErrorEvent.addEventListener(function(error) {
                            // 静默处理瓦片加载错误（可能是CORS导致的）
                            console.log('[Cesium JS Info] 瓦片加载错误（已静默处理）:', error);
                        });
                    }
                }, 100);
            }
             // 使用Cesium默认底图，不做干预
            
            // 在file://协议下，设置地球为单色（蓝色）
            if (isFileProtocol) {
                // 延迟设置，确保globe已初始化
                setTimeout(function() {
                    if (cesiumViewer && cesiumViewer.scene && cesiumViewer.scene.globe) {
                        try {
                            // 设置地球为蓝色（使用baseColor）
                            cesiumViewer.scene.globe.baseColor = Cesium.Color.BLUE.withAlpha(0.8);
                            // 或者使用ColorMaterial（如果需要材质）
                            // cesiumViewer.scene.globe.material = new Cesium.ColorMaterial({
                            //     color: Cesium.Color.BLUE.withAlpha(0.8)
                            // });
                        } catch (e) {
                            console.log('[Cesium JS Info] 设置地球颜色失败:', e);
                            	                        }
                        }
                    }, 200);
                }
            
            // 初始化Three.js场景
            initThreeScene();
            
            // 设置渲染循环：在Cesium渲染后同步相机并渲染THREE.js场景
            cesiumViewer.scene.postRender.addEventListener(function() {
                syncCameraAndRender();
            });
            
            // 添加地形和影像选择事件监听器
            document.getElementById('terrainSelect').addEventListener('change', updateTerrain);
            document.getElementById('imagerySelect').addEventListener('change', updateImagery);

            // 启动场景信息更新
            startInfoUpdate();
            
            // 处理队列中的消息
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                window.receiveMessageFromPython(msg);
            }
            
            isInitialized = true;
            console.log('[Cesium JS Info] 初始化完成');
            
            // 监听容器尺寸变化，确保Cesium在容器尺寸变为有效时正确调整
            // 这在Qt WebEngine中很重要，因为未激活的标签页容器尺寸可能为0
            let lastWidth = cesiumContainer.offsetWidth;
            let lastHeight = cesiumContainer.offsetHeight;
            
            // 使用ResizeObserver监听容器尺寸变化（如果支持）
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(function(entries) {
                    for (const entry of entries) {
                        const width = entry.contentRect.width;
                        const height = entry.contentRect.height;
                        if (width > 0 && height > 0 && (width !== lastWidth || height !== lastHeight)) {
                            lastWidth = width;
                            lastHeight = height;
                            console.log('[Cesium JS Info] 容器尺寸变化，调整Cesium Viewer:', width, 'x', height);
                            if (cesiumViewer) {
                                cesiumViewer.resize();
                            }
                            if (threeRenderer) {
                                threeRenderer.setSize(width, height);
                                threeCamera.aspect = width / height;
                                threeCamera.updateProjectionMatrix();
                            }
                        }
                    }
                });
                resizeObserver.observe(cesiumContainer);
            } else {
                // 备用方案：定期检查容器尺寸
                const checkSizeInterval = setInterval(function() {
                    const width = cesiumContainer.offsetWidth;
                    const height = cesiumContainer.offsetHeight;
                    if (width > 0 && height > 0 && (width !== lastWidth || height !== lastHeight)) {
                        lastWidth = width;
                        lastHeight = height;
                        console.log('[Cesium JS Info] 容器尺寸变化，调整Cesium Viewer:', width, 'x', height);
                        if (cesiumViewer) {
                            cesiumViewer.resize();
                        }
                        if (threeRenderer) {
                            threeRenderer.setSize(width, height);
                            threeCamera.aspect = width / height;
                            threeCamera.updateProjectionMatrix();
                        }
                    }
                }, 500); // 每500ms检查一次
                
                // 在窗口大小变化时也检查
                window.addEventListener('resize', function() {
                    const width = cesiumContainer.offsetWidth;
                    const height = cesiumContainer.offsetHeight;
                    if (width > 0 && height > 0) {
                        if (cesiumViewer) {
                            cesiumViewer.resize();
                        }
                        if (threeRenderer) {
                            threeRenderer.setSize(width, height);
                            threeCamera.aspect = width / height;
                            threeCamera.updateProjectionMatrix();
                        }
                    }
                });
            }
            
            // 通知Python初始化完成
            function notifyPython() {
                if (pyBridge && pyBridge.receiveMessage) {
                    try {
                        pyBridge.receiveMessage(JSON.stringify({
                            type: 'viewerReady',
                            message: 'Cesium viewer已初始化'
                        }));
                    } catch (e) {
                        console.log('[Cesium JS Info] 通知Python失败:', e);
                    }
                } else if (window.pyBridge && window.pyBridge.receiveMessage) {
                    try {
                        window.pyBridge.receiveMessage(JSON.stringify({
                            type: 'viewerReady',
                            message: 'Cesium viewer已初始化'
                        }));
                    } catch (e) {
                        console.log('[Cesium JS Info] 通知Python失败:', e);
                    }
                }
            }
            
            // 延迟通知，确保WebChannel已连接
            setTimeout(notifyPython, 500);
            
            } catch (error) {
                console.error('[Cesium JS Error] 初始化失败:', error);
                isInitializing = false;
            }
        };
        
        function initThreeScene() {
            // 创建Three.js场景
            threeScene = new THREE.Scene();
            
            // 创建相机（将使用Cesium相机）
            // 增加far plane到1e10，以适应Cesium的ECEF坐标系（地球半径约6.3e6米）
            threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1e10);
            threeScene.add(threeCamera);
            
            // 创建渲染器
            threeRenderer = new THREE.WebGLRenderer({
                alpha: true
            });
            // 移除setPixelRatio，因为GaussianSplats3D配置了ignoreDevicePixelRatio: true
            // 且GSSEW参考实现中没有设置此项，设置它可能导致视口计算错误
            // threeRenderer.setPixelRatio(window.devicePixelRatio);
            threeRenderer.setSize(window.innerWidth, window.innerHeight);
            // 移除autoClear = false，使用默认值true，与GSSEW保持一致
            // 这样每帧都会清除Three.js的颜色和深度缓冲区，避免累积和深度测试问题
            threeRenderer.autoClear = false; // 手动控制清除，避免多重渲染时的清除问题
            
            const threeContainer = document.getElementById('threeContainer');
            threeContainer.appendChild(threeRenderer.domElement);
            
            // 监听窗口大小变化
            window.addEventListener('resize', function() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                threeRenderer.setSize(width, height);
                threeCamera.aspect = width / height;
                threeCamera.updateProjectionMatrix();
            });
        }
        
        // 同步Cesium相机到THREE.js相机并渲染（参考cesium-gaussian-splatting项目）
        function syncCameraAndRender() {
            if (!cesiumViewer || !threeCamera || !threeRenderer) return;

            // 手动清除缓冲区
            threeRenderer.clear();
            
            // 同步相机FOV
            threeCamera.fov = Cesium.Math.toDegrees(cesiumViewer.camera.frustum.fovy);
            threeCamera.updateProjectionMatrix();
            
            // 从Cesium相机获取视图矩阵
            const cesiumCamera = cesiumViewer.camera;
            const cvm = cesiumCamera.viewMatrix;
            const civm = cesiumCamera.inverseViewMatrix;
            
            // 提取相机位置
            const cameraPosition = Cesium.Cartesian3.fromElements(
                civm[12],
                civm[13],
                civm[14]
            );
            
            // 提取相机方向
            const cameraDirection = new Cesium.Cartesian3(-cvm[2], -cvm[6], -cvm[10]);
            const cameraUp = new Cesium.Cartesian3(cvm[1], cvm[5], cvm[9]);
            
            // 转换为THREE.js向量
            const cameraPositionVec3 = new THREE.Vector3(
                cameraPosition.x,
                cameraPosition.y,
                cameraPosition.z
            );
            const cameraDirectionVec3 = new THREE.Vector3(
                cameraDirection.x,
                cameraDirection.y,
                cameraDirection.z
            );
            const cameraUpVec3 = new THREE.Vector3(cameraUp.x, cameraUp.y, cameraUp.z);
            
            // 更新THREE.js相机
            threeCamera.position.copy(cameraPositionVec3);
            threeCamera.up.copy(cameraUpVec3);
            threeCamera.lookAt(cameraPositionVec3.clone().add(cameraDirectionVec3));
            
            // 关键：手动更新相机矩阵，确保splatViewer.update()使用的是最新的相机状态
            threeCamera.updateMatrixWorld(true);
            
            // 更新并渲染所有高斯模型（严格按照cesium-gaussian-splatting项目）
            // 根据cesium-gaussian-splatting的实现：
            // 1. 先调用splatViewer.update()更新状态
            // 2. 然后调用splatViewer.render()渲染splatMesh
            // 3. 最后调用threeRenderer.render()渲染scene中的其他对象
            let needBoundsUpdate = false;
            gaussianSplatLayers.forEach(function(layer) {
                if (!layer.ready) return;
                if (layer.visible === false) return; // 如果不可见，跳过渲染
                
                // 确保scene和mesh的世界变换矩阵已更新
                // 这是关键：因为mesh在scene中，而scene的位置是Cesium坐标（非常大的数字）
                // 需要确保世界变换矩阵正确计算
                if (layer.scene) {
                    layer.scene.updateMatrixWorld(true);
                    
                    // 调试：检查mesh的世界位置（仅在第一次渲染时输出）
                    if (layer._firstRender === undefined) {
                        layer._firstRender = true;
                        const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                        if (mesh) {
                            const worldPos = new THREE.Vector3();
                            mesh.getWorldPosition(worldPos);
                            console.log('[Cesium JS Info] 首次渲染 - Mesh世界位置:', worldPos.x, worldPos.y, worldPos.z);
                            console.log('[Cesium JS Info] 首次渲染 - Scene位置:', layer.scene.position.x, layer.scene.position.y, layer.scene.position.z);
                            console.log('[Cesium JS Info] 首次渲染 - 相机位置:', threeCamera.position.x, threeCamera.position.y, threeCamera.position.z);
                        }
                    }
                }
                
                if (layer._needsBoundsUpdate) {
                    needBoundsUpdate = true;
                }
                
                // 调用splatViewer的update和render方法（严格按照cesium-gaussian-splatting项目）
                try {
                    if (layer.splatViewer && typeof layer.splatViewer.update === 'function') {
                        layer.splatViewer.update();
                    }
                    
                    // 恢复splatViewer.render()，因为GSSEW参考实现中调用了它
                    // 这可能对触发worker数据传输或状态更新是必要的
                    if (layer.splatViewer && typeof layer.splatViewer.render === 'function') {
                        layer.splatViewer.render();
                    }

                    const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                    const instanceCount = mesh && mesh.geometry ? mesh.geometry.instanceCount : null;
                    
                    if (layer._debugLogged !== true) {
                        const renderCount = (mesh && mesh.geometry && mesh.geometry.drawRange) ? mesh.geometry.drawRange.count : null;
                        console.log('[Cesium JS Info] 首次渲染 - geometry.instanceCount:', instanceCount);
                        console.log('[Cesium JS Info] 首次渲染 - geometry.drawRange.count:', renderCount);
                        if (mesh && mesh.getSplatCount) {
                            console.log('[Cesium JS Info] 首次渲染 - 总splats:', mesh.getSplatCount());
                        }
                        layer._debugLogged = true;
                    }
                    
                    // 如果instanceCount变为正数且之前是0，记录一下
                    if (instanceCount > 0 && !layer._hasShownInstanceCount) {
                        console.log('[Cesium JS Info] geometry.instanceCount已更新为:', instanceCount);
                        layer._hasShownInstanceCount = true;
                    }
                    
                    // 每60帧（约1秒）输出一次调试信息
                    if (!layer._frameCount) layer._frameCount = 0;
                    layer._frameCount++;
                    if (layer._frameCount % 60 === 0) {
                         if (instanceCount === 0) {
                             console.log('[Cesium JS Info] 等待Splat排序... instanceCount:', instanceCount);
                             // 调试：检查相机和Mesh的距离及状态
                             if (mesh) {
                                 const meshPos = new THREE.Vector3();
                                 mesh.getWorldPosition(meshPos);
                                 const dist = threeCamera.position.distanceTo(meshPos);
                                 console.log('[Cesium JS Info] Debug Info:', JSON.stringify({
                                     distToCamera: dist,
                                     meshPos: {x: meshPos.x, y: meshPos.y, z: meshPos.z},
                                     visible: mesh.visible,
                                     frustumCulled: mesh.frustumCulled,
                                     materialVisible: mesh.material ? mesh.material.visible : 'no material'
                                 }));
                             }
                         }
                    }
                } catch (e) {
                    console.warn('[Cesium JS Warning] 更新/渲染模型时出错:', e);
                    console.error('[Cesium JS Error] 错误详情:', e);
                }
            });
            
            if (needBoundsUpdate) {
                calculateBoundingSphere();
            }
            
            // 根据cesium-gaussian-splatting项目，在splatViewer.render()之后，
            // 还需要调用threeRenderer.render()来渲染scene中的其他对象
            // 虽然splatViewer.render()已经渲染了splatMesh，但threeRenderer.render()不会重复渲染
            // 因为splatMesh已经在splatViewer.render()中渲染过了
            threeRenderer.render(threeScene, threeCamera);
        }
        
        function updateTerrain() {
            const select = document.getElementById('terrainSelect');
            const value = select.options[select.selectedIndex].value;
            
            if (value === 'world') {
                cesiumViewer.terrainProvider = Cesium.createWorldTerrain();
            } else {
                cesiumViewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
            }
        }
        
        function updateImagery(fallbackAttempted = false) {
            const select = document.getElementById('imagerySelect');
            const value = select.options[select.selectedIndex].value;
            let provider = null;
            
            try {
                switch (value) {
                    case 'bing':
                        provider = new Cesium.BingMapsImageryProvider({
                            url: 'https://dev.virtualearth.net',
                            key: 'AuhfJZVHlwH7UQ8cW8lqFuF7q7nCxTfa5bkCbEMjXjzQ57b9sV_8s8pE7zR7Z-iN',
                            mapStyle: Cesium.BingMapsStyle.AERIAL
                        });
                        break;
                    case 'osm':
                        provider = new Cesium.OpenStreetMapImageryProvider({
                            url: 'https://a.tile.openstreetmap.org/'
                        });
                        break;
                    case 'arcgis':
                        provider = new Cesium.ArcGisMapServerImageryProvider({
                            url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
                        });
                        break;
                }
            } catch (error) {
                console.error(`[Cesium JS Error] 创建影像图层失败(${value}):`, error);
                if (!fallbackAttempted && value !== 'osm') {
                    console.log('[Cesium JS Info] 回退到OpenStreetMap影像');
                    select.value = 'osm';
                    updateImagery(true);
                }
                return;
            }

            if (!provider) {
                console.warn('[Cesium JS Warning] 未创建新的影像图层提供者');
                return;
            }
            
            let oldLayer = null;
            if (cesiumViewer.imageryLayers.length > 0) {
                oldLayer = cesiumViewer.imageryLayers.get(0);
            }

            let newLayer = null;
            try {
                newLayer = cesiumViewer.imageryLayers.addImageryProvider(provider);
            } catch (error) {
                console.error(`[Cesium JS Error] 添加影像图层失败(${value}):`, error);
                if (!fallbackAttempted && value !== 'osm') {
                    console.log('[Cesium JS Info] 回退到OpenStreetMap影像');
                    select.value = 'osm';
                    updateImagery(true);
                }
                return;
            }

            if (oldLayer) {
                cesiumViewer.imageryLayers.remove(oldLayer);
            }

            if (provider.readyPromise && typeof provider.readyPromise.then === 'function') {
                provider.readyPromise.then(function() {
                    console.log(`[Cesium JS Info] 影像图层已准备就绪: ${value}`);
                }).catch(function(error) {
                    console.error(`[Cesium JS Error] 影像图层加载失败(${value}):`, error);
                    if (!fallbackAttempted && value !== 'osm') {
                        console.log('[Cesium JS Info] 回退到OpenStreetMap影像');
                        select.value = 'osm';
                        updateImagery(true);
                    }
                });
            }
            if (provider.errorEvent && typeof provider.errorEvent.addEventListener === 'function') {
                provider.errorEvent.addEventListener(function(error) {
                    console.error(`[Cesium JS Error] 影像图层请求错误(${value}):`, error);
                });
            }

            if (newLayer && typeof newLayer.show === 'boolean') {
                newLayer.show = true;
            }
        }
        
        async function loadModel(data) {
            try {
                let resourceUrl = data.url || '';
                const lon = data.location.lon;
                const lat = data.location.lat;
                const height = data.location.height || 0;
                const scale = data.scale || 1.0;
                const rotation = data.rotation || {x: 0, y: 0, z: 0};
                const modelId = data.modelId || `model_${Date.now()}`;
                const isSegment = data.isSegment || false;
                const segmentId = data.segmentId || null;

                let arrayBuffer = null;
                // 对 data URL 不再做转换，直接交给 addSplatScene 处理，避免内存问题
                // 对 http/https 同理

                const position = Cesium.Cartesian3.fromDegrees(lon, lat, height);

                    const splatConfig = {
                        selfDrivenMode: false,
                        gpuAcceleratedSort: false, // 禁用GPU排序，避免worker问题
                        sharedMemoryForWorkers: false, // 禁用共享内存
                        ignoreDevicePixelRatio: true,
                        sceneRevealMode: window.GaussianSplats3D.SceneRevealMode.Always,
                        useBuiltInControls: false,
                        enableSIMDInSort: false, // 禁用SIMD
                        camera: threeCamera,
                        renderer: threeRenderer,
                        logLevel: window.GaussianSplats3D.LogLevel.Info
                    };
                    console.log('[Cesium JS Info] SplatConfig:', JSON.stringify(splatConfig));

                const splatViewer = new window.GaussianSplats3D.Viewer(splatConfig);

                // 创建父场景并放置在指定位置
                // 参考GSSEW项目：直接将splat场景放在世界位置会导致抖动
                // 因此使用父场景包裹，并在父场景上设置位置和旋转
                const scene = new THREE.Scene();
                scene.position.set(position.x, position.y, position.z);
                // 应用旋转 - 注意：这里的旋转是相对于Cesium坐标系的
                scene.rotation.set(rotation.x, rotation.y, rotation.z);

                const layer = {
                    scene,
                    splatViewer,
                    ready: false,
                    modelId,
                    isSegment,
                    segmentId,
                    geoLocation: { lon, lat, height },
                    scale,
                    rotation: { x: rotation.x, y: rotation.y, z: rotation.z },
                    blobUrl: resourceUrl.startsWith('blob:') ? resourceUrl : null,
                    _needsBoundsUpdate: true,
                    _pendingFlyTo: data.flyTo !== false,
                    visible: true  // 添加可见性控制
                };

                {
                    const isDataUrl = resourceUrl.startsWith('data:');
                    const splatOptions = {
                        showLoadingUI: false,
                        progressiveLoad: false, // 统一关闭，规避部分环境/服务器的渐进式加载问题
                        rotation: [0, 0, 0],
                        scale: [1, 1, 1]
                    };
                    // 显式指定格式
                    if (data.format) {
                        splatOptions.format = data.format;
                    } else if (isDataUrl || resourceUrl.toLowerCase().endsWith('.splat')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.Splat;
                    } else if (resourceUrl.toLowerCase().endsWith('.ply')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.Ply;
                    } else if (resourceUrl.toLowerCase().endsWith('.ksplat')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.KSplat;
                    }
                    await splatViewer.addSplatScene(resourceUrl, splatOptions);
                }

                const mesh = splatViewer.getSplatMesh();
                if (!mesh) {
                    throw new Error('未能获取到SplatMesh');
                }
                console.log('[Cesium JS Info] 3DGS模型加载成功:', modelId);

                // 应用缩放到mesh
                mesh.scale.set(scale, scale, scale);
                // 禁用视锥体剔除，防止因包围盒计算不准导致消失
                mesh.frustumCulled = false;
                
                // 确保mesh被添加到layer.scene（如果还没有添加）
                if (mesh.parent !== layer.scene) {
                    layer.scene.add(mesh);
                }
                
                // 确保mesh的初始旋转是正确的（相对于父scene）
                // 修正倒立问题：绕X轴旋转180度
                mesh.rotation.set(Math.PI, 0, 0);
                
                layer.scene.updateMatrixWorld(true);
                threeScene.add(layer.scene);
                
                console.log('[Cesium JS Info] Mesh added to scene. Mesh parent:', mesh.parent ? 'layer.scene' : 'null');

                layer.ready = true;
                gaussianSplatLayers.push(layer);
                calculateBoundingSphere();
                document.getElementById('modelCount').textContent = gaussianSplatLayers.length;
                
                // 更新模型列表UI
                updateModelListUI();

                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'loadComplete',
                        success: true,
                        modelId,
                        isSegment,
                        segmentId
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] 加载3DGS模型时出错:', error);
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'loadComplete',
                        success: false,
                        error: error.message || String(error),
                        modelId: data.modelId || 'unknown'
                    }));
                }
            }
        }
        
        // 对齐项目结构：提供与 cesium-gaussian-splatting 相同的入口
        function load3DGS(data) {
            return loadModel(data);
        }
        // 暴露为全局，供 Qt/Python 调用
        window.load3DGS = load3DGS;
        
        function calculateBoundingSphere() {
            if (gaussianSplatLayers.length === 0) {
                modelBoundingSphere = null;
                return;
            }
            
            // 计算所有模型的联合边界球
            // 使用geoLocation和mesh的boundingBox来计算
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            let hasValidBounds = false;
            
            for (const layer of gaussianSplatLayers) {
                try {
                    if (!layer.ready || !layer.scene) continue;

                    const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                    let boundsUpdated = false;

                    // 尝试获取SplatMesh的包围盒
                    // 注意：GaussianSplats3D的mesh.boundingBox可能未计算或为空
                    if (mesh && !boundsUpdated) {
                        // 强制更新一次矩阵，确保localToWorld正确
                        mesh.updateMatrixWorld(true);
                        
                        // 优先使用geometry的boundingBox，因为它是原始数据的包围盒
                        if (mesh.geometry && !mesh.geometry.boundingBox) {
                            mesh.geometry.computeBoundingBox();
                        }
                        
                        let box = null;
                        if (mesh.geometry && mesh.geometry.boundingBox) {
                            box = mesh.geometry.boundingBox;
                        } else if (mesh.boundingBox) {
                            box = mesh.boundingBox;
                        }
                        
                        // 检查box是否有效（非空且非无限）
                        const isValidBox = box &&
                                         isFinite(box.min.x) && isFinite(box.min.y) && isFinite(box.min.z) &&
                                         isFinite(box.max.x) && isFinite(box.max.y) && isFinite(box.max.z) &&
                                         (box.max.x > box.min.x || box.max.y > box.min.y || box.max.z > box.min.z);

                        if (isValidBox) {
                            console.log('[Cesium JS Info] 使用Mesh/Geometry BoundingBox:', JSON.stringify(box));
                            const corners = [
                                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                                new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                            ];

                            corners.forEach((corner) => {
                                // 将局部坐标转换为世界坐标
                                // 注意：mesh在layer.scene中，layer.scene在threeScene中
                                // mesh.localToWorld会考虑所有父级变换
                                const worldCorner = corner.clone();
                                mesh.localToWorld(worldCorner);
                                
                                minX = Math.min(minX, worldCorner.x);
                                minY = Math.min(minY, worldCorner.y);
                                minZ = Math.min(minZ, worldCorner.z);
                                maxX = Math.max(maxX, worldCorner.x);
                                maxY = Math.max(maxY, worldCorner.y);
                                maxZ = Math.max(maxZ, worldCorner.z);
                            });

                            hasValidBounds = true;
                            boundsUpdated = true;
                        }
                    }

                    // 如果没有mesh或无法计算，回退到geoLocation
                    if (!boundsUpdated && layer.geoLocation) {
                        const pos = Cesium.Cartesian3.fromDegrees(
                            layer.geoLocation.lon,
                            layer.geoLocation.lat,
                            layer.geoLocation.height
                        );
                        const radius = 100;

                        minX = Math.min(minX, pos.x - radius);
                        minY = Math.min(minY, pos.y - radius);
                        minZ = Math.min(minZ, pos.z - radius);
                        maxX = Math.max(maxX, pos.x + radius);
                        maxY = Math.max(maxY, pos.y + radius);
                        maxZ = Math.max(maxZ, pos.z + radius);

                        hasValidBounds = true;
                    }

                    // 如果boundingBox不可用，但有场景中心和最大距离，使用它来估算
                    if (!boundsUpdated && mesh && mesh.calculatedSceneCenter && mesh.maxSplatDistanceFromSceneCenter) {
                        console.log('[Cesium JS Info] 使用maxSplatDistance计算边界:', mesh.maxSplatDistanceFromSceneCenter);
                        const centerLocal = mesh.calculatedSceneCenter.clone();
                        const worldCenter = centerLocal.clone();
                        layer.scene.localToWorld(worldCenter);
                        const radius = mesh.maxSplatDistanceFromSceneCenter * (layer.scale || 1);

                        minX = Math.min(minX, worldCenter.x - radius);
                        minY = Math.min(minY, worldCenter.y - radius);
                        minZ = Math.min(minZ, worldCenter.z - radius);
                        maxX = Math.max(maxX, worldCenter.x + radius);
                        maxY = Math.max(maxY, worldCenter.y + radius);
                        maxZ = Math.max(maxZ, worldCenter.z + radius);

                        hasValidBounds = true;
                        boundsUpdated = true;
                    }

                    if (boundsUpdated) {
                        layer._needsBoundsUpdate = false;
                    }

                } catch (e) {
                    console.warn('[Cesium JS Warning] 计算边界球时出错:', e);
                }
            }
            
            if (hasValidBounds) {
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const radius = Math.sqrt(
                    Math.pow(maxX - minX, 2) + 
                    Math.pow(maxY - minY, 2) + 
                    Math.pow(maxZ - minZ, 2)
                ) / 2;
                
                modelBoundingSphere = {
                    center: [centerX, centerY, centerZ],
                    radius: radius
                };
            } else {
                // 回退：使用第一个模型的位置
                const firstLayer = gaussianSplatLayers[0];
                if (firstLayer && firstLayer.geoLocation) {
                    const pos = Cesium.Cartesian3.fromDegrees(
                        firstLayer.geoLocation.lon,
                        firstLayer.geoLocation.lat,
                        firstLayer.geoLocation.height
                    );
                    modelBoundingSphere = {
                        center: [pos.x, pos.y, pos.z],
                        radius: 100
                    };
                }
            }

            if (modelBoundingSphere) {
                console.log('[Cesium JS Info] 边界球计算结果:', JSON.stringify(modelBoundingSphere));
                const pendingFlyLayers = gaussianSplatLayers.filter(layer => layer._pendingFlyTo);
                if (pendingFlyLayers.length > 0) {
                    pendingFlyLayers.forEach(layer => layer._pendingFlyTo = false);
                    console.log('[Cesium JS Info] 边界球已计算，执行飞行');
                    flyToModel();
                }
            }
        }
        
        function loadSegment(data) {
            console.log('[Cesium JS Info] 加载分割模型:', data);
            
            // 使用load3DGS函数，但标记为分割模型
            const segmentData = {
                ...data,
                isSegment: true,
                modelId: data.segmentId || `segment_${Date.now()}`
            };
            
            load3DGS(segmentData);
        }
        
        function highlightSegment(data) {
            const segmentId = data.segmentId;
            console.log('[Cesium JS Info] 高亮分割:', segmentId);
            
            // 查找对应的分割模型
            const segment = gaussianSplatLayers.find(splat => 
                splat.isSegment && splat.segmentId === segmentId
            );
            
            if (segment) {
                // 临时高亮效果：调整透明度或颜色
                // 这里可以实现更复杂的高亮效果
                console.log('[Cesium JS Info] 找到分割模型，应用高亮效果');
                
                // 通知Python高亮完成
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'highlightComplete',
                        success: true,
                        segmentId: segmentId
                    }));
                }
            } else {
                console.warn('[Cesium JS Warning] 未找到分割模型:', segmentId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'highlightComplete',
                        success: false,
                        error: '未找到分割模型',
                        segmentId: segmentId
                    }));
                }
            }
        }
        
        function removeModel(data) {
            const modelId = data.modelId;
            console.log('[Cesium JS Info] 移除模型:', modelId);
            
            const index = gaussianSplatLayers.findIndex(layer => layer.modelId === modelId);
            
            if (index !== -1) {
                const layer = gaussianSplatLayers[index];
                
                // 清理Blob URL（如果存在）
                if (layer.blobUrl) {
                    try {
                        URL.revokeObjectURL(layer.blobUrl);
                        console.log('[Cesium JS Info] 已清理Blob URL');
                    } catch (e) {
                        console.warn('[Cesium JS Warning] 清理Blob URL失败:', e);
                    }
                }
                
                // 清理资源（参考cesium-gaussian-splatting项目）
                if (layer.splatViewer && layer.splatViewer.dispose) {
                    layer.splatViewer.dispose().catch(err => {
                        console.warn('[Cesium JS Warning] 清理模型资源时出错:', err);
                    });
                }
                
                // 从场景中移除（参考cesium-gaussian-splatting项目）
                if (layer.scene) {
                    threeScene.remove(layer.scene);
                }
                
                gaussianSplatLayers.splice(index, 1);
                
                // 重新计算边界球
                calculateBoundingSphere();
                
                // 更新模型计数
                document.getElementById('modelCount').textContent = gaussianSplatLayers.length;
                
                // 更新模型列表UI
                updateModelListUI();
                
                console.log('[Cesium JS Info] 模型移除成功:', modelId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'removeComplete',
                        success: true,
                        modelId: modelId
                    }));
                }
            } else {
                console.warn('[Cesium JS Warning] 未找到模型:', modelId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'removeComplete',
                        success: false,
                        error: '未找到模型',
                        modelId: modelId
                    }));
                }
            }
        }
        
        function clearAllModels() {
            console.log('[Cesium JS Info] 清除所有模型');
            
            // 移除所有高斯模型（参考cesium-gaussian-splatting项目）
            for (const layer of gaussianSplatLayers) {
                // 清理Blob URL（如果存在）
                if (layer.blobUrl) {
                    try {
                        URL.revokeObjectURL(layer.blobUrl);
                    } catch (e) {
                        console.warn('[Cesium JS Warning] 清理Blob URL失败:', e);
                    }
                }
                
                // 清理资源
                if (layer.splatViewer && layer.splatViewer.dispose) {
                    layer.splatViewer.dispose().catch(err => {
                        console.warn('[Cesium JS Warning] 清理模型资源时出错:', err);
                    });
                }
                
                // 从场景中移除
                if (layer.scene) {
                    threeScene.remove(layer.scene);
                }
            }
            gaussianSplatLayers = [];
            
            // 重置边界球
            modelBoundingSphere = null;
            
            // 更新模型计数
            document.getElementById('modelCount').textContent = '0';
        }
        
        function setCameraPosition(data) {
            if (!cesiumViewer) return;
            
            const position = Cesium.Cartesian3.fromDegrees(
                data.longitude, 
                data.latitude, 
                data.height
            );
            
            cesiumViewer.camera.setView({
                destination: position,
                orientation: {
                    heading: data.heading || 0,
                    pitch: data.pitch || -Cesium.Math.PI_OVER_FOUR,
                    roll: data.roll || 0
                }
            });
        }
        
        function resetCamera() {
            if (!cesiumViewer) return;
            
            cesiumViewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(116.391, 39.907, 1500),
                orientation: {
                    heading: 0,
                    pitch: -Cesium.Math.PI_OVER_FOUR,
                    roll: 0
                }
            });
        }
        
        // 相对移动相机（平移）
        function moveCamera(data) {
            if (!cesiumViewer) return;
            
            const dx = data.x || 0; // 左右移动
            const dy = data.y || 0; // 上下移动
            const dz = data.z || 0; // 前后移动
            
            // 获取当前相机高度，用于调整移动速度
            const height = cesiumViewer.camera.positionCartographic.height;
            const moveFactor = height / 1000.0; // 根据高度调整移动速度
            
            if (dx !== 0) {
                cesiumViewer.camera.moveRight(dx * moveFactor);
            }
            if (dy !== 0) {
                cesiumViewer.camera.moveUp(dy * moveFactor);
            }
            if (dz !== 0) {
                cesiumViewer.camera.moveForward(dz * moveFactor);
            }
        }
        
        // 缩放相机
        function zoomCamera(data) {
            if (!cesiumViewer) return;
            
            const amount = data.amount || 0;
            const height = cesiumViewer.camera.positionCartographic.height;
            
            // 限制最小高度
            if (amount > 0 && height < 10) return;
            
            cesiumViewer.camera.zoomIn(amount * height * 0.1);
        }
        
        // 旋转相机
        function rotateCamera(data) {
            if (!cesiumViewer) return;
            
            const heading = data.heading || 0; // 左右旋转
            const pitch = data.pitch || 0;     // 上下旋转
            
            if (heading !== 0) {
                cesiumViewer.camera.lookRight(heading);
            }
            if (pitch !== 0) {
                cesiumViewer.camera.lookUp(pitch);
            }
        }

        function resetView() {
            if (!cesiumViewer) return;
            cesiumViewer.camera.flyHome(1.0);
        }

        function setTopView() {
            if (!cesiumViewer) return;
            const camera = cesiumViewer.camera;
            const cartographic = camera.positionCartographic;
            
            cesiumViewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromRadians(
                    cartographic.longitude,
                    cartographic.latitude,
                    cartographic.height
                ),
                orientation: {
                    heading: 0.0,
                    pitch: Cesium.Math.toRadians(-90.0),
                    roll: 0.0
                }
            });
        }
        
        // 截图功能：合并Cesium和Three.js的canvas，不包含UI面板
        function captureScreenshot(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                // 等待一帧渲染完成后再截图
                cesiumViewer.scene.render();
                
                // 使用requestAnimationFrame确保渲染完成
                requestAnimationFrame(function() {
                    const cesiumCanvas = cesiumViewer.scene.canvas;
                    if (!cesiumCanvas || cesiumCanvas.width === 0 || cesiumCanvas.height === 0) {
                        console.error('[Cesium JS Error] Cesium Canvas无效');
                        return;
                    }
                    
                    // 获取Three.js渲染器的canvas
                    let threeCanvas = null;
                    if (threeRenderer && threeRenderer.domElement) {
                        threeCanvas = threeRenderer.domElement;
                    }
                    
                    // 创建合并的canvas
                    const mergedCanvas = document.createElement('canvas');
                    mergedCanvas.width = cesiumCanvas.width;
                    mergedCanvas.height = cesiumCanvas.height;
                    const ctx = mergedCanvas.getContext('2d');
                    
                    // 先绘制Cesium场景（作为背景）
                    ctx.drawImage(cesiumCanvas, 0, 0);
                    
                    // 如果有Three.js canvas，叠加绘制（Three.js渲染的内容在Cesium之上）
                    if (threeCanvas && threeCanvas.width > 0 && threeCanvas.height > 0) {
                        // Three.js canvas可能尺寸不同，需要缩放
                        ctx.drawImage(threeCanvas, 0, 0, mergedCanvas.width, mergedCanvas.height);
                    }
                    
                    // 将合并后的canvas转换为base64图像
                    const dataURL = mergedCanvas.toDataURL('image/png');
                    
                    // 通过pyBridge发送回Python
                    if (pyBridge && pyBridge.receiveMessage) {
                        pyBridge.receiveMessage(JSON.stringify({
                            type: 'screenshotCaptured',
                            data: {
                                imageData: dataURL,
                                width: mergedCanvas.width,
                                height: mergedCanvas.height
                            }
                        }));
                    } else {
                        console.error('[Cesium JS Error] pyBridge未初始化');
                    }
                });
            } catch (error) {
                console.error('[Cesium JS Error] 截图失败:', error);
            }
        }
        
        // 添加点标签功能
        function addPointLabels(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                const points = data.points || [];
                if (points.length === 0) {
                    console.warn('[Cesium JS Warning] 没有要显示的点');
                    return;
                }
                
                // 清除之前的点标签
                if (window.cornerPointLabels) {
                    window.cornerPointLabels.forEach(function(label) {
                        cesiumViewer.entities.remove(label);
                    });
                }
                window.cornerPointLabels = [];
                
                // 添加新的点标签
                points.forEach(function(point, index) {
                    // 确保longitude和latitude是弧度
                    const lon = typeof point.longitude === 'number' ? point.longitude : Cesium.Math.toRadians(point.longitude);
                    const lat = typeof point.latitude === 'number' ? point.latitude : Cesium.Math.toRadians(point.latitude);
                    
                    const entity = cesiumViewer.entities.add({
                        name: `CornerPoint_${index + 1}`,
                        position: Cesium.Cartesian3.fromRadians(
                            lon,
                            lat,
                            point.height || 0
                        ),
                        point: {
                            pixelSize: 20, // 增大点的大小
                            color: point.color ? Cesium.Color.fromBytes(point.color[0], point.color[1], point.color[2]) : Cesium.Color.RED,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 3, // 增加轮廓宽度
                            heightReference: Cesium.HeightReference.NONE, // 不使用贴地，使用绝对高度
                            disableDepthTestDistance: Number.POSITIVE_INFINITY // 禁用深度测试，确保点始终可见
                        },
                        label: {
                            text: point.label || `P${index + 1}`,
                            font: '16px sans-serif', // 增大字体
                            fillColor: Cesium.Color.YELLOW, // 使用黄色标签更明显
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 3,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -50), // 调整偏移
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY // 禁用深度测试
                        }
                    });
                    
                    window.cornerPointLabels.push(entity);
                    console.log(`[Cesium JS Info] 已添加角点${index + 1}标签，位置: (${Cesium.Math.toDegrees(lon).toFixed(6)}, ${Cesium.Math.toDegrees(lat).toFixed(6)}, ${point.height || 0})`);
                });
                
                console.log(`[Cesium JS Info] 已添加${points.length}个角点标签`);
            } catch (error) {
                console.error('[Cesium JS Error] 添加点标签失败:', error);
            }
        }
        
        // 可视化角点和射线（显示四个交点、四边形和视锥体）
        function visualizeCornerPointsAndRays(cornerPoints3DThree, threeCamera, pixelPoints, imageWidth, imageHeight) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene || !threeCamera) {
                    console.error('[Cesium JS Error] 无法可视化：viewer或相机未初始化');
                    return;
                }
                
                if (!cornerPoints3DThree || cornerPoints3DThree.length !== 4) {
                    console.warn('[Cesium JS Warning] 角点数量不正确，无法可视化');
                    return;
                }
                
                // 清除之前的可视化
                clearCornerPointsVisualization();
                
                // 1. 在Cesium中显示四个角点（红色点标签）
                const cornerPointsGeo = [];
                cornerPoints3DThree.forEach((pt, idx) => {
                    try {
                        // 将Three.js坐标转换为Cesium ECEF坐标
                        const ecefPoint = new Cesium.Cartesian3(pt.x, pt.y, pt.z);
                        const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                        
                        // 检查坐标是否有效
                        if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude)) {
                            const lonDeg = Cesium.Math.toDegrees(cartographic.longitude);
                            const latDeg = Cesium.Math.toDegrees(cartographic.latitude);
                            
                            console.log(`[Cesium JS Info] 角点${idx + 1}转换: Three.js(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.z.toFixed(2)}) -> 地理(${lonDeg.toFixed(6)}, ${latDeg.toFixed(6)}, ${cartographic.height.toFixed(2)})`);
                            
                            cornerPointsGeo.push({
                                longitude: cartographic.longitude, // 已经是弧度
                                latitude: cartographic.latitude, // 已经是弧度
                                height: cartographic.height,
                                label: `P${idx + 1}`,
                                color: [255, 0, 0] // 红色
                            });
                            console.log(`[Cesium JS Info] 角点${idx + 1}添加到cornerPointsGeo，经纬度(弧度): (${cartographic.longitude.toFixed(6)}, ${cartographic.latitude.toFixed(6)})`);
                        } else {
                            console.warn(`[Cesium JS Warning] 角点${idx + 1}坐标无效: lon=${cartographic.longitude}, lat=${cartographic.latitude}`);
                        }
                    } catch (e) {
                        console.warn(`[Cesium JS Warning] 无法转换角点${idx + 1}坐标:`, e);
                    }
                });
                
                console.log(`[Cesium JS Info] 成功转换${cornerPointsGeo.length}个角点坐标`);
                
                // 添加角点标签
                if (cornerPointsGeo.length === 4) {
                    console.log('[Cesium JS Info] 开始添加角点标签和四边形...');
                    addPointLabels({ points: cornerPointsGeo });
                    
                    // 2. 在Cesium中绘制四边形（连接四个角点）
                    const positions = cornerPointsGeo.map(pt => {
                        // 确保使用弧度
                        const lon = typeof pt.longitude === 'number' ? pt.longitude : Cesium.Math.toRadians(pt.longitude);
                        const lat = typeof pt.latitude === 'number' ? pt.latitude : Cesium.Math.toRadians(pt.latitude);
                        const pos = Cesium.Cartesian3.fromRadians(lon, lat, pt.height);
                        return pos;
                    });
                    // 闭合四边形（添加第一个点到最后）
                    positions.push(positions[0].clone());
                    
                    console.log('[Cesium JS Info] 四边形位置数量:', positions.length);
                    
                    // 添加贴地版本的四边形
                    const quadEntity = cesiumViewer.entities.add({
                        name: 'CornerQuadrilateral',
                        polyline: {
                            positions: positions,
                            width: 5, // 增加线宽使其更明显
                            material: Cesium.Color.CYAN.withAlpha(0.9), // 增加不透明度
                            clampToGround: true, // 使用贴地
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                            arcType: Cesium.ArcType.GEODESIC // 使用测地线
                        }
                    });
                    
                    // 添加不贴地版本的四边形作为备用
                    const quadEntity2 = cesiumViewer.entities.add({
                        name: 'CornerQuadrilateral_NoClamp',
                        polyline: {
                            positions: positions,
                            width: 3,
                            material: Cesium.Color.YELLOW.withAlpha(0.7),
                            clampToGround: false,
                            heightReference: Cesium.HeightReference.NONE
                        }
                    });
                    
                    if (!window.cornerVisualizationEntities) {
                        window.cornerVisualizationEntities = [];
                    }
                    window.cornerVisualizationEntities.push(quadEntity);
                    window.cornerVisualizationEntities.push(quadEntity2);
                    console.log('[Cesium JS Info] 已添加四边形实体（贴地和不贴地版本）');
                    
                    // 3. 在Three.js中绘制视锥体射线（从相机到四个角点）
                    // 优先使用全局threeScene，因为角点坐标是在全局坐标系中
                    if (threeScene) {
                        console.log('[Cesium JS Info] 使用全局threeScene绘制射线');
                        visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, threeScene);
                    } else {
                        // 如果没有全局scene，尝试使用layer的scene
                        let layerScene = null;
                        for (let layer of gaussianSplatLayers) {
                            if (layer.splatViewer && layer.ready && layer.scene) {
                                layerScene = layer.scene;
                                break;
                            }
                        }
                        if (layerScene) {
                            console.log('[Cesium JS Info] 使用layer scene绘制射线');
                            visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, layerScene);
                        } else {
                            console.warn('[Cesium JS Warning] 无法找到可用的Three.js scene');
                        }
                    }
                    
                    console.log('[Cesium JS Info] 已可视化四个角点、四边形和视锥体射线');
                } else {
                    console.warn('[Cesium JS Warning] 有效的角点数量不足，无法绘制四边形');
                }
                
            } catch (error) {
                console.error('[Cesium JS Error] 可视化角点和射线失败:', error);
            }
        }
        
        // 在Three.js中绘制视锥体射线
        function visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, scene) {
            try {
                if (!scene || !threeCamera) {
                    console.warn('[Cesium JS Warning] Three.js场景或相机未初始化，无法绘制射线');
                    return;
                }
                
                console.log('[Cesium JS Info] 开始绘制视锥体射线，scene类型:', scene.constructor.name);
                
                // 清除之前的射线
                if (window.rayLines) {
                    window.rayLines.forEach(line => {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                }
                window.rayLines = [];
                
                // 获取相机位置（世界坐标）
                const cameraPosition = new THREE.Vector3();
                threeCamera.getWorldPosition(cameraPosition);
                console.log('[Cesium JS Info] 相机位置:', cameraPosition.x.toFixed(2), cameraPosition.y.toFixed(2), cameraPosition.z.toFixed(2));
                
                // 为每个角点创建射线（绿色，表示视锥体）
                cornerPoints3DThree.forEach((cornerPoint, idx) => {
                    console.log(`[Cesium JS Info] 绘制射线${idx + 1}: 从相机(${cameraPosition.x.toFixed(2)}, ${cameraPosition.y.toFixed(2)}, ${cameraPosition.z.toFixed(2)}) 到角点(${cornerPoint.x.toFixed(2)}, ${cornerPoint.y.toFixed(2)}, ${cornerPoint.z.toFixed(2)})`);
                    
                    // 创建从相机到角点的线段
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        cameraPosition,
                        cornerPoint
                    ]);
                    
                    // 使用绿色材质（视锥体射线）
                    const material = new THREE.LineBasicMaterial({
                        color: 0x00ff00, // 绿色
                        linewidth: 3, // 增加线宽
                        transparent: true,
                        opacity: 0.9 // 增加不透明度
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    window.rayLines.push(line);
                    console.log(`[Cesium JS Info] 已添加射线${idx + 1}到scene，scene子对象数量:`, scene.children.length);
                });
                
                // 绘制视锥体的边界线（连接四个角点形成四边形，在Three.js中）
                if (cornerPoints3DThree.length === 4) {
                    // 创建四边形边框（在Three.js中，使用青色）
                    const quadGeometry = new THREE.BufferGeometry().setFromPoints([
                        cornerPoints3DThree[0],
                        cornerPoints3DThree[1],
                        cornerPoints3DThree[2],
                        cornerPoints3DThree[3],
                        cornerPoints3DThree[0] // 闭合
                    ]);
                    
                    const quadMaterial = new THREE.LineBasicMaterial({
                        color: 0x00ffff, // 青色
                        linewidth: 3,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const quadLine = new THREE.Line(quadGeometry, quadMaterial);
                    scene.add(quadLine);
                    window.rayLines.push(quadLine);
                }
                
                console.log('[Cesium JS Info] 已在Three.js中绘制视锥体射线');
                
            } catch (error) {
                console.error('[Cesium JS Error] 在Three.js中绘制射线失败:', error);
            }
        }
        
        // 清除角点可视化
        function clearCornerPointsVisualization() {
            try {
                // 清除Cesium实体
                if (window.cornerVisualizationEntities) {
                    window.cornerVisualizationEntities.forEach(entity => {
                        cesiumViewer.entities.remove(entity);
                    });
                    window.cornerVisualizationEntities = [];
                }
                
                // 清除Three.js射线
                if (window.rayLines) {
                    window.rayLines.forEach(line => {
                        // 尝试从所有可能的scene中移除
                        if (threeScene) threeScene.remove(line);
                        // 也尝试从layer scenes中移除
                        for (let layer of gaussianSplatLayers) {
                            if (layer.scene) {
                                try {
                                    layer.scene.remove(line);
                                } catch (e) {
                                    // 忽略错误
                                }
                            }
                        }
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                    window.rayLines = [];
                }
                
                // 清除点标签（如果存在）
                if (window.cornerPointLabels) {
                    window.cornerPointLabels.forEach(label => {
                        cesiumViewer.entities.remove(label);
                    });
                    window.cornerPointLabels = [];
                }
                
            } catch (error) {
                console.error('[Cesium JS Error] 清除可视化失败:', error);
            }
        }
        
        // 计算角点3D坐标（使用射线检测，将四个角点约束到XZ平面上实现贴地效果）
        function calculateCornerPoints3D(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const pixelPoints = data.pixelPoints || [];
                
                // 获取第一个加载的splat viewer和mesh
                let splatViewer = null;
                let splatMesh = null;
                let threeCamera = null;
                let threeScene = null;
                
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        splatViewer = layer.splatViewer;
                        splatMesh = splatViewer.getSplatMesh();
                        threeCamera = splatViewer.camera;
                        threeScene = layer.scene;
                        if (splatMesh && threeCamera && threeScene) break;
                    }
                }
                
                if (!threeCamera) {
                    console.warn('[Cesium JS Warning] 未找到可用的THREE.js相机，使用备用方法');
                    calculateCornerPoints3DWithPlane(data);
                    return;
                }
                
                // 计算地面高度（XZ平面的Y坐标）
                // 方法1：尝试从场景边界获取最小Y值
                let groundY = 0.0;
                if (modelBoundingSphere && modelBoundingSphere.center && modelBoundingSphere.radius) {
                    // 使用边界球中心Y坐标减去半径作为地面高度
                    groundY = modelBoundingSphere.center[1] - modelBoundingSphere.radius;
                    console.log('[Cesium JS Info] 从边界球计算地面高度:', groundY);
                } else if (splatMesh) {
                    // 方法2：从mesh的包围盒获取最小Y值
                    try {
                        if (splatMesh.geometry && !splatMesh.geometry.boundingBox) {
                            splatMesh.geometry.computeBoundingBox();
                        }
                        if (splatMesh.geometry && splatMesh.geometry.boundingBox) {
                            const box = splatMesh.geometry.boundingBox;
                            const minWorld = new THREE.Vector3(box.min.x, box.min.y, box.min.z);
                            const maxWorld = new THREE.Vector3(box.max.x, box.max.y, box.max.z);
                            splatMesh.localToWorld(minWorld);
                            splatMesh.localToWorld(maxWorld);
                            groundY = Math.min(minWorld.y, maxWorld.y);
                            console.log('[Cesium JS Info] 从mesh包围盒计算地面高度:', groundY);
                        }
                    } catch (e) {
                        console.warn('[Cesium JS Warning] 无法从mesh获取地面高度，使用默认值0:', e);
                    }
                }
                
                // 如果groundY仍然是0，尝试使用第一个角点的临时计算来估算
                // 但这只是备用方案，主要应该使用上面的方法
                if (groundY === 0.0 && pixelPoints.length > 0) {
                    console.warn('[Cesium JS Warning] 地面高度为0，将使用默认值。建议检查场景边界计算。');
                }
                
                console.log('[Cesium JS Info] 最终使用地面高度（Y坐标）:', groundY);
                
                // 创建XZ平面（法向量为Y轴正方向，通过groundY点）
                const planeNormal = new THREE.Vector3(0, 1, 0); // Y轴正方向
                const planePoint = new THREE.Vector3(0, groundY, 0);
                const xzPlane = new THREE.Plane(planeNormal, -groundY); // plane.d = -n·point
                
                // 创建Three.js的Raycaster用于获取射线
                const threeRaycaster = new THREE.Raycaster();
                const cornerPoints3D = [];
                const cornerPoints3DThree = []; // 存储Three.js坐标，用于后续转换
                
                // 对每个角点进行射线检测
                for (let pixelPoint of pixelPoints) {
                    try {
                        // 检查pixelPoint是否有效
                        if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                            console.warn('[Cesium JS Warning] 无效的角点数据，跳过:', pixelPoint);
                            cornerPoints3D.push({
                                longitude: 0.0,
                                latitude: 0.0,
                                height: 0.0
                            });
                            continue;
                        }
                        
                        // 1. 将屏幕坐标转换为归一化设备坐标（NDC）
                        // Three.js的Raycaster需要NDC坐标，范围是[-1, 1]
                        const ndcX = (pixelPoint.x / imageWidth) * 2 - 1;
                        const ndcY = 1 - (pixelPoint.y / imageHeight) * 2; // Y轴翻转
                        
                        // 2. 使用Three.js的Raycaster设置射线
                        threeRaycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);
                        
                        // 3. 获取射线的起点和方向
                        const ray = threeRaycaster.ray;
                        
                        // 4. 计算射线与XZ平面的交点
                        const intersectionPoint = new THREE.Vector3();
                        const result = ray.intersectPlane(xzPlane, intersectionPoint);
                        
                        if (result) {
                            // 成功计算到交点，存储在Three.js坐标系中
                            cornerPoints3DThree.push(intersectionPoint.clone());
                            
                            // 5. 将Three.js世界坐标转换为Cesium坐标（可选，主要用于兼容）
                            // 注意：Three.js坐标是主要结果，Cesium坐标只是备用
                            
                            // 尝试将Three.js坐标转换为Cesium ECEF坐标
                            // Three.js坐标可能已经是ECEF坐标，或者需要转换
                            try {
                                // 将Three.js坐标视为ECEF坐标（如果场景使用ECEF坐标系）
                                const ecefPoint = new Cesium.Cartesian3(
                                    intersectionPoint.x,
                                    intersectionPoint.y,
                                    intersectionPoint.z
                                );
                                
                                // 转换为地理坐标
                                const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                                
                                // 检查坐标是否有效（经纬度在合理范围内）
                                if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude) &&
                                    cartographic.longitude >= -Math.PI && cartographic.longitude <= Math.PI &&
                                    cartographic.latitude >= -Math.PI/2 && cartographic.latitude <= Math.PI/2) {
                                    cornerPoints3D.push({
                                        longitude: cartographic.longitude,
                                        latitude: cartographic.latitude,
                                        height: cartographic.height
                                    });
                                } else {
                                    // 如果直接转换失败，尝试使用Cesium相机射线
                                    const cesiumRay = cesiumViewer.camera.getPickRay(
                                        new Cesium.Cartesian2(pixelPoint.x, pixelPoint.y)
                                    );
                                    
                                    if (cesiumRay) {
                                        const cesiumIntersection = cesiumViewer.scene.globe.pick(cesiumRay, cesiumViewer.scene);
                                        if (cesiumIntersection) {
                                            const cartographic2 = Cesium.Cartographic.fromCartesian(cesiumIntersection);
                                            cornerPoints3D.push({
                                                longitude: cartographic2.longitude,
                                                latitude: cartographic2.latitude,
                                                height: cartographic2.height
                                            });
                                        } else {
                                            // 使用椭球面求交
                                            const ellipsoid = cesiumViewer.scene.globe.ellipsoid;
                                            const intersectionResult = Cesium.IntersectionTests.rayEllipsoid(cesiumRay, ellipsoid);
                                            if (intersectionResult) {
                                                const intersectionPoint2 = intersectionResult.start;
                                                const cartographic3 = Cesium.Cartographic.fromCartesian(intersectionPoint2);
                                                cornerPoints3D.push({
                                                    longitude: cartographic3.longitude,
                                                    latitude: cartographic3.latitude,
                                                    height: 0.0
                                                });
                                            } else {
                                                // Cesium坐标计算失败，但不影响Three.js坐标的使用
                                                // Three.js坐标是主要结果，Cesium坐标只是备用
                                                cornerPoints3D.push({
                                                    longitude: 0.0,
                                                    latitude: 0.0,
                                                    height: 0.0
                                                });
                                            }
                                        }
                                    } else {
                                        cornerPoints3D.push({
                                            longitude: 0.0,
                                            latitude: 0.0,
                                            height: 0.0
                                        });
                                    }
                                }
                            } catch (e) {
                                // Three.js到Cesium坐标转换失败，使用默认值
                                // 这不影响Three.js坐标的使用（Three.js坐标是主要结果）
                                cornerPoints3D.push({
                                    longitude: 0.0,
                                    latitude: 0.0,
                                    height: 0.0
                                });
                            }
                        } else {
                            // 射线与平面平行或不相交
                            console.warn('[Cesium JS Warning] 射线与XZ平面不相交，使用默认值');
                            cornerPoints3D.push({
                                longitude: 0.0,
                                latitude: 0.0,
                                height: 0.0
                            });
                        }
                    } catch (error) {
                        console.error('[Cesium JS Error] 处理角点时出错:', error);
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                    }
                }
                
                // 输出Three.js坐标用于调试
                if (cornerPoints3DThree.length > 0) {
                    console.log('[Cesium JS Info] 计算得到的Three.js坐标（XZ平面）:');
                    cornerPoints3DThree.forEach((pt, idx) => {
                        console.log(`  角点${idx + 1}: (${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.z.toFixed(2)})`);
                    });
                    
                    // 可视化角点和射线
                    visualizeCornerPointsAndRays(cornerPoints3DThree, threeCamera, pixelPoints, imageWidth, imageHeight);
                }
                
                // 发送结果回Python（包含Three.js坐标和Cesium坐标）
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cornerPoints3DCalculated',
                        data: {
                            cornerPoints: cornerPoints3D,
                            cornerPointsThree: cornerPoints3DThree.map(pt => ({
                                x: pt.x,
                                y: pt.y,
                                z: pt.z
                            }))
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] 计算角点3D坐标失败:', error);
                // 出错时使用备用方法
                calculateCornerPoints3DWithPlane(data);
            }
        }
        
        // 计算分割轮廓的3D坐标（将2D轮廓点约束到XZ平面上）
        function calculateContourPoints3D(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const contourPoints = data.contourPoints || []; // 轮廓点数组，每个轮廓是一个点数组
                const contourId = data.contourId || 0; // 轮廓ID，用于区分不同的分割结果
                
                if (!contourPoints || contourPoints.length === 0) {
                    console.warn('[Cesium JS Warning] 没有轮廓点数据');
                    return;
                }
                
                // 获取第一个加载的splat viewer和mesh
                let splatViewer = null;
                let splatMesh = null;
                let threeCamera = null;
                
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        splatViewer = layer.splatViewer;
                        splatMesh = splatViewer.getSplatMesh();
                        threeCamera = splatViewer.camera;
                        if (splatMesh && threeCamera) break;
                    }
                }
                
                if (!threeCamera) {
                    console.warn('[Cesium JS Warning] 未找到可用的THREE.js相机');
                    return;
                }
                
                // 计算地面高度（XZ平面的Y坐标）- 使用和角点相同的方法
                let groundY = 0.0;
                if (modelBoundingSphere && modelBoundingSphere.center && modelBoundingSphere.radius) {
                    groundY = modelBoundingSphere.center[1] - modelBoundingSphere.radius;
                } else if (splatMesh) {
                    try {
                        if (splatMesh.geometry && !splatMesh.geometry.boundingBox) {
                            splatMesh.geometry.computeBoundingBox();
                        }
                        if (splatMesh.geometry && splatMesh.geometry.boundingBox) {
                            const box = splatMesh.geometry.boundingBox;
                            const minWorld = new THREE.Vector3(box.min.x, box.min.y, box.min.z);
                            const maxWorld = new THREE.Vector3(box.max.x, box.max.y, box.max.z);
                            splatMesh.localToWorld(minWorld);
                            splatMesh.localToWorld(maxWorld);
                            groundY = Math.min(minWorld.y, maxWorld.y);
                        }
                    } catch (e) {
                        console.warn('[Cesium JS Warning] 无法从mesh获取地面高度，使用默认值0:', e);
                    }
                }
                
                // 创建XZ平面
                const xzPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -groundY);
                
                // 创建Three.js的Raycaster
                const threeRaycaster = new THREE.Raycaster();
                const allContourPoints3D = []; // 存储所有轮廓的3D点
                
                // 处理每个轮廓
                contourPoints.forEach((contour, contourIdx) => {
                    if (!contour || contour.length < 3) {
                        console.warn(`[Cesium JS Warning] 轮廓${contourIdx}点数不足，跳过`);
                        return;
                    }
                    
                    const contour3D = []; // 当前轮廓的3D点
                    
                    // 对轮廓中的每个点进行射线检测
                    contour.forEach((pixelPoint, pointIdx) => {
                        try {
                            if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                                return;
                            }
                            
                            // 将屏幕坐标转换为归一化设备坐标（NDC）
                            const ndcX = (pixelPoint.x / imageWidth) * 2 - 1;
                            const ndcY = 1 - (pixelPoint.y / imageHeight) * 2; // Y轴翻转
                            
                            // 使用Three.js的Raycaster设置射线
                            threeRaycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);
                            
                            // 获取射线
                            const ray = threeRaycaster.ray;
                            
                            // 计算射线与XZ平面的交点
                            const intersectionPoint = new THREE.Vector3();
                            const result = ray.intersectPlane(xzPlane, intersectionPoint);
                            
                            if (result) {
                                contour3D.push(intersectionPoint.clone());
                            }
                        } catch (error) {
                            console.warn(`[Cesium JS Warning] 处理轮廓${contourIdx}的点${pointIdx}时出错:`, error);
                        }
                    });
                    
                    if (contour3D.length > 0) {
                        allContourPoints3D.push(contour3D);
                    }
                });
                
                console.log(`[Cesium JS Info] 成功转换${allContourPoints3D.length}个轮廓到3D坐标`);
                
                // 可视化轮廓线
                visualizeContours3D(allContourPoints3D, contourId);
                
                // 发送结果回Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'contourPoints3DCalculated',
                        data: {
                            contourId: contourId,
                            contours3D: allContourPoints3D.map(contour => 
                                contour.map(pt => ({ x: pt.x, y: pt.y, z: pt.z }))
                            )
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] 计算轮廓3D坐标失败:', error);
            }
        }
        
        // 可视化分割轮廓线（在3D场景中）
        function visualizeContours3D(contours3D, contourId) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                // 清除之前的轮廓可视化
                clearContourVisualization(contourId);
                
                // 为每个轮廓创建可视化
                contours3D.forEach((contour, idx) => {
                    if (contour.length < 3) {
                        return;
                    }
                    
                    // 将Three.js坐标转换为Cesium地理坐标
                    const positions = [];
                    contour.forEach(pt => {
                        try {
                            const ecefPoint = new Cesium.Cartesian3(pt.x, pt.y, pt.z);
                            const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                            
                            if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude)) {
                                positions.push(Cesium.Cartesian3.fromRadians(
                                    cartographic.longitude,
                                    cartographic.latitude,
                                    cartographic.height
                                ));
                            }
                        } catch (e) {
                            // 忽略转换失败的点
                        }
                    });
                    
                    // 闭合轮廓（添加第一个点到最后）
                    if (positions.length > 0) {
                        positions.push(positions[0].clone());
                        
                        // 在Cesium中绘制轮廓线
                        const contourEntity = cesiumViewer.entities.add({
                            name: `Contour_${contourId}_${idx}`,
                            polyline: {
                                positions: positions,
                                width: 3,
                                material: Cesium.Color.MAGENTA.withAlpha(0.8), // 使用洋红色区分轮廓
                                clampToGround: true,
                                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                                arcType: Cesium.ArcType.GEODESIC
                            }
                        });
                        
                        if (!window.contourVisualizationEntities) {
                            window.contourVisualizationEntities = {};
                        }
                        if (!window.contourVisualizationEntities[contourId]) {
                            window.contourVisualizationEntities[contourId] = [];
                        }
                        window.contourVisualizationEntities[contourId].push(contourEntity);
                    }
                });
                
                // 在Three.js中也绘制轮廓线（用于更精确的显示）
                visualizeContoursInThreeJS(contours3D, contourId);
                
                console.log(`[Cesium JS Info] 已可视化${contours3D.length}个轮廓`);
            } catch (error) {
                console.error('[Cesium JS Error] 可视化轮廓失败:', error);
            }
        }
        
        // 在Three.js中绘制轮廓线
        function visualizeContoursInThreeJS(contours3D, contourId) {
            try {
                // 获取scene
                let scene = threeScene;
                if (!scene) {
                    for (let layer of gaussianSplatLayers) {
                        if (layer.splatViewer && layer.ready && layer.scene) {
                            scene = layer.scene;
                            break;
                        }
                    }
                }
                
                if (!scene) {
                    console.warn('[Cesium JS Warning] 无法找到可用的Three.js scene');
                    return;
                }
                
                // 清除之前的轮廓线
                if (window.contourLines && window.contourLines[contourId]) {
                    window.contourLines[contourId].forEach(line => {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                }
                
                if (!window.contourLines) {
                    window.contourLines = {};
                }
                window.contourLines[contourId] = [];
                
                // 为每个轮廓创建线条
                contours3D.forEach((contour, idx) => {
                    if (contour.length < 3) {
                        return;
                    }
                    
                    // 闭合轮廓
                    const closedContour = [...contour, contour[0]];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(closedContour);
                    const material = new THREE.LineBasicMaterial({
                        color: 0xff00ff, // 洋红色
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    window.contourLines[contourId].push(line);
                });
                
                console.log(`[Cesium JS Info] 已在Three.js中绘制${contours3D.length}个轮廓`);
            } catch (error) {
                console.error('[Cesium JS Error] 在Three.js中绘制轮廓失败:', error);
            }
        }
        
        // 清除轮廓可视化
        function clearContourVisualization(contourId) {
            try {
                // 清除Cesium实体
                if (window.contourVisualizationEntities && window.contourVisualizationEntities[contourId]) {
                    window.contourVisualizationEntities[contourId].forEach(entity => {
                        cesiumViewer.entities.remove(entity);
                    });
                    delete window.contourVisualizationEntities[contourId];
                }
                
                // 清除Three.js线条
                if (window.contourLines && window.contourLines[contourId]) {
                    window.contourLines[contourId].forEach(line => {
                        // 尝试从所有可能的scene中移除
                        if (threeScene) threeScene.remove(line);
                        for (let layer of gaussianSplatLayers) {
                            if (layer.scene) {
                                try {
                                    layer.scene.remove(line);
                                } catch (e) {}
                            }
                        }
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                    delete window.contourLines[contourId];
                }
            } catch (error) {
                console.error('[Cesium JS Error] 清除轮廓可视化失败:', error);
            }
        }
        
        // 使用射线与Cesium地球表面求交的方法（备用方法，也实现贴地效果）
        function calculateCornerPoints3DWithPlane(data) {
            try {
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const pixelPoints = data.pixelPoints || [];
                
                const cornerPoints3D = [];
                
                // 直接使用Cesium相机与地球表面求交（贴地效果）
                for (let pixelPoint of pixelPoints) {
                    // 检查pixelPoint是否有效
                    if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                        console.warn('[Cesium JS Warning] 无效的角点数据，跳过:', pixelPoint);
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                        continue;
                    }
                    
                    const ray = cesiumViewer.camera.getPickRay(new Cesium.Cartesian2(pixelPoint.x, pixelPoint.y));
                    if (ray) {
                        // 与地球椭球面求交（贴地效果）
                        const intersection = cesiumViewer.scene.globe.pick(ray, cesiumViewer.scene);
                        if (intersection) {
                            const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                            cornerPoints3D.push({
                                longitude: cartographic.longitude,
                                latitude: cartographic.latitude,
                                height: cartographic.height
                            });
                        } else {
                            // 如果没有交点，使用椭球面求交（备用方法）
                            const ellipsoid = cesiumViewer.scene.globe.ellipsoid;
                            const intersectionResult = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
                            if (intersectionResult) {
                                // intersectionResult 包含 start 和 stop 两个交点，使用较近的点（start）
                                const intersectionPoint = intersectionResult.start;
                                const cartographic = Cesium.Cartographic.fromCartesian(intersectionPoint);
                                cornerPoints3D.push({
                                    longitude: cartographic.longitude,
                                    latitude: cartographic.latitude,
                                    height: 0.0  // 椭球面高度为0
                                });
                            } else {
                                cornerPoints3D.push({
                                    longitude: 0.0,
                                    latitude: 0.0,
                                    height: 0.0
                                });
                            }
                        }
                    } else {
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                    }
                }
                
                // 发送结果回Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cornerPoints3DCalculated',
                        data: {
                            cornerPoints: cornerPoints3D
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] 计算角点3D坐标（平面方法）失败:', error);
            }
        }
        
        // 获取相机矩阵
        function getCameraMatrices() {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium viewer未初始化');
                    return;
                }
                
                // 获取第一个splat viewer的THREE.js相机
                let threeCamera = null;
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        threeCamera = layer.splatViewer.camera;
                        if (threeCamera) break;
                    }
                }
                
                if (!threeCamera) {
                    console.error('[Cesium JS Error] 未找到THREE.js相机');
                    return;
                }
                
                // 获取视图矩阵和投影矩阵
                const viewMatrix = threeCamera.matrixWorldInverse.clone();
                const projMatrix = threeCamera.projectionMatrix.clone();
                
                // 转换为数组格式
                const viewArray = [];
                const projArray = [];
                
                for (let i = 0; i < 16; i++) {
                    viewArray.push(viewMatrix.elements[i]);
                    projArray.push(projMatrix.elements[i]);
                }
                
                // 发送结果回Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cameraMatricesReceived',
                        data: {
                            viewMatrix: viewArray,
                            projMatrix: projArray
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] 获取相机矩阵失败:', error);
            }
        }

        function flyToModel() {
            if (!cesiumViewer) {
                console.log('[Cesium JS Info] Cesium viewer未初始化');
                return;
            }
            
            // 如果有边界球，使用边界球
            // 增加检查：中心点不能太接近(0,0,0)，那意味着在地心
            const center = modelBoundingSphere ? modelBoundingSphere.center : null;
            const distToCenter = center ? Math.sqrt(center[0]*center[0] + center[1]*center[1] + center[2]*center[2]) : 0;
            const isCenterValid = distToCenter > 1000000; // 至少离地心1000km（地球半径约6371km）

            if (modelBoundingSphere && center && isCenterValid) {
                console.log('[Cesium JS Info] 使用边界球飞到模型:', JSON.stringify(modelBoundingSphere));
                
                // 检查半径是否异常大（例如超过100km），如果是，则限制半径
                let radius = modelBoundingSphere.radius;
                if (radius > 100000) {
                    console.warn('[Cesium JS Warning] 边界球半径过大:', radius, '限制为100m');
                    radius = 100;
                }
                // 如果半径太小（小于1m），也调整一下
                if (radius < 1) {
                    radius = 10;
                }

                const boundingSphere = new Cesium.BoundingSphere(
                    Cesium.Cartesian3.fromElements(center[0], center[1], center[2]),
                    radius
                );
                
                cesiumViewer.camera.flyToBoundingSphere(boundingSphere, {
                    duration: 2,
                    offset: new Cesium.HeadingPitchRange(0, -0.5, radius * 1.5)
                });
            } else if (gaussianSplatLayers.length > 0) {
                console.log('[Cesium JS Info] 边界球无效或未计算，回退到地理位置飞行');
                // 如果没有边界球，使用第一个模型的位置
                const firstLayer = gaussianSplatLayers[0];
                if (firstLayer && firstLayer.geoLocation) {
                    console.log('[Cesium JS Info] 使用模型地理位置飞到模型:', firstLayer.geoLocation);
                    const position = Cesium.Cartesian3.fromDegrees(
                        firstLayer.geoLocation.lon,
                        firstLayer.geoLocation.lat,
                        firstLayer.geoLocation.height + 100  // 在模型上方100米
                    );
                    
                    cesiumViewer.camera.flyTo({
                        destination: position,
                        orientation: {
                            heading: 0,
                            pitch: -Cesium.Math.PI_OVER_FOUR,
                            roll: 0
                        },
                        duration: 2
                    });
                }
            } else {
                console.log('[Cesium JS Info] 没有模型可飞行');
            }
        }
        
        function toggleInfoPanel() {
            const content = document.getElementById('info-content');
            content.classList.toggle('collapsed');
        }
        
        function startInfoUpdate() {
            setInterval(updateInfo, 1000);
        }
        
        function updateInfo() {
            if (!cesiumViewer) return;
            
            // 获取相机位置
            const cameraPosition = cesiumViewer.camera.position;
            const cartographic = Cesium.Cartographic.fromCartesian(cameraPosition);
            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
            const latitude = Cesium.Math.toDegrees(cartographic.latitude);
            const height = cartographic.height;
            
            // 更新UI
            document.getElementById('cameraHeight').textContent = height.toFixed(1);
            document.getElementById('longitude').textContent = longitude.toFixed(6);
            document.getElementById('latitude').textContent = latitude.toFixed(6);
        }
        
        // 加载本地文件
        function loadLocalFile() {
            const fileInput = document.getElementById('localFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                console.warn('[Cesium JS Warning] 未选择文件');
                return;
            }
            
            console.log('[Cesium JS Info] 加载本地文件:', file.name);
            
            // 创建文件URL
            const fileUrl = URL.createObjectURL(file);
            
            // 确定文件格式
            const fileName = file.name.toLowerCase();
            let format = null;
            if (fileName.endsWith('.splat')) {
                format = window.GaussianSplats3D.SceneFormat.Splat;
            } else if (fileName.endsWith('.ply')) {
                format = window.GaussianSplats3D.SceneFormat.Ply;
            } else if (fileName.endsWith('.ksplat')) {
                format = window.GaussianSplats3D.SceneFormat.KSplat;
            }
            
            // 获取当前相机中心位置作为默认加载位置
            let defaultLocation = {
                lon: 116.3974,
                lat: 39.9088,
                height: 0
            };

            if (cesiumViewer) {
                const center = cesiumViewer.camera.positionCartographic;
                defaultLocation = {
                    lon: Cesium.Math.toDegrees(center.longitude),
                    lat: Cesium.Math.toDegrees(center.latitude),
                    height: 0 // 默认贴地
                };
            }
            
            // 加载模型
            const modelData = {
                url: fileUrl,
                location: defaultLocation,
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1.0,
                modelId: `local_${Date.now()}`,
                format: format,
                flyTo: true
            };
            
            load3DGS(modelData);
            
            // 清除文件输入
            fileInput.value = '';
        }
        
        // 更新模型列表UI
        function updateModelListUI() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            // 清空现有选项
            modelList.innerHTML = '';
            
            if (gaussianSplatLayers.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '无模型';
                modelList.appendChild(option);
                return;
            }
            
            // 添加每个模型
            gaussianSplatLayers.forEach(layer => {
                const option = document.createElement('option');
                option.value = layer.modelId;
                option.textContent = `${layer.modelId} ${layer.visible ? '✓' : '✗'}`;
                modelList.appendChild(option);
            });
        }
        
        // 删除选中的模型
        function removeSelectedModel() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                console.warn('[Cesium JS Warning] 未选择模型');
                return;
            }
            
            const modelId = selectedOption.value;
            removeModel({ modelId: modelId });
            updateModelListUI();
        }
        
        // 切换模型可见性
        function toggleModelVisibility() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                console.warn('[Cesium JS Warning] 未选择模型');
                return;
            }
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (layer) {
                layer.visible = !layer.visible;
                if (layer.scene) {
                    layer.scene.visible = layer.visible;
                }
                updateModelListUI();
                console.log('[Cesium JS Info] 模型可见性已切换:', modelId, layer.visible);
            }
        }
        
        // 选中模型时显示属性面板
        function onModelSelected() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                // 隐藏属性面板
                document.getElementById('modelProperties').style.display = 'none';
                return;
            }
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (layer) {
                // 显示属性面板
                document.getElementById('modelProperties').style.display = 'block';
                
                // 更新位置输入框
                document.getElementById('propLon').value = layer.geoLocation.lon.toFixed(6);
                document.getElementById('propLat').value = layer.geoLocation.lat.toFixed(6);
                document.getElementById('propHeight').value = layer.geoLocation.height.toFixed(1);
                
                // 更新旋转滑块
                document.getElementById('propRotX').value = layer.rotation.x;
                document.getElementById('propRotY').value = layer.rotation.y;
                document.getElementById('propRotZ').value = layer.rotation.z;
                document.getElementById('propRotXValue').textContent = layer.rotation.x.toFixed(2);
                document.getElementById('propRotYValue').textContent = layer.rotation.y.toFixed(2);
                document.getElementById('propRotZValue').textContent = layer.rotation.z.toFixed(2);
                
                // 更新缩放滑块
                document.getElementById('propScale').value = layer.scale;
                document.getElementById('propScaleValue').textContent = layer.scale.toFixed(2);
            }
        }
        
        // 更新模型属性
        function updateModelProperty(propertyType) {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer) return;
            
            if (propertyType === 'location') {
                // 更新位置
                const lon = parseFloat(document.getElementById('propLon').value);
                const lat = parseFloat(document.getElementById('propLat').value);
                const height = parseFloat(document.getElementById('propHeight').value);
                
                layer.geoLocation.lon = lon;
                layer.geoLocation.lat = lat;
                layer.geoLocation.height = height;
                
                // 更新场景位置
                const position = Cesium.Cartesian3.fromDegrees(lon, lat, height);
                if (layer.scene) {
                    layer.scene.position.set(position.x, position.y, position.z);
                }
                
                console.log('[Cesium JS Info] 模型位置已更新:', modelId, {lon, lat, height});
            } else if (propertyType === 'rotation') {
                // 更新旋转
                const rotX = parseFloat(document.getElementById('propRotX').value);
                const rotY = parseFloat(document.getElementById('propRotY').value);
                const rotZ = parseFloat(document.getElementById('propRotZ').value);
                
                layer.rotation.x = rotX;
                layer.rotation.y = rotY;
                layer.rotation.z = rotZ;
                
                // 更新场景旋转
                if (layer.scene) {
                    layer.scene.rotation.set(rotX, rotY, rotZ);
                }
                
                // 更新显示值
                document.getElementById('propRotXValue').textContent = rotX.toFixed(2);
                document.getElementById('propRotYValue').textContent = rotY.toFixed(2);
                document.getElementById('propRotZValue').textContent = rotZ.toFixed(2);
                
                console.log('[Cesium JS Info] 模型旋转已更新:', modelId, {rotX, rotY, rotZ});
            } else if (propertyType === 'scale') {
                // 更新缩放
                const scale = parseFloat(document.getElementById('propScale').value);
                
                layer.scale = scale;
                
                // 更新mesh缩放
                const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                if (mesh) {
                    mesh.scale.set(scale, scale, scale);
                }
                
                // 更新显示值
                document.getElementById('propScaleValue').textContent = scale.toFixed(2);
                
                console.log('[Cesium JS Info] 模型缩放已更新:', modelId, scale);
            }
            
            // 重新计算边界球
            layer._needsBoundsUpdate = true;
            calculateBoundingSphere();
        }
        
        // 重置模型变换
        function resetModelTransform() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer) return;
            
            // 重置旋转
            layer.rotation.x = 0;
            layer.rotation.y = 0;
            layer.rotation.z = 0;
            if (layer.scene) {
                layer.scene.rotation.set(0, 0, 0);
            }
            
            // 重置缩放
            layer.scale = 1.0;
            const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
            if (mesh) {
                mesh.scale.set(1, 1, 1);
            }
            
            // 更新UI
            document.getElementById('propRotX').value = 0;
            document.getElementById('propRotY').value = 0;
            document.getElementById('propRotZ').value = 0;
            document.getElementById('propRotXValue').textContent = '0.00';
            document.getElementById('propRotYValue').textContent = '0.00';
            document.getElementById('propRotZValue').textContent = '0.00';
            document.getElementById('propScale').value = 1;
            document.getElementById('propScaleValue').textContent = '1.00';
            
            console.log('[Cesium JS Info] 模型变换已重置:', modelId);
            
            // 重新计算边界球
            layer._needsBoundsUpdate = true;
            calculateBoundingSphere();
        }
        
        // 飞到选中的模型
        function flyToSelectedModel() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer || !layer.geoLocation) return;
            
            console.log('[Cesium JS Info] 飞到选中模型:', modelId);
            
            // 尝试基于模型包围球飞行
            let boundingSphere = null;
            
            if (layer.splatViewer) {
                 const mesh = layer.splatViewer.getSplatMesh();
                 if (mesh) {
                     mesh.updateMatrixWorld(true);
                     if (mesh.geometry && !mesh.geometry.boundingBox) {
                         mesh.geometry.computeBoundingBox();
                     }
                     
                     let box = null;
                     if (mesh.geometry && mesh.geometry.boundingBox) {
                         box = mesh.geometry.boundingBox;
                     } else if (mesh.boundingBox) {
                         box = mesh.boundingBox;
                     }
                     
                     if (box) {
                         // 计算包围盒的世界坐标中心和半径
                         const corners = [
                             new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                             new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                         ];
                         
                         let minX = Infinity, minY = Infinity, minZ = Infinity;
                         let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                         
                         corners.forEach(c => {
                             // 这里只取极值点简化计算，准确计算需要8个角
                             const corner = c.clone();
                             mesh.localToWorld(corner);
                             minX = Math.min(minX, corner.x); minY = Math.min(minY, corner.y); minZ = Math.min(minZ, corner.z);
                             maxX = Math.max(maxX, corner.x); maxY = Math.max(maxY, corner.y); maxZ = Math.max(maxZ, corner.z);
                         });
                         
                         const centerX = (minX + maxX) / 2;
                         const centerY = (minY + maxY) / 2;
                         const centerZ = (minZ + maxZ) / 2;
                         
                         // 使用对角线长度的一半作为半径近似
                         const radius = new THREE.Vector3(minX, minY, minZ).distanceTo(new THREE.Vector3(maxX, maxY, maxZ)) / 2;
                         
                         // 检查中心点是否有效（防止飞到地心）
                         if (Math.abs(centerX) > 1000 && Math.abs(centerY) > 1000) {
                             boundingSphere = new Cesium.BoundingSphere(
                                 new Cesium.Cartesian3(centerX, centerY, centerZ),
                                 radius
                             );
                         }
                     }
                 }
            }
            
            if (boundingSphere) {
                console.log('[Cesium JS Info] 使用模型包围球飞行:', boundingSphere.radius);
                // 限制半径，防止过大或过小
                let r = boundingSphere.radius;
                if (r > 100000) r = 100;
                if (r < 1) r = 10;
                
                cesiumViewer.camera.flyToBoundingSphere(boundingSphere, {
                    duration: 1.5,
                    offset: new Cesium.HeadingPitchRange(0, -0.5, r * 1.5) // -0.5 rad 约等于 -28度，视角比较自然
                });
            } else {
                // 回退逻辑
                let offsetHeight = 50 * (layer.scale || 1.0); // 降低默认高度
                const position = Cesium.Cartesian3.fromDegrees(
                    layer.geoLocation.lon,
                    layer.geoLocation.lat,
                    layer.geoLocation.height + offsetHeight
                );
                
                cesiumViewer.camera.flyTo({
                    destination: position,
                    orientation: {
                        heading: 0,
                        pitch: -Cesium.Math.PI_OVER_FOUR,
                        roll: 0
                    },
                    duration: 1.5
                });
            }
        }
        
        // 修改loadModel函数以支持format参数
        function loadModelWithFormat(data) {
            return loadModel(data);
        }
        
        // 页面加载完成后初始化
        window.onload = function() {
            console.log('[Cesium JS Info] 页面加载完成，开始初始化...');
            
            // 检查库是否已加载和DOM是否准备好
            let checkCount = 0;
            const MAX_CHECK_COUNT = 100; // 最多检查10秒
            
            function checkLibraries() {
                checkCount++;
                
                // 检查DOM元素
                const cesiumContainer = document.getElementById('cesiumContainer');
                if (!cesiumContainer) {
                    console.log('[Cesium JS Info] 等待DOM元素...');
                    if (checkCount < MAX_CHECK_COUNT) {
                        setTimeout(checkLibraries, 100);
                    } else {
                        console.error('[Cesium JS Error] 超时：无法找到cesiumContainer元素');
                    }
                    return;
                }
                
                // 详细检查库加载状态
                const cesiumLoaded = typeof Cesium !== 'undefined';
                const threeLoaded = typeof THREE !== 'undefined';
                
                if (!cesiumLoaded || !threeLoaded) {
                    // 只在第一次或每10次检查时输出详细信息
                    if (checkCount === 1 || checkCount % 10 === 0) {
                        const status = {
                            Cesium: cesiumLoaded ? '已加载' : '未加载',
                            THREE: threeLoaded ? '已加载' : '未加载',
                            检查次数: checkCount
                        };
                        console.log('[Cesium JS Info] 等待库加载... Cesium:', status.Cesium, 'THREE:', status.THREE, '检查次数:', status.检查次数);
                    }
                    
                    if (checkCount < MAX_CHECK_COUNT) {
                        setTimeout(checkLibraries, 100);
                    } else {
                        console.error('[Cesium JS Error] 超时：库加载失败 - Cesium:', cesiumLoaded ? '已加载' : '未加载', 
                                    'THREE:', threeLoaded ? '已加载' : '未加载', 
                                    '建议: 请检查网络连接或文件路径');
                    }
                    return;
                }
                
                // 库已加载，直接初始化（不等待容器尺寸）
                // 在Qt WebEngine中，未激活的标签页容器尺寸可能为0，但Cesium可以初始化
                // 当标签页被激活时，容器会有尺寸，Cesium会自动调整
                console.log('[Cesium JS Info] 所有库已加载，开始初始化Cesium Viewer...', 
                           '容器尺寸:', cesiumContainer.offsetWidth, 'x', cesiumContainer.offsetHeight);
                window.initCesiumViewer();
            }
            
            // 启动初始化过程
            setTimeout(checkLibraries, 100);
        };
        
        // 如果DOM已经准备好（在GUI中可能已经加载）
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(function() {
                if (!isInitialized && !isInitializing) {
                    console.log('[Cesium JS Info] DOM已准备好，开始初始化...');
                    window.onload();
                }
            }, 100);
        }
        // 关闭模型属性面板
        function closeModelProperties() {
            document.getElementById('modelProperties').style.display = 'none';
            // 可选：取消选择列表中的选中状态
            const modelList = document.getElementById('modelList');
            if (modelList) modelList.value = "";
        }

    </script>
</body>
</html>
