<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GSSE Cesium 3DGSæŸ¥çœ‹å™¨</title>
    
    <!-- Cesium CSS - ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ -->
    <link href="./lib/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <!-- Three.js - ä½¿ç”¨unpkg CDNï¼ˆå¤‡ç”¨ï¼šæœ¬åœ°æ–‡ä»¶ï¼‰ -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js" 
            onerror="console.error('[Cesium JS Error] THREE.js CDNåŠ è½½å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æœ¬åœ°æ–‡ä»¶'); loadLocalThree();"></script>
    
    <!-- Cesium JS - ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ -->
    <script src="./lib/Cesium/Cesium.js"
            onerror="console.error('[Cesium JS Error] Cesium.jsæœ¬åœ°æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„')"></script>
    
    <!-- å¤‡ç”¨ï¼šæœ¬åœ°Three.jsåŠ è½½å‡½æ•° -->
    <script>
        function loadLocalThree() {
            // å¦‚æœCDNåŠ è½½å¤±è´¥ï¼Œå°è¯•åŠ è½½æœ¬åœ°æ–‡ä»¶
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                // å°è¯•ä½¿ç”¨æœ¬åœ°çš„three.min.js (åŒ¹é…wgetå‘½ä»¤ä¸‹è½½çš„è·¯å¾„)
                script.src = './lib/threejs/three.min.js';
                script.onerror = function() {
                    console.error('[Cesium JS Error] æœ¬åœ°THREE.jsæ–‡ä»¶ä¹Ÿæ— æ³•åŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ–‡ä»¶è·¯å¾„: ./lib/threejs/three.min.js');
                };
                script.onload = function() {
                    console.log('[Cesium JS Info] å·²ä»æœ¬åœ°æ–‡ä»¶åŠ è½½THREE.js');
                };
                document.head.appendChild(script);
            }
        }
    </script>
    
    <!-- Gaussian Splats 3D - ä½¿ç”¨libç›®å½•ä¸­çš„UMDåº“æ–‡ä»¶ -->
    <!-- æ³¨æ„ï¼šå¿…é¡»åœ¨THREE.jsåŠ è½½ä¹‹ååŠ è½½ï¼Œå› ä¸ºUMDæ–‡ä»¶ä¾èµ–THREE -->
    <script>
        // ç­‰å¾…THREE.jsåŠ è½½å®Œæˆåå†åŠ è½½GaussianSplats3D
        function loadGaussianSplats3D() {
            if (typeof THREE === 'undefined') {
                console.log('[Cesium JS Info] ç­‰å¾…THREE.jsåŠ è½½...');
                setTimeout(loadGaussianSplats3D, 100);
                return;
            }
            
            // THREE.jså·²åŠ è½½ï¼Œç°åœ¨åŠ è½½GaussianSplats3D
            const script = document.createElement('script');
            script.src = './lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs';
            script.onload = function() {
                // UMDæ–‡ä»¶å°†åº“å¯¼å‡ºä¸ºå…¨å±€å˜é‡ "Gaussian Splats 3D"ï¼ˆå¸¦ç©ºæ ¼ï¼‰
                const GaussianSplats3D = window["Gaussian Splats 3D"] || window.GaussianSplats3D;
                
                if (GaussianSplats3D && typeof GaussianSplats3D.Viewer !== 'undefined') {
                    // å°†å…¶è®¾ç½®ä¸ºå…¨å±€å˜é‡ï¼Œä»¥ä¾¿å…¶ä»–è„šæœ¬å¯ä»¥ä½¿ç”¨ï¼ˆä½¿ç”¨æ— ç©ºæ ¼ç‰ˆæœ¬ï¼‰
                    window.GaussianSplats3D = GaussianSplats3D;
                    console.log('[Cesium JS Info] GaussianSplats3Dåº“å·²åŠ è½½');
                    console.log('[Cesium JS Info] å¯ç”¨çš„GaussianSplats3Då±æ€§:', Object.keys(GaussianSplats3D));
                    console.log('[Cesium JS Info] GaussianSplats3D.Viewerç±»å·²æ­£ç¡®åŠ è½½');
                    
                    // æ£€æŸ¥Raycasteræ˜¯å¦å¯ç”¨
                    if (typeof GaussianSplats3D.Raycaster !== 'undefined') {
                        console.log('[Cesium JS Info] GaussianSplats3D.Raycasterç±»å·²æ­£ç¡®åŠ è½½');
                    } else {
                        console.warn('[Cesium JS Warning] GaussianSplats3D.Raycasterç±»ä¸å¯ç”¨ï¼Œå¯èƒ½éœ€è¦æ›´æ–°åº“æ–‡ä»¶');
                    }
                } else {
                    console.error('[Cesium JS Error] GaussianSplats3Dåº“æœªåŠ è½½æˆ–Viewerç±»æœªå®šä¹‰');
                    console.log('[Cesium JS Info] æ£€æŸ¥å…¨å±€å¯¹è±¡:', {
                        'Gaussian Splats 3D': typeof window["Gaussian Splats 3D"],
                        'GaussianSplats3D': typeof window.GaussianSplats3D,
                        'THREE': typeof window.THREE,
                        'window keys': Object.keys(window).filter(k => k.includes('Gaussian') || k.includes('Splat'))
                    });
                }
            };
            script.onerror = function() {
                console.error('[Cesium JS Error] åŠ è½½GaussianSplats3Dåº“æ–‡ä»¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„: ./lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs');
            };
            document.head.appendChild(script);
        }
        
        // å¼€å§‹åŠ è½½
        loadGaussianSplats3D();
    </script>
    
    <style>
        :root {
            --bg-primary: #121218;
            --bg-secondary: #1e1e2e;
            --bg-tertiary: #2a2a3e;
            --bg-hover: #3d3d5c;
            --accent-color: #8b5cf6;
            --accent-hover: #a78bfa;
            --accent-light: rgba(139, 92, 246, 0.15);
            --text-primary: #e8e8f0;
            --text-secondary: #9898b0;
            --border-color: #3d3d5c;
            --success-color: #22c55e;
            --warning-color: #eab308;
            --danger-color: #ef4444;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-primary);
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        #cesiumContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #threeContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        #threeContainer canvas {
            pointer-events: none;
        }
        
        /* å·¦ä¾§å·¥å…·æ é¢æ¿ */
        #toolbar {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 300px;
            z-index: 1000;
            background: var(--bg-secondary);
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            overflow: hidden;
            max-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            padding: 0;
        }
        
        /* é¢æ¿æ ‡é¢˜ */
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }
        
        .panel-header:hover {
            background: var(--bg-hover);
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 15px;
        }
        
        .panel-title-icon {
            width: 22px;
            height: 22px;
            background: var(--accent-color);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .toolbar-section {
            margin-bottom: 14px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .toolbar-section:last-child {
            margin-bottom: 0;
        }
        
        .toolbar-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 13px;
            color: var(--accent-color);
        }
        
        .toolbar-section input, .toolbar-section select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            box-sizing: border-box;
            transition: all 0.15s;
        }
        
        .toolbar-section input:focus, .toolbar-section select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-light);
        }
        
        .toolbar-section input:hover, .toolbar-section select:hover {
            border-color: var(--accent-color);
        }
        
        .toolbar-section button {
            width: 100%;
            padding: 10px 14px;
            margin-top: 8px;
            border: none;
            border-radius: 8px;
            background: var(--accent-color);
            color: white;
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            transition: all 0.15s;
        }
        
        .toolbar-section button:hover {
            background: var(--accent-hover);
        }
        
        .toolbar-section button:active {
            transform: scale(0.98);
        }
        
        /* åº•éƒ¨ä¿¡æ¯é¢æ¿ */
        #info-panel {
            position: absolute;
            bottom: 14px;
            left: 12px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 14px 16px;
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 13px;
            min-width: 220px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }
        
        .info-item {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .info-item span:first-child {
            color: var(--text-secondary);
        }
        
        .info-item span:last-child {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
            padding: 8px 0;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .collapsible:hover {
            color: var(--accent-color);
        }
        
        .content {
            display: block;
        }
        
        .content.collapsed {
            display: none;
        }
        
        /* æ¨¡å‹å±æ€§é¢æ¿ */
        #modelProperties {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 0;
            border-radius: 10px;
            color: var(--text-primary);
            width: 300px;
            display: none;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .props-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .props-header h3 {
            margin: 0;
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .props-close-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }
        
        .props-close-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        #modelPropsContent {
            padding: 12px;
        }
        
        /* è¾“å…¥ç»„æ ·å¼ */
        .input-group {
            margin-bottom: 8px;
        }
        
        .input-group label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        /* æ»‘å—æ ·å¼ */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .slider-row label {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 30px;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            accent-color: var(--accent-color);
            padding: 0;
            border: none;
        }
        
        .slider-row span {
            font-size: 12px;
            color: var(--accent-color);
            min-width: 40px;
            text-align: right;
        }
        
        /* è½´æ ‡ç­¾é¢œè‰² */
        .axis-x { color: #f87171; }
        .axis-y { color: #4ade80; }
        .axis-z { color: #60a5fa; }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="threeContainer"></div>
    
    <div id="toolbar">
        <div class="panel-header">
            <div class="panel-title">
                <div class="panel-title-icon">ğŸŒ</div>
                <span>GISè§†å›¾</span>
            </div>
        </div>
        <div class="panel-content">
            <div class="toolbar-section">
                <label>ğŸ—ºï¸ åœ°å½¢è®¾ç½®</label>
                <select id="terrainSelect">
                    <option value="none">æ— åœ°å½¢</option>
                    <option value="world" selected>å…¨çƒåœ°å½¢</option>
                </select>
            </div>
            
            <div class="toolbar-section">
                <label>ğŸ–¼ï¸ å½±åƒå›¾å±‚</label>
                <select id="imagerySelect">
                    <option value="bing" selected>Bing Maps</option>
                    <option value="osm">OpenStreetMap</option>
                    <option value="arcgis">ArcGIS World Imagery</option>
                </select>
            </div>
            
            <div class="toolbar-section">
                <label>ğŸ“¦ æ¨¡å‹ç®¡ç†</label>
                <select id="modelList" size="3" onchange="onModelSelected()">
                    <option value="">æ— æ¨¡å‹</option>
                </select>
                <button onclick="removeSelectedModel()">åˆ é™¤é€‰ä¸­æ¨¡å‹</button>
                <button onclick="toggleModelVisibility()">æ˜¾ç¤º/éšè—</button>
            </div>
        </div>
    </div>
    
    <!-- æ¨¡å‹å±æ€§æ§åˆ¶é¢æ¿ -->
    <div id="modelProperties">
        <div class="props-header">
            <h3><span class="panel-title-icon">âš™ï¸</span>æ¨¡å‹å±æ€§</h3>
            <button class="props-close-btn" onclick="closeModelProperties()">âœ•</button>
        </div>
        <div id="modelPropsContent">
            <div class="toolbar-section">
                <label>ğŸ“ ä½ç½®</label>
                <div class="input-group">
                    <label>ç»åº¦:</label>
                    <input type="number" id="propLon" step="0.000001" onchange="updateModelProperty('location')" />
                </div>
                <div class="input-group">
                    <label>çº¬åº¦:</label>
                    <input type="number" id="propLat" step="0.000001" onchange="updateModelProperty('location')" />
                </div>
                <div class="input-group">
                    <label>é«˜åº¦ (m):</label>
                    <input type="number" id="propHeight" step="0.1" onchange="updateModelProperty('location')" />
                </div>
            </div>
            
            <div class="toolbar-section">
                <label>ğŸ”„ æ—‹è½¬ (å¼§åº¦)</label>
                <div class="slider-row">
                    <label class="axis-x">Xè½´:</label>
                    <input type="range" id="propRotX" min="-3.14159" max="3.14159" step="0.01" value="0" oninput="updateModelProperty('rotation')" />
                    <span id="propRotXValue">0.00</span>
                </div>
                <div class="slider-row">
                    <label class="axis-y">Yè½´:</label>
                    <input type="range" id="propRotY" min="-3.14159" max="3.14159" step="0.01" value="0" oninput="updateModelProperty('rotation')" />
                    <span id="propRotYValue">0.00</span>
                </div>
                <div class="slider-row">
                    <label class="axis-z">Zè½´:</label>
                    <input type="range" id="propRotZ" min="-3.14159" max="3.14159" step="0.01" value="0" oninput="updateModelProperty('rotation')" />
                    <span id="propRotZValue">0.00</span>
                </div>
            </div>
            
            <div class="toolbar-section">
                <label>ğŸ“ ç¼©æ”¾</label>
                <div class="slider-row">
                    <input type="range" id="propScale" min="0.1" max="5" step="0.05" value="1" oninput="updateModelProperty('scale')" />
                    <span id="propScaleValue">1.00</span>
                </div>
            </div>
            
            <div class="toolbar-section">
                <button onclick="resetModelTransform()">é‡ç½®å˜æ¢</button>
                <button onclick="flyToSelectedModel()">é£åˆ°æ­¤æ¨¡å‹</button>
            </div>
        </div>
    </div>
    
    <div id="info-panel">
        <div class="collapsible" onclick="toggleInfoPanel()">
            <span>ğŸ“Š</span>
            <span>åœºæ™¯ä¿¡æ¯</span>
        </div>
        <div id="info-content" class="content">
            <div class="info-item"><span>ç›¸æœºé«˜åº¦:</span> <span id="cameraHeight">-</span></div>
            <div class="info-item"><span>ç»åº¦:</span> <span id="longitude">-</span></div>
            <div class="info-item"><span>çº¬åº¦:</span> <span id="latitude">-</span></div>
            <div class="info-item"><span>å·²åŠ è½½æ¨¡å‹:</span> <span id="modelCount">0</span></div>
        </div>
    </div>

    <!-- Qt WebChannel - ä»…åœ¨Qtç¯å¢ƒä¸­åŠ è½½ -->
    <script>
        // åŠ¨æ€åŠ è½½Qt WebChannelè„šæœ¬ï¼Œé¿å…åœ¨æµè§ˆå™¨ä¸­æŠ¥é”™
        if (typeof qt !== 'undefined' && qt.webChannelTransport) {
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            script.onerror = function() {
                console.log('[Cesium JS Info] Qt WebChannelä¸å¯ç”¨ï¼ˆæµè§ˆå™¨ç¯å¢ƒï¼‰');
            };
            document.head.appendChild(script);
        }
    </script>
    <script>
        // å…¨å±€å˜é‡
        let cesiumViewer = null;
        let threeScene = null;
        let threeCamera = null;
        let threeRenderer = null;
        let gaussianSplatLayers = [];
        let modelBoundingSphere = null;
        let pyBridge = null;
        
        // æ¶ˆæ¯é˜Ÿåˆ—ï¼Œç”¨äºå­˜å‚¨åˆå§‹åŒ–å‰æ”¶åˆ°çš„æ¶ˆæ¯
        const messageQueue = [];
        let initRetryCount = 0;
        const MAX_INIT_RETRIES = 100; // æœ€å¤šé‡è¯•10ç§’
        
        // é¢„å…ˆå®šä¹‰ receiveMessageFromPython å‡½æ•°ï¼Œé¿å…æœªå®šä¹‰é”™è¯¯
        window.receiveMessageFromPython = function(messageStr) {
            if (!cesiumViewer) {
                // console.log('[Cesium JS Info] æ”¶åˆ°Pythonæ¶ˆæ¯ï¼Œä½†viewerè¿˜æœªåˆå§‹åŒ–ï¼ŒåŠ å…¥é˜Ÿåˆ—'); // æ³¨é‡Šæ‰é¢‘ç¹çš„æ—¥å¿—è¾“å‡º
                messageQueue.push(messageStr);
                // å¦‚æœåˆå§‹åŒ–é‡è¯•æ¬¡æ•°è¿‡å¤šï¼Œå¼ºåˆ¶å°è¯•åˆå§‹åŒ–
                if (initRetryCount < MAX_INIT_RETRIES) {
                    initRetryCount++;
                    setTimeout(function() {
                        if (window.receiveMessageFromPython) {
                            window.receiveMessageFromPython(messageStr);
                        }
                    }, 100);
                } else {
                    console.error('[Cesium JS Error] åˆå§‹åŒ–è¶…æ—¶ï¼Œå¼ºåˆ¶å¤„ç†æ¶ˆæ¯');
                    // å¼ºåˆ¶å¤„ç†æ¶ˆæ¯
                    if (cesiumViewer) {
                        const message = JSON.parse(messageStr);
                        // console.log('æ”¶åˆ°Pythonæ¶ˆæ¯:', message); // æ³¨é‡Šæ‰é¢‘ç¹çš„æ—¥å¿—è¾“å‡º
                    }
                }
                return;
            }
            
            // viewerå·²åˆå§‹åŒ–ï¼Œå¤„ç†æ¶ˆæ¯
            const message = JSON.parse(messageStr);
            // console.log('[Cesium JS Info] æ”¶åˆ°Pythonæ¶ˆæ¯:', message); // æ³¨é‡Šæ‰é¢‘ç¹çš„æ—¥å¿—è¾“å‡º
            
            switch(message.type) {
                case 'load3DGS':
                    load3DGS(message.data);
                    break;
                case 'loadSegment':
                    loadSegment(message.data);
                    break;
                case 'clearAll':
                    clearAllModels();
                    break;
                case 'setCamera':
                    setCameraPosition(message.data);
                    break;
                case 'highlightSegment':
                    highlightSegment(message.data);
                    break;
                case 'removeModel':
                    removeModel(message.data);
                    break;
                case 'getModelInfo':
                    getModelInfo(message.data);
                    break;
                case 'moveCamera':
                    moveCamera(message.data);
                    break;
                case 'zoomCamera':
                    zoomCamera(message.data);
                    break;
                case 'rotateCamera':
                    rotateCamera(message.data);
                    break;
                case 'resetView':
                    resetView();
                    break;
                case 'setTopView':
                    setTopView();
                    break;
                case 'captureScreenshot':
                    captureScreenshot(message.data);
                    break;
                case 'calculateCornerPoints3D':
                    calculateCornerPoints3D(message.data);
                    break;
                case 'calculateContourPoints3D':
                    calculateContourPoints3D(message.data);
                    break;
                case 'getCameraMatrices':
                    getCameraMatrices();
                    break;
                case 'addPointLabels':
                    addPointLabels(message.data);
                    break;
                default:
                    console.log('[Cesium JS Info] æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
            }
        };
        
        // åˆå§‹åŒ–æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤åˆå§‹åŒ–
        let isInitializing = false;
        let isInitialized = false;
        
        // åˆå§‹åŒ–Cesium Viewer - åœ¨Cesiumåº“åŠ è½½å®Œæˆåè°ƒç”¨
        window.initCesiumViewer = function() {
            // é˜²æ­¢é‡å¤åˆå§‹åŒ–
            if (isInitializing || isInitialized) {
                console.log('[Cesium JS Info] åˆå§‹åŒ–å·²åœ¨è¿›è¡Œæˆ–å·²å®Œæˆï¼Œè·³è¿‡');
                return;
            }
            
            // æ£€æŸ¥DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            const cesiumContainer = document.getElementById('cesiumContainer');
            if (!cesiumContainer) {
                console.error('[Cesium JS Error] æ‰¾ä¸åˆ°cesiumContainerå…ƒç´ ');
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            // æ£€æŸ¥Cesiumæ˜¯å¦å·²åŠ è½½
            if (typeof Cesium === 'undefined') {
                console.error('[Cesium JS Error] Cesiumåº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„');
                // å»¶è¿Ÿé‡è¯•
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            // æ£€æŸ¥THREEæ˜¯å¦å·²åŠ è½½
            if (typeof THREE === 'undefined') {
                console.log('[Cesium JS Info] ç­‰å¾…Three.jsåŠ è½½...');
                setTimeout(window.initCesiumViewer, 100);
                return;
            }
            
            isInitializing = true;
            console.log('[Cesium JS Info] Cesiumå’ŒTHREEåº“å·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
            if (typeof THREE !== 'undefined') {
                console.log('[Cesium JS Info] THREE.REVISION:', THREE.REVISION);
            }
            
            try {
            
            // é…ç½®Cesiumä½¿ç”¨æœ¬åœ°èµ„æºè·¯å¾„ï¼ˆé¿å…CORSé—®é¢˜ï¼‰
            // è·å–å½“å‰HTMLæ–‡ä»¶çš„ç›®å½•è·¯å¾„
            const currentPath = window.location.href;
            const isFileProtocol = currentPath.startsWith('file://');
            
            // è®¾ç½®Cesium Ionè®¿é—®ä»¤ç‰Œ
            Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiOTE1YmRiZi1hM2E3LTQ5NGUtYTI4Yy0yYTI1YjRmNmZiMzMiLCJpZCI6MjgyOTIwLCJpYXQiOjE3NDE2MTA2NTB9.bNbSodak59xJkrGIOiPcaAjaRQ3H4iJExEQiHjXDdqo';
            
            // åœ¨file://åè®®ä¸‹ï¼Œé™é»˜å¤„ç†Ion APIçš„CORSé”™è¯¯
            // è¿™æ ·å³ä½¿Ion APIè¯·æ±‚å¤±è´¥ï¼Œä¹Ÿä¸ä¼šå½±å“Cesiumçš„æ­£å¸¸æ˜¾ç¤º
            if (isFileProtocol) {
                // æ‹¦æˆªå¹¶é™é»˜å¤„ç†Ion APIçš„CORSé”™è¯¯
                const originalError = console.error;
                console.error = function(...args) {
                    // å¦‚æœæ˜¯Ion APIçš„CORSé”™è¯¯ï¼Œé™é»˜å¤„ç†
                    const message = args.join(' ');
                    if (message.includes('api.cesium.com') && message.includes('CORS')) {
                        // é™é»˜å¤„ç†ï¼Œä¸è¾“å‡ºé”™è¯¯
                        return;
                    }
                    // å…¶ä»–é”™è¯¯æ­£å¸¸è¾“å‡º
                    originalError.apply(console, args);
                };
                
                // æ•è·æœªå¤„ç†çš„Promiseé”™è¯¯ï¼ˆIon APIè¯·æ±‚å¤±è´¥ï¼‰
                window.addEventListener('unhandledrejection', function(event) {
                    const reason = event.reason;
                    if (reason && typeof reason === 'object') {
                        const reasonStr = JSON.stringify(reason);
                        if (reasonStr.includes('api.cesium.com') || reasonStr.includes('CORS')) {
                            // é™é»˜å¤„ç†Ion APIçš„CORSé”™è¯¯
                            event.preventDefault();
                            return;
                        }
                    }
                });
            }
            
            // é…ç½®Cesiumä½¿ç”¨æœ¬åœ°èµ„æºè·¯å¾„ï¼ˆé¿å…CORSé—®é¢˜ï¼‰
            let basePath = '';
            if (isFileProtocol) {
                // ä»file://è·¯å¾„ä¸­æå–ç›®å½•
                // file:///home/xyh/GSSE/cesium_viewer.html -> file:///home/xyh/GSSE/
                const pathMatch = currentPath.match(/file:\/\/\/.*\//);
                if (pathMatch) {
                    basePath = pathMatch[0];
                } else {
                    // å¦‚æœåŒ¹é…å¤±è´¥ï¼Œå°è¯•å¦ä¸€ç§æ ¼å¼ file:///path/to/file.html
                    const lastSlash = currentPath.lastIndexOf('/');
                    if (lastSlash > 0) {
                        basePath = currentPath.substring(0, lastSlash + 1);
                    }
                }
            } else {
                // å¯¹äºHTTP/HTTPSï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„
                basePath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
            }
            
            // è®¾ç½®Cesiumèµ„æºè·¯å¾„ä¸ºæœ¬åœ°lib/Cesiumç›®å½•
            if (typeof Cesium !== 'undefined' && basePath) {
                const cesiumBasePath = basePath + 'lib/Cesium/';
                // é‡å†™buildModuleUrlä»¥ä½¿ç”¨æœ¬åœ°è·¯å¾„
                const originalBuildModuleUrl = Cesium.buildModuleUrl;
                Cesium.buildModuleUrl = function(module) {
                    // æ£€æŸ¥moduleå‚æ•°æ˜¯å¦æœ‰æ•ˆ
                    if (!module || typeof module !== 'string') {
                        return originalBuildModuleUrl ? originalBuildModuleUrl(module) : module;
                    }
                    // å¦‚æœæ¨¡å—è·¯å¾„æ˜¯ç»å¯¹URLï¼Œç›´æ¥è¿”å›
                    if (module.startsWith('http://') || module.startsWith('https://') || module.startsWith('data:')) {
                        return originalBuildModuleUrl ? originalBuildModuleUrl(module) : module;
                    }
                    // å¦åˆ™ä½¿ç”¨æœ¬åœ°è·¯å¾„
                    const localPath = cesiumBasePath + module;
                    // åªåœ¨è°ƒè¯•æ—¶è¾“å‡ºæ—¥å¿—
                    // console.log('[Cesium JS Info] ä½¿ç”¨æœ¬åœ°èµ„æº:', module, '->', localPath);
                    return localPath;
                };
                console.log('[Cesium JS Info] Cesiumèµ„æºè·¯å¾„è®¾ç½®ä¸º:', cesiumBasePath);
            }
            
            // åˆå§‹åŒ–WebChannel
            // åœ¨Qt WebEngineä¸­ï¼ŒWebChanneléœ€è¦ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
            function initWebChannel() {
                if (typeof QWebChannel !== 'undefined' && typeof qt !== 'undefined' && qt.webChannelTransport) {
                    try {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            if (channel && channel.objects && channel.objects.pyBridge) {
                                pyBridge = channel.objects.pyBridge;
                                window.pyBridge = pyBridge;
                                console.log('[Cesium JS Info] WebChannelå·²è¿æ¥');
                            } else {
                                console.log('[Cesium JS Info] WebChannelå¯¹è±¡æœªæ‰¾åˆ°');
                            }
                        });
                    } catch (e) {
                        console.log('[Cesium JS Info] WebChannelåˆå§‹åŒ–å¤±è´¥:', e);
                    }
                } else {
                    // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥ä½¿ç”¨window.pyBridgeï¼ˆå¦‚æœå·²è®¾ç½®ï¼‰
                    if (window.pyBridge) {
                        pyBridge = window.pyBridge;
                        console.log('[Cesium JS Info] ä½¿ç”¨window.pyBridge');
                    } else {
                        console.log('[Cesium JS Info] WebChannelä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ');
                    }
                }
            }
            
            // å»¶è¿Ÿåˆå§‹åŒ–WebChannelï¼Œç¡®ä¿Qtç¯å¢ƒå·²å‡†å¤‡å¥½
            setTimeout(initWebChannel, 100);
            
            cesiumViewer = new Cesium.Viewer('cesiumContainer', {
                scene3DOnly: true,
                // ä½¿ç”¨ç®€åŒ–çš„åœ°å½¢ä»¥é¿å…ä¾èµ–å¤–éƒ¨æœåŠ¡
                terrainProvider: new Cesium.EllipsoidTerrainProvider(),
                timeline: false,
                animation: false,
                baseLayerPicker: true, 
                geocoder: false,
                homeButton: true,
                sceneModePicker: true,
                navigationHelpButton: false,
                fullscreenButton: true,
                // åœ¨file://åè®®ä¸‹ï¼Œç¦ç”¨ä¸€äº›éœ€è¦è¿œç¨‹æœåŠ¡çš„åŠŸèƒ½
                requestRenderMode: false, // ç¦ç”¨æŒ‰éœ€æ¸²æŸ“ï¼Œç¡®ä¿æ¸²æŸ“å¾ªç¯æŒç»­è¿è¡Œï¼Œä»¥ä¾¿SplatVieweræ›´æ–°
                maximumRenderTimeChange: undefined
            });
            
            // åœ¨file://åè®®ä¸‹ï¼Œé…ç½®é”™è¯¯å¤„ç†ï¼Œä½¿Ion APIé”™è¯¯ä¸å½±å“æ˜¾ç¤º
            if (isFileProtocol) {
                // å»¶è¿Ÿæ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼Œç¡®ä¿globeå·²åˆå§‹åŒ–
                setTimeout(function() {
                    if (cesiumViewer && cesiumViewer.scene && cesiumViewer.scene.globe && cesiumViewer.scene.globe.tileLoadErrorEvent) {
                        // ç›‘å¬Cesiumçš„é”™è¯¯äº‹ä»¶ï¼Œé™é»˜å¤„ç†Ion APIç›¸å…³é”™è¯¯
                        cesiumViewer.scene.globe.tileLoadErrorEvent.addEventListener(function(error) {
                            // é™é»˜å¤„ç†ç“¦ç‰‡åŠ è½½é”™è¯¯ï¼ˆå¯èƒ½æ˜¯CORSå¯¼è‡´çš„ï¼‰
                            console.log('[Cesium JS Info] ç“¦ç‰‡åŠ è½½é”™è¯¯ï¼ˆå·²é™é»˜å¤„ç†ï¼‰:', error);
                        });
                    }
                }, 100);
            }
             // ä½¿ç”¨Cesiumé»˜è®¤åº•å›¾ï¼Œä¸åšå¹²é¢„
            
            // åœ¨file://åè®®ä¸‹ï¼Œè®¾ç½®åœ°çƒä¸ºå•è‰²ï¼ˆè“è‰²ï¼‰
            if (isFileProtocol) {
                // å»¶è¿Ÿè®¾ç½®ï¼Œç¡®ä¿globeå·²åˆå§‹åŒ–
                setTimeout(function() {
                    if (cesiumViewer && cesiumViewer.scene && cesiumViewer.scene.globe) {
                        try {
                            // è®¾ç½®åœ°çƒä¸ºè“è‰²ï¼ˆä½¿ç”¨baseColorï¼‰
                            cesiumViewer.scene.globe.baseColor = Cesium.Color.BLUE.withAlpha(0.8);
                            // æˆ–è€…ä½¿ç”¨ColorMaterialï¼ˆå¦‚æœéœ€è¦æè´¨ï¼‰
                            // cesiumViewer.scene.globe.material = new Cesium.ColorMaterial({
                            //     color: Cesium.Color.BLUE.withAlpha(0.8)
                            // });
                        } catch (e) {
                            console.log('[Cesium JS Info] è®¾ç½®åœ°çƒé¢œè‰²å¤±è´¥:', e);
                            	                        }
                        }
                    }, 200);
                }
            
            // åˆå§‹åŒ–Three.jsåœºæ™¯
            initThreeScene();
            
            // è®¾ç½®æ¸²æŸ“å¾ªç¯ï¼šåœ¨Cesiumæ¸²æŸ“ååŒæ­¥ç›¸æœºå¹¶æ¸²æŸ“THREE.jsåœºæ™¯
            cesiumViewer.scene.postRender.addEventListener(function() {
                syncCameraAndRender();
            });
            
            // æ·»åŠ åœ°å½¢å’Œå½±åƒé€‰æ‹©äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('terrainSelect').addEventListener('change', updateTerrain);
            document.getElementById('imagerySelect').addEventListener('change', updateImagery);

            // å¯åŠ¨åœºæ™¯ä¿¡æ¯æ›´æ–°
            startInfoUpdate();
            
            // å¤„ç†é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                window.receiveMessageFromPython(msg);
            }
            
            isInitialized = true;
            console.log('[Cesium JS Info] åˆå§‹åŒ–å®Œæˆ');
            
            // ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–ï¼Œç¡®ä¿Cesiumåœ¨å®¹å™¨å°ºå¯¸å˜ä¸ºæœ‰æ•ˆæ—¶æ­£ç¡®è°ƒæ•´
            // è¿™åœ¨Qt WebEngineä¸­å¾ˆé‡è¦ï¼Œå› ä¸ºæœªæ¿€æ´»çš„æ ‡ç­¾é¡µå®¹å™¨å°ºå¯¸å¯èƒ½ä¸º0
            let lastWidth = cesiumContainer.offsetWidth;
            let lastHeight = cesiumContainer.offsetHeight;
            
            // ä½¿ç”¨ResizeObserverç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–ï¼ˆå¦‚æœæ”¯æŒï¼‰
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(function(entries) {
                    for (const entry of entries) {
                        const width = entry.contentRect.width;
                        const height = entry.contentRect.height;
                        if (width > 0 && height > 0 && (width !== lastWidth || height !== lastHeight)) {
                            lastWidth = width;
                            lastHeight = height;
                            console.log('[Cesium JS Info] å®¹å™¨å°ºå¯¸å˜åŒ–ï¼Œè°ƒæ•´Cesium Viewer:', width, 'x', height);
                            if (cesiumViewer) {
                                cesiumViewer.resize();
                            }
                            if (threeRenderer) {
                                threeRenderer.setSize(width, height);
                                threeCamera.aspect = width / height;
                                threeCamera.updateProjectionMatrix();
                            }
                        }
                    }
                });
                resizeObserver.observe(cesiumContainer);
            } else {
                // å¤‡ç”¨æ–¹æ¡ˆï¼šå®šæœŸæ£€æŸ¥å®¹å™¨å°ºå¯¸
                const checkSizeInterval = setInterval(function() {
                    const width = cesiumContainer.offsetWidth;
                    const height = cesiumContainer.offsetHeight;
                    if (width > 0 && height > 0 && (width !== lastWidth || height !== lastHeight)) {
                        lastWidth = width;
                        lastHeight = height;
                        console.log('[Cesium JS Info] å®¹å™¨å°ºå¯¸å˜åŒ–ï¼Œè°ƒæ•´Cesium Viewer:', width, 'x', height);
                        if (cesiumViewer) {
                            cesiumViewer.resize();
                        }
                        if (threeRenderer) {
                            threeRenderer.setSize(width, height);
                            threeCamera.aspect = width / height;
                            threeCamera.updateProjectionMatrix();
                        }
                    }
                }, 500); // æ¯500msæ£€æŸ¥ä¸€æ¬¡
                
                // åœ¨çª—å£å¤§å°å˜åŒ–æ—¶ä¹Ÿæ£€æŸ¥
                window.addEventListener('resize', function() {
                    const width = cesiumContainer.offsetWidth;
                    const height = cesiumContainer.offsetHeight;
                    if (width > 0 && height > 0) {
                        if (cesiumViewer) {
                            cesiumViewer.resize();
                        }
                        if (threeRenderer) {
                            threeRenderer.setSize(width, height);
                            threeCamera.aspect = width / height;
                            threeCamera.updateProjectionMatrix();
                        }
                    }
                });
            }
            
            // é€šçŸ¥Pythonåˆå§‹åŒ–å®Œæˆ
            function notifyPython() {
                if (pyBridge && pyBridge.receiveMessage) {
                    try {
                        pyBridge.receiveMessage(JSON.stringify({
                            type: 'viewerReady',
                            message: 'Cesium viewerå·²åˆå§‹åŒ–'
                        }));
                    } catch (e) {
                        console.log('[Cesium JS Info] é€šçŸ¥Pythonå¤±è´¥:', e);
                    }
                } else if (window.pyBridge && window.pyBridge.receiveMessage) {
                    try {
                        window.pyBridge.receiveMessage(JSON.stringify({
                            type: 'viewerReady',
                            message: 'Cesium viewerå·²åˆå§‹åŒ–'
                        }));
                    } catch (e) {
                        console.log('[Cesium JS Info] é€šçŸ¥Pythonå¤±è´¥:', e);
                    }
                }
            }
            
            // å»¶è¿Ÿé€šçŸ¥ï¼Œç¡®ä¿WebChannelå·²è¿æ¥
            setTimeout(notifyPython, 500);
            
            } catch (error) {
                console.error('[Cesium JS Error] åˆå§‹åŒ–å¤±è´¥:', error);
                isInitializing = false;
            }
        };
        
        function initThreeScene() {
            // åˆ›å»ºThree.jsåœºæ™¯
            threeScene = new THREE.Scene();
            
            // åˆ›å»ºç›¸æœºï¼ˆå°†ä½¿ç”¨Cesiumç›¸æœºï¼‰
            // å¢åŠ far planeåˆ°1e10ï¼Œä»¥é€‚åº”Cesiumçš„ECEFåæ ‡ç³»ï¼ˆåœ°çƒåŠå¾„çº¦6.3e6ç±³ï¼‰
            threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1e10);
            threeScene.add(threeCamera);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            threeRenderer = new THREE.WebGLRenderer({
                alpha: true
            });
            // ç§»é™¤setPixelRatioï¼Œå› ä¸ºGaussianSplats3Dé…ç½®äº†ignoreDevicePixelRatio: true
            // ä¸”GSSEWå‚è€ƒå®ç°ä¸­æ²¡æœ‰è®¾ç½®æ­¤é¡¹ï¼Œè®¾ç½®å®ƒå¯èƒ½å¯¼è‡´è§†å£è®¡ç®—é”™è¯¯
            // threeRenderer.setPixelRatio(window.devicePixelRatio);
            threeRenderer.setSize(window.innerWidth, window.innerHeight);
            // ç§»é™¤autoClear = falseï¼Œä½¿ç”¨é»˜è®¤å€¼trueï¼Œä¸GSSEWä¿æŒä¸€è‡´
            // è¿™æ ·æ¯å¸§éƒ½ä¼šæ¸…é™¤Three.jsçš„é¢œè‰²å’Œæ·±åº¦ç¼“å†²åŒºï¼Œé¿å…ç´¯ç§¯å’Œæ·±åº¦æµ‹è¯•é—®é¢˜
            threeRenderer.autoClear = false; // æ‰‹åŠ¨æ§åˆ¶æ¸…é™¤ï¼Œé¿å…å¤šé‡æ¸²æŸ“æ—¶çš„æ¸…é™¤é—®é¢˜
            
            const threeContainer = document.getElementById('threeContainer');
            threeContainer.appendChild(threeRenderer.domElement);
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', function() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                threeRenderer.setSize(width, height);
                threeCamera.aspect = width / height;
                threeCamera.updateProjectionMatrix();
            });
        }
        
        // åŒæ­¥Cesiumç›¸æœºåˆ°THREE.jsç›¸æœºå¹¶æ¸²æŸ“ï¼ˆå‚è€ƒcesium-gaussian-splattingé¡¹ç›®ï¼‰
        function syncCameraAndRender() {
            if (!cesiumViewer || !threeCamera || !threeRenderer) return;

            // æ‰‹åŠ¨æ¸…é™¤ç¼“å†²åŒº
            threeRenderer.clear();
            
            // åŒæ­¥ç›¸æœºFOV
            threeCamera.fov = Cesium.Math.toDegrees(cesiumViewer.camera.frustum.fovy);
            threeCamera.updateProjectionMatrix();
            
            // ä»Cesiumç›¸æœºè·å–è§†å›¾çŸ©é˜µ
            const cesiumCamera = cesiumViewer.camera;
            const cvm = cesiumCamera.viewMatrix;
            const civm = cesiumCamera.inverseViewMatrix;
            
            // æå–ç›¸æœºä½ç½®
            const cameraPosition = Cesium.Cartesian3.fromElements(
                civm[12],
                civm[13],
                civm[14]
            );
            
            // æå–ç›¸æœºæ–¹å‘
            const cameraDirection = new Cesium.Cartesian3(-cvm[2], -cvm[6], -cvm[10]);
            const cameraUp = new Cesium.Cartesian3(cvm[1], cvm[5], cvm[9]);
            
            // è½¬æ¢ä¸ºTHREE.jså‘é‡
            const cameraPositionVec3 = new THREE.Vector3(
                cameraPosition.x,
                cameraPosition.y,
                cameraPosition.z
            );
            const cameraDirectionVec3 = new THREE.Vector3(
                cameraDirection.x,
                cameraDirection.y,
                cameraDirection.z
            );
            const cameraUpVec3 = new THREE.Vector3(cameraUp.x, cameraUp.y, cameraUp.z);
            
            // æ›´æ–°THREE.jsç›¸æœº
            threeCamera.position.copy(cameraPositionVec3);
            threeCamera.up.copy(cameraUpVec3);
            threeCamera.lookAt(cameraPositionVec3.clone().add(cameraDirectionVec3));
            
            // å…³é”®ï¼šæ‰‹åŠ¨æ›´æ–°ç›¸æœºçŸ©é˜µï¼Œç¡®ä¿splatViewer.update()ä½¿ç”¨çš„æ˜¯æœ€æ–°çš„ç›¸æœºçŠ¶æ€
            threeCamera.updateMatrixWorld(true);
            
            // æ›´æ–°å¹¶æ¸²æŸ“æ‰€æœ‰é«˜æ–¯æ¨¡å‹ï¼ˆä¸¥æ ¼æŒ‰ç…§cesium-gaussian-splattingé¡¹ç›®ï¼‰
            // æ ¹æ®cesium-gaussian-splattingçš„å®ç°ï¼š
            // 1. å…ˆè°ƒç”¨splatViewer.update()æ›´æ–°çŠ¶æ€
            // 2. ç„¶åè°ƒç”¨splatViewer.render()æ¸²æŸ“splatMesh
            // 3. æœ€åè°ƒç”¨threeRenderer.render()æ¸²æŸ“sceneä¸­çš„å…¶ä»–å¯¹è±¡
            let needBoundsUpdate = false;
            gaussianSplatLayers.forEach(function(layer) {
                if (!layer.ready) return;
                if (layer.visible === false) return; // å¦‚æœä¸å¯è§ï¼Œè·³è¿‡æ¸²æŸ“
                
                // ç¡®ä¿sceneå’Œmeshçš„ä¸–ç•Œå˜æ¢çŸ©é˜µå·²æ›´æ–°
                // è¿™æ˜¯å…³é”®ï¼šå› ä¸ºmeshåœ¨sceneä¸­ï¼Œè€Œsceneçš„ä½ç½®æ˜¯Cesiumåæ ‡ï¼ˆéå¸¸å¤§çš„æ•°å­—ï¼‰
                // éœ€è¦ç¡®ä¿ä¸–ç•Œå˜æ¢çŸ©é˜µæ­£ç¡®è®¡ç®—
                if (layer.scene) {
                    layer.scene.updateMatrixWorld(true);
                    
                    // è°ƒè¯•ï¼šæ£€æŸ¥meshçš„ä¸–ç•Œä½ç½®ï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡æ¸²æŸ“æ—¶è¾“å‡ºï¼‰
                    if (layer._firstRender === undefined) {
                        layer._firstRender = true;
                        const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                        if (mesh) {
                            const worldPos = new THREE.Vector3();
                            mesh.getWorldPosition(worldPos);
                            console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - Meshä¸–ç•Œä½ç½®:', worldPos.x, worldPos.y, worldPos.z);
                            console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - Sceneä½ç½®:', layer.scene.position.x, layer.scene.position.y, layer.scene.position.z);
                            console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - ç›¸æœºä½ç½®:', threeCamera.position.x, threeCamera.position.y, threeCamera.position.z);
                        }
                    }
                }
                
                if (layer._needsBoundsUpdate) {
                    needBoundsUpdate = true;
                }
                
                // è°ƒç”¨splatViewerçš„updateå’Œrenderæ–¹æ³•ï¼ˆä¸¥æ ¼æŒ‰ç…§cesium-gaussian-splattingé¡¹ç›®ï¼‰
                try {
                    if (layer.splatViewer && typeof layer.splatViewer.update === 'function') {
                        layer.splatViewer.update();
                    }
                    
                    // æ¢å¤splatViewer.render()ï¼Œå› ä¸ºGSSEWå‚è€ƒå®ç°ä¸­è°ƒç”¨äº†å®ƒ
                    // è¿™å¯èƒ½å¯¹è§¦å‘workeræ•°æ®ä¼ è¾“æˆ–çŠ¶æ€æ›´æ–°æ˜¯å¿…è¦çš„
                    if (layer.splatViewer && typeof layer.splatViewer.render === 'function') {
                        layer.splatViewer.render();
                    }

                    const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                    const instanceCount = mesh && mesh.geometry ? mesh.geometry.instanceCount : null;
                    
                    // å¦‚æœinstanceCountä¸º0ä½†åº”è¯¥æœ‰æ•°æ®ï¼Œå°è¯•å¼ºåˆ¶æ›´æ–°
                    if (instanceCount === 0 && mesh && mesh.getSplatCount && mesh.getSplatCount() > 0) {
                        if (!layer._forceUpdateAttempted) {
                            console.log('[Cesium JS Info] instanceCountä¸º0ä½†æœ‰splatsï¼Œå°è¯•å¼ºåˆ¶æ›´æ–°...');
                            // å°è¯•å¼ºåˆ¶æ›´æ–°geometry
                            if (mesh.geometry && mesh.geometry.attributes) {
                                const totalSplats = mesh.getSplatCount();
                                mesh.geometry.instanceCount = totalSplats;
                                if (mesh.geometry.attributes.splatIndex) {
                                    mesh.geometry.attributes.splatIndex.needsUpdate = true;
                                }
                                console.log('[Cesium JS Info] å¼ºåˆ¶è®¾ç½®instanceCountä¸º:', totalSplats);
                            }
                            layer._forceUpdateAttempted = true;
                        }
                    }
                    
                    if (layer._debugLogged !== true) {
                        const renderCount = (mesh && mesh.geometry && mesh.geometry.drawRange) ? mesh.geometry.drawRange.count : null;
                        console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - geometry.instanceCount:', instanceCount);
                        console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - geometry.drawRange.count:', renderCount);
                        if (mesh && mesh.getSplatCount) {
                            console.log('[Cesium JS Info] é¦–æ¬¡æ¸²æŸ“ - æ€»splats:', mesh.getSplatCount());
                        }
                        layer._debugLogged = true;
                    }
                    
                    // å¦‚æœinstanceCountå˜ä¸ºæ­£æ•°ä¸”ä¹‹å‰æ˜¯0ï¼Œè®°å½•ä¸€ä¸‹
                    if (instanceCount > 0 && !layer._hasShownInstanceCount) {
                        console.log('[Cesium JS Info] geometry.instanceCountå·²æ›´æ–°ä¸º:', instanceCount);
                        layer._hasShownInstanceCount = true;
                    }
                    
                    // æ¯60å¸§ï¼ˆçº¦1ç§’ï¼‰è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
                    if (!layer._frameCount) layer._frameCount = 0;
                    layer._frameCount++;
                    if (layer._frameCount % 60 === 0) {
                         if (instanceCount === 0) {
                             console.log('[Cesium JS Info] ç­‰å¾…Splatæ’åº... instanceCount:', instanceCount);
                             // è°ƒè¯•ï¼šæ£€æŸ¥ç›¸æœºå’ŒMeshçš„è·ç¦»åŠçŠ¶æ€
                             if (mesh) {
                                 const meshPos = new THREE.Vector3();
                                 mesh.getWorldPosition(meshPos);
                                 const dist = threeCamera.position.distanceTo(meshPos);
                                 console.log('[Cesium JS Info] Debug Info:', JSON.stringify({
                                     distToCamera: dist,
                                     meshPos: {x: meshPos.x, y: meshPos.y, z: meshPos.z},
                                     visible: mesh.visible,
                                     frustumCulled: mesh.frustumCulled,
                                     materialVisible: mesh.material ? mesh.material.visible : 'no material'
                                 }));
                             }
                         }
                    }
                } catch (e) {
                    console.warn('[Cesium JS Warning] æ›´æ–°/æ¸²æŸ“æ¨¡å‹æ—¶å‡ºé”™:', e);
                    console.error('[Cesium JS Error] é”™è¯¯è¯¦æƒ…:', e);
                }
            });
            
            if (needBoundsUpdate) {
                calculateBoundingSphere();
            }
            
            // æ ¹æ®cesium-gaussian-splattingé¡¹ç›®ï¼Œåœ¨splatViewer.render()ä¹‹åï¼Œ
            // è¿˜éœ€è¦è°ƒç”¨threeRenderer.render()æ¥æ¸²æŸ“sceneä¸­çš„å…¶ä»–å¯¹è±¡
            // è™½ç„¶splatViewer.render()å·²ç»æ¸²æŸ“äº†splatMeshï¼Œä½†threeRenderer.render()ä¸ä¼šé‡å¤æ¸²æŸ“
            // å› ä¸ºsplatMeshå·²ç»åœ¨splatViewer.render()ä¸­æ¸²æŸ“è¿‡äº†
            threeRenderer.render(threeScene, threeCamera);
        }
        
        function updateTerrain() {
            const select = document.getElementById('terrainSelect');
            const value = select.options[select.selectedIndex].value;
            
            if (value === 'world') {
                cesiumViewer.terrainProvider = Cesium.createWorldTerrain();
            } else {
                cesiumViewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
            }
        }
        
        function updateImagery(fallbackAttempted = false) {
            const select = document.getElementById('imagerySelect');
            const value = select.options[select.selectedIndex].value;
            let provider = null;
            
            try {
                switch (value) {
                    case 'bing':
                        provider = new Cesium.BingMapsImageryProvider({
                            url: 'https://dev.virtualearth.net',
                            key: 'AuhfJZVHlwH7UQ8cW8lqFuF7q7nCxTfa5bkCbEMjXjzQ57b9sV_8s8pE7zR7Z-iN',
                            mapStyle: Cesium.BingMapsStyle.AERIAL
                        });
                        break;
                    case 'osm':
                        provider = new Cesium.OpenStreetMapImageryProvider({
                            url: 'https://a.tile.openstreetmap.org/'
                        });
                        break;
                    case 'arcgis':
                        provider = new Cesium.ArcGisMapServerImageryProvider({
                            url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
                        });
                        break;
                }
            } catch (error) {
                console.error(`[Cesium JS Error] åˆ›å»ºå½±åƒå›¾å±‚å¤±è´¥(${value}):`, error);
                if (!fallbackAttempted && value !== 'osm') {
                    console.log('[Cesium JS Info] å›é€€åˆ°OpenStreetMapå½±åƒ');
                    select.value = 'osm';
                    updateImagery(true);
                }
                return;
            }

            if (!provider) {
                console.warn('[Cesium JS Warning] æœªåˆ›å»ºæ–°çš„å½±åƒå›¾å±‚æä¾›è€…');
                return;
            }
            
            let oldLayer = null;
            if (cesiumViewer.imageryLayers.length > 0) {
                oldLayer = cesiumViewer.imageryLayers.get(0);
            }

            let newLayer = null;
            try {
                newLayer = cesiumViewer.imageryLayers.addImageryProvider(provider);
            } catch (error) {
                console.error(`[Cesium JS Error] æ·»åŠ å½±åƒå›¾å±‚å¤±è´¥(${value}):`, error);
                if (!fallbackAttempted && value !== 'osm') {
                    console.log('[Cesium JS Info] å›é€€åˆ°OpenStreetMapå½±åƒ');
                    select.value = 'osm';
                    updateImagery(true);
                }
                return;
            }

            if (oldLayer) {
                cesiumViewer.imageryLayers.remove(oldLayer);
            }

            if (provider.readyPromise && typeof provider.readyPromise.then === 'function') {
                provider.readyPromise.then(function() {
                    console.log(`[Cesium JS Info] å½±åƒå›¾å±‚å·²å‡†å¤‡å°±ç»ª: ${value}`);
                }).catch(function(error) {
                    console.error(`[Cesium JS Error] å½±åƒå›¾å±‚åŠ è½½å¤±è´¥(${value}):`, error);
                    if (!fallbackAttempted && value !== 'osm') {
                        console.log('[Cesium JS Info] å›é€€åˆ°OpenStreetMapå½±åƒ');
                        select.value = 'osm';
                        updateImagery(true);
                    }
                });
            }
            if (provider.errorEvent && typeof provider.errorEvent.addEventListener === 'function') {
                provider.errorEvent.addEventListener(function(error) {
                    console.error(`[Cesium JS Error] å½±åƒå›¾å±‚è¯·æ±‚é”™è¯¯(${value}):`, error);
                });
            }

            if (newLayer && typeof newLayer.show === 'boolean') {
                newLayer.show = true;
            }
        }
        
        async function loadModel(data) {
            try {
                let resourceUrl = data.url || '';
                const lon = data.location.lon;
                const lat = data.location.lat;
                const height = data.location.height || 0;
                const scale = data.scale || 1.0;
                const rotation = data.rotation || {x: 0, y: 0, z: 0};
                const modelId = data.modelId || `model_${Date.now()}`;
                const isSegment = data.isSegment || false;
                const segmentId = data.segmentId || null;

                let arrayBuffer = null;
                // å¯¹ data URL ä¸å†åšè½¬æ¢ï¼Œç›´æ¥äº¤ç»™ addSplatScene å¤„ç†ï¼Œé¿å…å†…å­˜é—®é¢˜
                // å¯¹ http/https åŒç†

                const position = Cesium.Cartesian3.fromDegrees(lon, lat, height);

                    const splatConfig = {
                        selfDrivenMode: false,
                        gpuAcceleratedSort: false, // ç¦ç”¨GPUæ’åºï¼Œé¿å…workeré—®é¢˜
                        sharedMemoryForWorkers: false, // ç¦ç”¨å…±äº«å†…å­˜
                        ignoreDevicePixelRatio: true,
                        sceneRevealMode: window.GaussianSplats3D.SceneRevealMode.Always,
                        useBuiltInControls: false,
                        enableSIMDInSort: false, // ç¦ç”¨SIMD
                        camera: threeCamera,
                        renderer: threeRenderer,
                        logLevel: window.GaussianSplats3D.LogLevel.Info
                    };
                    console.log('[Cesium JS Info] SplatConfig:', JSON.stringify(splatConfig));

                const splatViewer = new window.GaussianSplats3D.Viewer(splatConfig);

                // åˆ›å»ºçˆ¶åœºæ™¯å¹¶æ”¾ç½®åœ¨æŒ‡å®šä½ç½®
                // å‚è€ƒGSSEWé¡¹ç›®ï¼šç›´æ¥å°†splatåœºæ™¯æ”¾åœ¨ä¸–ç•Œä½ç½®ä¼šå¯¼è‡´æŠ–åŠ¨
                // å› æ­¤ä½¿ç”¨çˆ¶åœºæ™¯åŒ…è£¹ï¼Œå¹¶åœ¨çˆ¶åœºæ™¯ä¸Šè®¾ç½®ä½ç½®å’Œæ—‹è½¬
                const scene = new THREE.Scene();
                scene.position.set(position.x, position.y, position.z);
                // åº”ç”¨æ—‹è½¬ - æ³¨æ„ï¼šè¿™é‡Œçš„æ—‹è½¬æ˜¯ç›¸å¯¹äºCesiumåæ ‡ç³»çš„
                scene.rotation.set(rotation.x, rotation.y, rotation.z);

                const layer = {
                    scene,
                    splatViewer,
                    ready: false,
                    modelId,
                    isSegment,
                    segmentId,
                    geoLocation: { lon, lat, height },
                    scale,
                    rotation: { x: rotation.x, y: rotation.y, z: rotation.z },
                    blobUrl: resourceUrl.startsWith('blob:') ? resourceUrl : null,
                    _needsBoundsUpdate: true,
                    _pendingFlyTo: data.flyTo !== false,
                    visible: true  // æ·»åŠ å¯è§æ€§æ§åˆ¶
                };

                {
                    const isDataUrl = resourceUrl.startsWith('data:');
                    const splatOptions = {
                        showLoadingUI: false,
                        progressiveLoad: false, // ç»Ÿä¸€å…³é—­ï¼Œè§„é¿éƒ¨åˆ†ç¯å¢ƒ/æœåŠ¡å™¨çš„æ¸è¿›å¼åŠ è½½é—®é¢˜
                        rotation: [0, 0, 0],
                        scale: [1, 1, 1]
                    };
                    // æ˜¾å¼æŒ‡å®šæ ¼å¼
                    if (data.format) {
                        splatOptions.format = data.format;
                    } else if (isDataUrl || resourceUrl.toLowerCase().endsWith('.splat')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.Splat;
                    } else if (resourceUrl.toLowerCase().endsWith('.ply')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.Ply;
                    } else if (resourceUrl.toLowerCase().endsWith('.ksplat')) {
                        splatOptions.format = window.GaussianSplats3D.SceneFormat.KSplat;
                    }
                    await splatViewer.addSplatScene(resourceUrl, splatOptions);
                }

                const mesh = splatViewer.getSplatMesh();
                if (!mesh) {
                    throw new Error('æœªèƒ½è·å–åˆ°SplatMesh');
                }
                console.log('[Cesium JS Info] 3DGSæ¨¡å‹åŠ è½½æˆåŠŸ:', modelId);

                // åº”ç”¨ç¼©æ”¾åˆ°mesh
                mesh.scale.set(scale, scale, scale);
                // ç¦ç”¨è§†é”¥ä½“å‰”é™¤ï¼Œé˜²æ­¢å› åŒ…å›´ç›’è®¡ç®—ä¸å‡†å¯¼è‡´æ¶ˆå¤±
                mesh.frustumCulled = false;
                
                // ç¡®ä¿meshè¢«æ·»åŠ åˆ°layer.sceneï¼ˆå¦‚æœè¿˜æ²¡æœ‰æ·»åŠ ï¼‰
                if (mesh.parent !== layer.scene) {
                    layer.scene.add(mesh);
                }
                
                // ç¡®ä¿meshçš„åˆå§‹æ—‹è½¬æ˜¯æ­£ç¡®çš„ï¼ˆç›¸å¯¹äºçˆ¶sceneï¼‰
                // ä¿®æ­£å€’ç«‹é—®é¢˜ï¼šç»•Xè½´æ—‹è½¬180åº¦
                mesh.rotation.set(Math.PI, 0, 0);
                
                layer.scene.updateMatrixWorld(true);
                threeScene.add(layer.scene);
                
                console.log('[Cesium JS Info] Mesh added to scene. Mesh parent:', mesh.parent ? 'layer.scene' : 'null');

                layer.ready = true;
                gaussianSplatLayers.push(layer);
                calculateBoundingSphere();
                document.getElementById('modelCount').textContent = gaussianSplatLayers.length;
                
                // æ›´æ–°æ¨¡å‹åˆ—è¡¨UI
                updateModelListUI();

                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'loadComplete',
                        success: true,
                        modelId,
                        isSegment,
                        segmentId
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] åŠ è½½3DGSæ¨¡å‹æ—¶å‡ºé”™:', error);
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'loadComplete',
                        success: false,
                        error: error.message || String(error),
                        modelId: data.modelId || 'unknown'
                    }));
                }
            }
        }
        
        // å¯¹é½é¡¹ç›®ç»“æ„ï¼šæä¾›ä¸ cesium-gaussian-splatting ç›¸åŒçš„å…¥å£
        function load3DGS(data) {
            return loadModel(data);
        }
        // æš´éœ²ä¸ºå…¨å±€ï¼Œä¾› Qt/Python è°ƒç”¨
        window.load3DGS = load3DGS;
        
        function calculateBoundingSphere() {
            if (gaussianSplatLayers.length === 0) {
                modelBoundingSphere = null;
                return;
            }
            
            // è®¡ç®—æ‰€æœ‰æ¨¡å‹çš„è”åˆè¾¹ç•Œçƒ
            // ä½¿ç”¨geoLocationå’Œmeshçš„boundingBoxæ¥è®¡ç®—
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            let hasValidBounds = false;
            
            for (const layer of gaussianSplatLayers) {
                try {
                    if (!layer.ready || !layer.scene) continue;

                    const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                    let boundsUpdated = false;

                    // å°è¯•è·å–SplatMeshçš„åŒ…å›´ç›’
                    // æ³¨æ„ï¼šGaussianSplats3Dçš„mesh.boundingBoxå¯èƒ½æœªè®¡ç®—æˆ–ä¸ºç©º
                    if (mesh && !boundsUpdated) {
                        // å¼ºåˆ¶æ›´æ–°ä¸€æ¬¡çŸ©é˜µï¼Œç¡®ä¿localToWorldæ­£ç¡®
                        mesh.updateMatrixWorld(true);
                        
                        // ä¼˜å…ˆä½¿ç”¨geometryçš„boundingBoxï¼Œå› ä¸ºå®ƒæ˜¯åŸå§‹æ•°æ®çš„åŒ…å›´ç›’
                        if (mesh.geometry && !mesh.geometry.boundingBox) {
                            mesh.geometry.computeBoundingBox();
                        }
                        
                        let box = null;
                        if (mesh.geometry && mesh.geometry.boundingBox) {
                            box = mesh.geometry.boundingBox;
                        } else if (mesh.boundingBox) {
                            box = mesh.boundingBox;
                        }
                        
                        // æ£€æŸ¥boxæ˜¯å¦æœ‰æ•ˆï¼ˆéç©ºä¸”éæ— é™ï¼‰
                        const isValidBox = box &&
                                         isFinite(box.min.x) && isFinite(box.min.y) && isFinite(box.min.z) &&
                                         isFinite(box.max.x) && isFinite(box.max.y) && isFinite(box.max.z) &&
                                         (box.max.x > box.min.x || box.max.y > box.min.y || box.max.z > box.min.z);

                        if (isValidBox) {
                            console.log('[Cesium JS Info] ä½¿ç”¨Mesh/Geometry BoundingBox:', JSON.stringify(box));
                            const corners = [
                                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                                new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                            ];

                            corners.forEach((corner) => {
                                // å°†å±€éƒ¨åæ ‡è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                                // æ³¨æ„ï¼šmeshåœ¨layer.sceneä¸­ï¼Œlayer.sceneåœ¨threeSceneä¸­
                                // mesh.localToWorldä¼šè€ƒè™‘æ‰€æœ‰çˆ¶çº§å˜æ¢
                                const worldCorner = corner.clone();
                                mesh.localToWorld(worldCorner);
                                
                                minX = Math.min(minX, worldCorner.x);
                                minY = Math.min(minY, worldCorner.y);
                                minZ = Math.min(minZ, worldCorner.z);
                                maxX = Math.max(maxX, worldCorner.x);
                                maxY = Math.max(maxY, worldCorner.y);
                                maxZ = Math.max(maxZ, worldCorner.z);
                            });

                            hasValidBounds = true;
                            boundsUpdated = true;
                        }
                    }

                    // å¦‚æœæ²¡æœ‰meshæˆ–æ— æ³•è®¡ç®—ï¼Œå›é€€åˆ°geoLocation
                    if (!boundsUpdated && layer.geoLocation) {
                        const pos = Cesium.Cartesian3.fromDegrees(
                            layer.geoLocation.lon,
                            layer.geoLocation.lat,
                            layer.geoLocation.height
                        );
                        const radius = 100;

                        minX = Math.min(minX, pos.x - radius);
                        minY = Math.min(minY, pos.y - radius);
                        minZ = Math.min(minZ, pos.z - radius);
                        maxX = Math.max(maxX, pos.x + radius);
                        maxY = Math.max(maxY, pos.y + radius);
                        maxZ = Math.max(maxZ, pos.z + radius);

                        hasValidBounds = true;
                    }

                    // å¦‚æœboundingBoxä¸å¯ç”¨ï¼Œä½†æœ‰åœºæ™¯ä¸­å¿ƒå’Œæœ€å¤§è·ç¦»ï¼Œä½¿ç”¨å®ƒæ¥ä¼°ç®—
                    if (!boundsUpdated && mesh && mesh.calculatedSceneCenter && mesh.maxSplatDistanceFromSceneCenter) {
                        console.log('[Cesium JS Info] ä½¿ç”¨maxSplatDistanceè®¡ç®—è¾¹ç•Œ:', mesh.maxSplatDistanceFromSceneCenter);
                        const centerLocal = mesh.calculatedSceneCenter.clone();
                        const worldCenter = centerLocal.clone();
                        layer.scene.localToWorld(worldCenter);
                        const radius = mesh.maxSplatDistanceFromSceneCenter * (layer.scale || 1);

                        minX = Math.min(minX, worldCenter.x - radius);
                        minY = Math.min(minY, worldCenter.y - radius);
                        minZ = Math.min(minZ, worldCenter.z - radius);
                        maxX = Math.max(maxX, worldCenter.x + radius);
                        maxY = Math.max(maxY, worldCenter.y + radius);
                        maxZ = Math.max(maxZ, worldCenter.z + radius);

                        hasValidBounds = true;
                        boundsUpdated = true;
                    }

                    if (boundsUpdated) {
                        layer._needsBoundsUpdate = false;
                    }

                } catch (e) {
                    console.warn('[Cesium JS Warning] è®¡ç®—è¾¹ç•Œçƒæ—¶å‡ºé”™:', e);
                }
            }
            
            if (hasValidBounds) {
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const radius = Math.sqrt(
                    Math.pow(maxX - minX, 2) + 
                    Math.pow(maxY - minY, 2) + 
                    Math.pow(maxZ - minZ, 2)
                ) / 2;
                
                modelBoundingSphere = {
                    center: [centerX, centerY, centerZ],
                    radius: radius
                };
            } else {
                // å›é€€ï¼šä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å‹çš„ä½ç½®
                const firstLayer = gaussianSplatLayers[0];
                if (firstLayer && firstLayer.geoLocation) {
                    const pos = Cesium.Cartesian3.fromDegrees(
                        firstLayer.geoLocation.lon,
                        firstLayer.geoLocation.lat,
                        firstLayer.geoLocation.height
                    );
                    modelBoundingSphere = {
                        center: [pos.x, pos.y, pos.z],
                        radius: 100
                    };
                }
            }

            if (modelBoundingSphere) {
                console.log('[Cesium JS Info] è¾¹ç•Œçƒè®¡ç®—ç»“æœ:', JSON.stringify(modelBoundingSphere));
                const pendingFlyLayers = gaussianSplatLayers.filter(layer => layer._pendingFlyTo);
                if (pendingFlyLayers.length > 0) {
                    pendingFlyLayers.forEach(layer => layer._pendingFlyTo = false);
                    console.log('[Cesium JS Info] è¾¹ç•Œçƒå·²è®¡ç®—ï¼Œæ‰§è¡Œé£è¡Œ');
                    flyToModel();
                }
            }
        }
        
        function loadSegment(data) {
            console.log('[Cesium JS Info] åŠ è½½åˆ†å‰²æ¨¡å‹:', data);
            
            // ä½¿ç”¨load3DGSå‡½æ•°ï¼Œä½†æ ‡è®°ä¸ºåˆ†å‰²æ¨¡å‹
            const segmentData = {
                ...data,
                isSegment: true,
                modelId: data.segmentId || `segment_${Date.now()}`
            };
            
            load3DGS(segmentData);
        }
        
        function highlightSegment(data) {
            const segmentId = data.segmentId;
            console.log('[Cesium JS Info] é«˜äº®åˆ†å‰²:', segmentId);
            
            // æŸ¥æ‰¾å¯¹åº”çš„åˆ†å‰²æ¨¡å‹
            const segment = gaussianSplatLayers.find(splat => 
                splat.isSegment && splat.segmentId === segmentId
            );
            
            if (segment) {
                // ä¸´æ—¶é«˜äº®æ•ˆæœï¼šè°ƒæ•´é€æ˜åº¦æˆ–é¢œè‰²
                // è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„é«˜äº®æ•ˆæœ
                console.log('[Cesium JS Info] æ‰¾åˆ°åˆ†å‰²æ¨¡å‹ï¼Œåº”ç”¨é«˜äº®æ•ˆæœ');
                
                // é€šçŸ¥Pythoné«˜äº®å®Œæˆ
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'highlightComplete',
                        success: true,
                        segmentId: segmentId
                    }));
                }
            } else {
                console.warn('[Cesium JS Warning] æœªæ‰¾åˆ°åˆ†å‰²æ¨¡å‹:', segmentId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'highlightComplete',
                        success: false,
                        error: 'æœªæ‰¾åˆ°åˆ†å‰²æ¨¡å‹',
                        segmentId: segmentId
                    }));
                }
            }
        }
        
        function removeModel(data) {
            const modelId = data.modelId;
            console.log('[Cesium JS Info] ç§»é™¤æ¨¡å‹:', modelId);
            
            const index = gaussianSplatLayers.findIndex(layer => layer.modelId === modelId);
            
            if (index !== -1) {
                const layer = gaussianSplatLayers[index];
                
                // æ¸…ç†Blob URLï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (layer.blobUrl) {
                    try {
                        URL.revokeObjectURL(layer.blobUrl);
                        console.log('[Cesium JS Info] å·²æ¸…ç†Blob URL');
                    } catch (e) {
                        console.warn('[Cesium JS Warning] æ¸…ç†Blob URLå¤±è´¥:', e);
                    }
                }
                
                // æ¸…ç†èµ„æºï¼ˆå‚è€ƒcesium-gaussian-splattingé¡¹ç›®ï¼‰
                if (layer.splatViewer && layer.splatViewer.dispose) {
                    layer.splatViewer.dispose().catch(err => {
                        console.warn('[Cesium JS Warning] æ¸…ç†æ¨¡å‹èµ„æºæ—¶å‡ºé”™:', err);
                    });
                }
                
                // ä»åœºæ™¯ä¸­ç§»é™¤ï¼ˆå‚è€ƒcesium-gaussian-splattingé¡¹ç›®ï¼‰
                if (layer.scene) {
                    threeScene.remove(layer.scene);
                }
                
                gaussianSplatLayers.splice(index, 1);
                
                // é‡æ–°è®¡ç®—è¾¹ç•Œçƒ
                calculateBoundingSphere();
                
                // æ›´æ–°æ¨¡å‹è®¡æ•°
                document.getElementById('modelCount').textContent = gaussianSplatLayers.length;
                
                // æ›´æ–°æ¨¡å‹åˆ—è¡¨UI
                updateModelListUI();
                
                console.log('[Cesium JS Info] æ¨¡å‹ç§»é™¤æˆåŠŸ:', modelId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'removeComplete',
                        success: true,
                        modelId: modelId
                    }));
                }
            } else {
                console.warn('[Cesium JS Warning] æœªæ‰¾åˆ°æ¨¡å‹:', modelId);
                
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'removeComplete',
                        success: false,
                        error: 'æœªæ‰¾åˆ°æ¨¡å‹',
                        modelId: modelId
                    }));
                }
            }
        }
        
        function clearAllModels() {
            console.log('[Cesium JS Info] æ¸…é™¤æ‰€æœ‰æ¨¡å‹');
            
            // ç§»é™¤æ‰€æœ‰é«˜æ–¯æ¨¡å‹ï¼ˆå‚è€ƒcesium-gaussian-splattingé¡¹ç›®ï¼‰
            for (const layer of gaussianSplatLayers) {
                // æ¸…ç†Blob URLï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (layer.blobUrl) {
                    try {
                        URL.revokeObjectURL(layer.blobUrl);
                    } catch (e) {
                        console.warn('[Cesium JS Warning] æ¸…ç†Blob URLå¤±è´¥:', e);
                    }
                }
                
                // æ¸…ç†èµ„æº
                if (layer.splatViewer && layer.splatViewer.dispose) {
                    layer.splatViewer.dispose().catch(err => {
                        console.warn('[Cesium JS Warning] æ¸…ç†æ¨¡å‹èµ„æºæ—¶å‡ºé”™:', err);
                    });
                }
                
                // ä»åœºæ™¯ä¸­ç§»é™¤
                if (layer.scene) {
                    threeScene.remove(layer.scene);
                }
            }
            gaussianSplatLayers = [];
            
            // é‡ç½®è¾¹ç•Œçƒ
            modelBoundingSphere = null;
            
            // æ›´æ–°æ¨¡å‹è®¡æ•°
            document.getElementById('modelCount').textContent = '0';
        }
        
        function setCameraPosition(data) {
            if (!cesiumViewer) return;
            
            const position = Cesium.Cartesian3.fromDegrees(
                data.longitude, 
                data.latitude, 
                data.height
            );
            
            cesiumViewer.camera.setView({
                destination: position,
                orientation: {
                    heading: data.heading || 0,
                    pitch: data.pitch || -Cesium.Math.PI_OVER_FOUR,
                    roll: data.roll || 0
                }
            });
        }
        
        // ç›¸å¯¹ç§»åŠ¨ç›¸æœºï¼ˆå¹³ç§»ï¼‰
        function moveCamera(data) {
            if (!cesiumViewer) return;
            
            const dx = data.x || 0; // å·¦å³ç§»åŠ¨
            const dy = data.y || 0; // ä¸Šä¸‹ç§»åŠ¨
            const dz = data.z || 0; // å‰åç§»åŠ¨
            
            // è·å–å½“å‰ç›¸æœºé«˜åº¦ï¼Œç”¨äºè°ƒæ•´ç§»åŠ¨é€Ÿåº¦
            const height = cesiumViewer.camera.positionCartographic.height;
            const moveFactor = height / 1000.0; // æ ¹æ®é«˜åº¦è°ƒæ•´ç§»åŠ¨é€Ÿåº¦
            
            if (dx !== 0) {
                cesiumViewer.camera.moveRight(dx * moveFactor);
            }
            if (dy !== 0) {
                cesiumViewer.camera.moveUp(dy * moveFactor);
            }
            if (dz !== 0) {
                cesiumViewer.camera.moveForward(dz * moveFactor);
            }
        }
        
        // ç¼©æ”¾ç›¸æœº
        function zoomCamera(data) {
            if (!cesiumViewer) return;
            
            const amount = data.amount || 0;
            const height = cesiumViewer.camera.positionCartographic.height;
            
            // é™åˆ¶æœ€å°é«˜åº¦
            if (amount > 0 && height < 10) return;
            
            cesiumViewer.camera.zoomIn(amount * height * 0.1);
        }
        
        // æ—‹è½¬ç›¸æœº
        function rotateCamera(data) {
            if (!cesiumViewer) return;
            
            const heading = data.heading || 0; // å·¦å³æ—‹è½¬
            const pitch = data.pitch || 0;     // ä¸Šä¸‹æ—‹è½¬
            
            if (heading !== 0) {
                cesiumViewer.camera.lookRight(heading);
            }
            if (pitch !== 0) {
                cesiumViewer.camera.lookUp(pitch);
            }
        }

        function resetView() {
            if (!cesiumViewer) return;
            cesiumViewer.camera.flyHome(1.0);
        }

        function setTopView() {
            if (!cesiumViewer) return;
            const camera = cesiumViewer.camera;
            const cartographic = camera.positionCartographic;
            
            cesiumViewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromRadians(
                    cartographic.longitude,
                    cartographic.latitude,
                    cartographic.height
                ),
                orientation: {
                    heading: 0.0,
                    pitch: Cesium.Math.toRadians(-90.0),
                    roll: 0.0
                }
            });
        }
        
        // æˆªå›¾åŠŸèƒ½ï¼šåˆå¹¶Cesiumå’ŒThree.jsçš„canvasï¼Œä¸åŒ…å«UIé¢æ¿
        function captureScreenshot(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                // ç­‰å¾…ä¸€å¸§æ¸²æŸ“å®Œæˆåå†æˆªå›¾
                cesiumViewer.scene.render();
                
                // ä½¿ç”¨requestAnimationFrameç¡®ä¿æ¸²æŸ“å®Œæˆ
                requestAnimationFrame(function() {
                    const cesiumCanvas = cesiumViewer.scene.canvas;
                    if (!cesiumCanvas || cesiumCanvas.width === 0 || cesiumCanvas.height === 0) {
                        console.error('[Cesium JS Error] Cesium Canvasæ— æ•ˆ');
                        return;
                    }
                    
                    // è·å–Three.jsæ¸²æŸ“å™¨çš„canvas
                    let threeCanvas = null;
                    if (threeRenderer && threeRenderer.domElement) {
                        threeCanvas = threeRenderer.domElement;
                    }
                    
                    // åˆ›å»ºåˆå¹¶çš„canvas
                    const mergedCanvas = document.createElement('canvas');
                    mergedCanvas.width = cesiumCanvas.width;
                    mergedCanvas.height = cesiumCanvas.height;
                    const ctx = mergedCanvas.getContext('2d');
                    
                    // å…ˆç»˜åˆ¶Cesiumåœºæ™¯ï¼ˆä½œä¸ºèƒŒæ™¯ï¼‰
                    ctx.drawImage(cesiumCanvas, 0, 0);
                    
                    // å¦‚æœæœ‰Three.js canvasï¼Œå åŠ ç»˜åˆ¶ï¼ˆThree.jsæ¸²æŸ“çš„å†…å®¹åœ¨Cesiumä¹‹ä¸Šï¼‰
                    if (threeCanvas && threeCanvas.width > 0 && threeCanvas.height > 0) {
                        // Three.js canvaså¯èƒ½å°ºå¯¸ä¸åŒï¼Œéœ€è¦ç¼©æ”¾
                        ctx.drawImage(threeCanvas, 0, 0, mergedCanvas.width, mergedCanvas.height);
                    }
                    
                    // å°†åˆå¹¶åçš„canvasè½¬æ¢ä¸ºbase64å›¾åƒ
                    const dataURL = mergedCanvas.toDataURL('image/png');
                    
                    // é€šè¿‡pyBridgeå‘é€å›Python
                    if (pyBridge && pyBridge.receiveMessage) {
                        pyBridge.receiveMessage(JSON.stringify({
                            type: 'screenshotCaptured',
                            data: {
                                imageData: dataURL,
                                width: mergedCanvas.width,
                                height: mergedCanvas.height
                            }
                        }));
                    } else {
                        console.error('[Cesium JS Error] pyBridgeæœªåˆå§‹åŒ–');
                    }
                });
            } catch (error) {
                console.error('[Cesium JS Error] æˆªå›¾å¤±è´¥:', error);
            }
        }
        
        // æ·»åŠ ç‚¹æ ‡ç­¾åŠŸèƒ½
        function addPointLabels(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                const points = data.points || [];
                if (points.length === 0) {
                    console.warn('[Cesium JS Warning] æ²¡æœ‰è¦æ˜¾ç¤ºçš„ç‚¹');
                    return;
                }
                
                // æ¸…é™¤ä¹‹å‰çš„ç‚¹æ ‡ç­¾
                if (window.cornerPointLabels) {
                    window.cornerPointLabels.forEach(function(label) {
                        cesiumViewer.entities.remove(label);
                    });
                }
                window.cornerPointLabels = [];
                
                // æ·»åŠ æ–°çš„ç‚¹æ ‡ç­¾
                points.forEach(function(point, index) {
                    // ç¡®ä¿longitudeå’Œlatitudeæ˜¯å¼§åº¦
                    const lon = typeof point.longitude === 'number' ? point.longitude : Cesium.Math.toRadians(point.longitude);
                    const lat = typeof point.latitude === 'number' ? point.latitude : Cesium.Math.toRadians(point.latitude);
                    
                    const entity = cesiumViewer.entities.add({
                        name: `CornerPoint_${index + 1}`,
                        position: Cesium.Cartesian3.fromRadians(
                            lon,
                            lat,
                            point.height || 0
                        ),
                        point: {
                            pixelSize: 20, // å¢å¤§ç‚¹çš„å¤§å°
                            color: point.color ? Cesium.Color.fromBytes(point.color[0], point.color[1], point.color[2]) : Cesium.Color.RED,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 3, // å¢åŠ è½®å»“å®½åº¦
                            heightReference: Cesium.HeightReference.NONE, // ä¸ä½¿ç”¨è´´åœ°ï¼Œä½¿ç”¨ç»å¯¹é«˜åº¦
                            disableDepthTestDistance: Number.POSITIVE_INFINITY // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿ç‚¹å§‹ç»ˆå¯è§
                        },
                        label: {
                            text: point.label || `P${index + 1}`,
                            font: '16px sans-serif', // å¢å¤§å­—ä½“
                            fillColor: Cesium.Color.YELLOW, // ä½¿ç”¨é»„è‰²æ ‡ç­¾æ›´æ˜æ˜¾
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 3,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -50), // è°ƒæ•´åç§»
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY // ç¦ç”¨æ·±åº¦æµ‹è¯•
                        }
                    });
                    
                    window.cornerPointLabels.push(entity);
                    console.log(`[Cesium JS Info] å·²æ·»åŠ è§’ç‚¹${index + 1}æ ‡ç­¾ï¼Œä½ç½®: (${Cesium.Math.toDegrees(lon).toFixed(6)}, ${Cesium.Math.toDegrees(lat).toFixed(6)}, ${point.height || 0})`);
                });
                
                console.log(`[Cesium JS Info] å·²æ·»åŠ ${points.length}ä¸ªè§’ç‚¹æ ‡ç­¾`);
            } catch (error) {
                console.error('[Cesium JS Error] æ·»åŠ ç‚¹æ ‡ç­¾å¤±è´¥:', error);
            }
        }
        
        // å¯è§†åŒ–è§’ç‚¹å’Œå°„çº¿ï¼ˆæ˜¾ç¤ºå››ä¸ªäº¤ç‚¹ã€å››è¾¹å½¢å’Œè§†é”¥ä½“ï¼‰
        function visualizeCornerPointsAndRays(cornerPoints3DThree, threeCamera, pixelPoints, imageWidth, imageHeight) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene || !threeCamera) {
                    console.error('[Cesium JS Error] æ— æ³•å¯è§†åŒ–ï¼švieweræˆ–ç›¸æœºæœªåˆå§‹åŒ–');
                    return;
                }
                
                if (!cornerPoints3DThree || cornerPoints3DThree.length !== 4) {
                    console.warn('[Cesium JS Warning] è§’ç‚¹æ•°é‡ä¸æ­£ç¡®ï¼Œæ— æ³•å¯è§†åŒ–');
                    return;
                }
                
                // æ¸…é™¤ä¹‹å‰çš„å¯è§†åŒ–
                clearCornerPointsVisualization();
                
                // 1. åœ¨Cesiumä¸­æ˜¾ç¤ºå››ä¸ªè§’ç‚¹ï¼ˆçº¢è‰²ç‚¹æ ‡ç­¾ï¼‰
                const cornerPointsGeo = [];
                cornerPoints3DThree.forEach((pt, idx) => {
                    try {
                        // å°†Three.jsåæ ‡è½¬æ¢ä¸ºCesium ECEFåæ ‡
                        const ecefPoint = new Cesium.Cartesian3(pt.x, pt.y, pt.z);
                        const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                        
                        // æ£€æŸ¥åæ ‡æ˜¯å¦æœ‰æ•ˆ
                        if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude)) {
                            const lonDeg = Cesium.Math.toDegrees(cartographic.longitude);
                            const latDeg = Cesium.Math.toDegrees(cartographic.latitude);
                            
                            console.log(`[Cesium JS Info] è§’ç‚¹${idx + 1}è½¬æ¢: Three.js(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.z.toFixed(2)}) -> åœ°ç†(${lonDeg.toFixed(6)}, ${latDeg.toFixed(6)}, ${cartographic.height.toFixed(2)})`);
                            
                            cornerPointsGeo.push({
                                longitude: cartographic.longitude, // å·²ç»æ˜¯å¼§åº¦
                                latitude: cartographic.latitude, // å·²ç»æ˜¯å¼§åº¦
                                height: cartographic.height,
                                label: `P${idx + 1}`,
                                color: [255, 0, 0] // çº¢è‰²
                            });
                            console.log(`[Cesium JS Info] è§’ç‚¹${idx + 1}æ·»åŠ åˆ°cornerPointsGeoï¼Œç»çº¬åº¦(å¼§åº¦): (${cartographic.longitude.toFixed(6)}, ${cartographic.latitude.toFixed(6)})`);
                        } else {
                            console.warn(`[Cesium JS Warning] è§’ç‚¹${idx + 1}åæ ‡æ— æ•ˆ: lon=${cartographic.longitude}, lat=${cartographic.latitude}`);
                        }
                    } catch (e) {
                        console.warn(`[Cesium JS Warning] æ— æ³•è½¬æ¢è§’ç‚¹${idx + 1}åæ ‡:`, e);
                    }
                });
                
                console.log(`[Cesium JS Info] æˆåŠŸè½¬æ¢${cornerPointsGeo.length}ä¸ªè§’ç‚¹åæ ‡`);
                
                // æ·»åŠ è§’ç‚¹æ ‡ç­¾
                if (cornerPointsGeo.length === 4) {
                    console.log('[Cesium JS Info] å¼€å§‹æ·»åŠ è§’ç‚¹æ ‡ç­¾å’Œå››è¾¹å½¢...');
                    addPointLabels({ points: cornerPointsGeo });
                    
                    // 2. åœ¨Cesiumä¸­ç»˜åˆ¶å››è¾¹å½¢ï¼ˆè¿æ¥å››ä¸ªè§’ç‚¹ï¼‰
                    const positions = cornerPointsGeo.map(pt => {
                        // ç¡®ä¿ä½¿ç”¨å¼§åº¦
                        const lon = typeof pt.longitude === 'number' ? pt.longitude : Cesium.Math.toRadians(pt.longitude);
                        const lat = typeof pt.latitude === 'number' ? pt.latitude : Cesium.Math.toRadians(pt.latitude);
                        const pos = Cesium.Cartesian3.fromRadians(lon, lat, pt.height);
                        return pos;
                    });
                    // é—­åˆå››è¾¹å½¢ï¼ˆæ·»åŠ ç¬¬ä¸€ä¸ªç‚¹åˆ°æœ€åï¼‰
                    positions.push(positions[0].clone());
                    
                    console.log('[Cesium JS Info] å››è¾¹å½¢ä½ç½®æ•°é‡:', positions.length);
                    
                    // æ·»åŠ è´´åœ°ç‰ˆæœ¬çš„å››è¾¹å½¢
                    const quadEntity = cesiumViewer.entities.add({
                        name: 'CornerQuadrilateral',
                        polyline: {
                            positions: positions,
                            width: 5, // å¢åŠ çº¿å®½ä½¿å…¶æ›´æ˜æ˜¾
                            material: Cesium.Color.CYAN.withAlpha(0.9), // å¢åŠ ä¸é€æ˜åº¦
                            clampToGround: true, // ä½¿ç”¨è´´åœ°
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                            arcType: Cesium.ArcType.GEODESIC // ä½¿ç”¨æµ‹åœ°çº¿
                        }
                    });
                    
                    // æ·»åŠ ä¸è´´åœ°ç‰ˆæœ¬çš„å››è¾¹å½¢ä½œä¸ºå¤‡ç”¨
                    const quadEntity2 = cesiumViewer.entities.add({
                        name: 'CornerQuadrilateral_NoClamp',
                        polyline: {
                            positions: positions,
                            width: 3,
                            material: Cesium.Color.YELLOW.withAlpha(0.7),
                            clampToGround: false,
                            heightReference: Cesium.HeightReference.NONE
                        }
                    });
                    
                    if (!window.cornerVisualizationEntities) {
                        window.cornerVisualizationEntities = [];
                    }
                    window.cornerVisualizationEntities.push(quadEntity);
                    window.cornerVisualizationEntities.push(quadEntity2);
                    console.log('[Cesium JS Info] å·²æ·»åŠ å››è¾¹å½¢å®ä½“ï¼ˆè´´åœ°å’Œä¸è´´åœ°ç‰ˆæœ¬ï¼‰');
                    
                    // 3. åœ¨Three.jsä¸­ç»˜åˆ¶è§†é”¥ä½“å°„çº¿ï¼ˆä»ç›¸æœºåˆ°å››ä¸ªè§’ç‚¹ï¼‰
                    // ä¼˜å…ˆä½¿ç”¨å…¨å±€threeSceneï¼Œå› ä¸ºè§’ç‚¹åæ ‡æ˜¯åœ¨å…¨å±€åæ ‡ç³»ä¸­
                    if (threeScene) {
                        console.log('[Cesium JS Info] ä½¿ç”¨å…¨å±€threeSceneç»˜åˆ¶å°„çº¿');
                        visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, threeScene);
                    } else {
                        // å¦‚æœæ²¡æœ‰å…¨å±€sceneï¼Œå°è¯•ä½¿ç”¨layerçš„scene
                        let layerScene = null;
                        for (let layer of gaussianSplatLayers) {
                            if (layer.splatViewer && layer.ready && layer.scene) {
                                layerScene = layer.scene;
                                break;
                            }
                        }
                        if (layerScene) {
                            console.log('[Cesium JS Info] ä½¿ç”¨layer sceneç»˜åˆ¶å°„çº¿');
                            visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, layerScene);
                        } else {
                            console.warn('[Cesium JS Warning] æ— æ³•æ‰¾åˆ°å¯ç”¨çš„Three.js scene');
                        }
                    }
                    
                    console.log('[Cesium JS Info] å·²å¯è§†åŒ–å››ä¸ªè§’ç‚¹ã€å››è¾¹å½¢å’Œè§†é”¥ä½“å°„çº¿');
                } else {
                    console.warn('[Cesium JS Warning] æœ‰æ•ˆçš„è§’ç‚¹æ•°é‡ä¸è¶³ï¼Œæ— æ³•ç»˜åˆ¶å››è¾¹å½¢');
                }
                
            } catch (error) {
                console.error('[Cesium JS Error] å¯è§†åŒ–è§’ç‚¹å’Œå°„çº¿å¤±è´¥:', error);
            }
        }
        
        // åœ¨Three.jsä¸­ç»˜åˆ¶è§†é”¥ä½“å°„çº¿
        function visualizeRaysInThreeJS(cornerPoints3DThree, threeCamera, scene) {
            try {
                if (!scene || !threeCamera) {
                    console.warn('[Cesium JS Warning] Three.jsåœºæ™¯æˆ–ç›¸æœºæœªåˆå§‹åŒ–ï¼Œæ— æ³•ç»˜åˆ¶å°„çº¿');
                    return;
                }
                
                console.log('[Cesium JS Info] å¼€å§‹ç»˜åˆ¶è§†é”¥ä½“å°„çº¿ï¼Œsceneç±»å‹:', scene.constructor.name);
                
                // æ¸…é™¤ä¹‹å‰çš„å°„çº¿
                if (window.rayLines) {
                    window.rayLines.forEach(line => {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                }
                window.rayLines = [];
                
                // è·å–ç›¸æœºä½ç½®ï¼ˆä¸–ç•Œåæ ‡ï¼‰
                const cameraPosition = new THREE.Vector3();
                threeCamera.getWorldPosition(cameraPosition);
                console.log('[Cesium JS Info] ç›¸æœºä½ç½®:', cameraPosition.x.toFixed(2), cameraPosition.y.toFixed(2), cameraPosition.z.toFixed(2));
                
                // ä¸ºæ¯ä¸ªè§’ç‚¹åˆ›å»ºå°„çº¿ï¼ˆç»¿è‰²ï¼Œè¡¨ç¤ºè§†é”¥ä½“ï¼‰
                cornerPoints3DThree.forEach((cornerPoint, idx) => {
                    console.log(`[Cesium JS Info] ç»˜åˆ¶å°„çº¿${idx + 1}: ä»ç›¸æœº(${cameraPosition.x.toFixed(2)}, ${cameraPosition.y.toFixed(2)}, ${cameraPosition.z.toFixed(2)}) åˆ°è§’ç‚¹(${cornerPoint.x.toFixed(2)}, ${cornerPoint.y.toFixed(2)}, ${cornerPoint.z.toFixed(2)})`);
                    
                    // åˆ›å»ºä»ç›¸æœºåˆ°è§’ç‚¹çš„çº¿æ®µ
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        cameraPosition,
                        cornerPoint
                    ]);
                    
                    // ä½¿ç”¨ç»¿è‰²æè´¨ï¼ˆè§†é”¥ä½“å°„çº¿ï¼‰
                    const material = new THREE.LineBasicMaterial({
                        color: 0x00ff00, // ç»¿è‰²
                        linewidth: 3, // å¢åŠ çº¿å®½
                        transparent: true,
                        opacity: 0.9 // å¢åŠ ä¸é€æ˜åº¦
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    window.rayLines.push(line);
                    console.log(`[Cesium JS Info] å·²æ·»åŠ å°„çº¿${idx + 1}åˆ°sceneï¼Œsceneå­å¯¹è±¡æ•°é‡:`, scene.children.length);
                });
                
                // ç»˜åˆ¶è§†é”¥ä½“çš„è¾¹ç•Œçº¿ï¼ˆè¿æ¥å››ä¸ªè§’ç‚¹å½¢æˆå››è¾¹å½¢ï¼Œåœ¨Three.jsä¸­ï¼‰
                if (cornerPoints3DThree.length === 4) {
                    // åˆ›å»ºå››è¾¹å½¢è¾¹æ¡†ï¼ˆåœ¨Three.jsä¸­ï¼Œä½¿ç”¨é’è‰²ï¼‰
                    const quadGeometry = new THREE.BufferGeometry().setFromPoints([
                        cornerPoints3DThree[0],
                        cornerPoints3DThree[1],
                        cornerPoints3DThree[2],
                        cornerPoints3DThree[3],
                        cornerPoints3DThree[0] // é—­åˆ
                    ]);
                    
                    const quadMaterial = new THREE.LineBasicMaterial({
                        color: 0x00ffff, // é’è‰²
                        linewidth: 3,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const quadLine = new THREE.Line(quadGeometry, quadMaterial);
                    scene.add(quadLine);
                    window.rayLines.push(quadLine);
                }
                
                console.log('[Cesium JS Info] å·²åœ¨Three.jsä¸­ç»˜åˆ¶è§†é”¥ä½“å°„çº¿');
                
            } catch (error) {
                console.error('[Cesium JS Error] åœ¨Three.jsä¸­ç»˜åˆ¶å°„çº¿å¤±è´¥:', error);
            }
        }
        
        // æ¸…é™¤è§’ç‚¹å¯è§†åŒ–
        function clearCornerPointsVisualization() {
            try {
                // æ¸…é™¤Cesiumå®ä½“
                if (window.cornerVisualizationEntities) {
                    window.cornerVisualizationEntities.forEach(entity => {
                        cesiumViewer.entities.remove(entity);
                    });
                    window.cornerVisualizationEntities = [];
                }
                
                // æ¸…é™¤Three.jså°„çº¿
                if (window.rayLines) {
                    window.rayLines.forEach(line => {
                        // å°è¯•ä»æ‰€æœ‰å¯èƒ½çš„sceneä¸­ç§»é™¤
                        if (threeScene) threeScene.remove(line);
                        // ä¹Ÿå°è¯•ä»layer scenesä¸­ç§»é™¤
                        for (let layer of gaussianSplatLayers) {
                            if (layer.scene) {
                                try {
                                    layer.scene.remove(line);
                                } catch (e) {
                                    // å¿½ç•¥é”™è¯¯
                                }
                            }
                        }
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                    window.rayLines = [];
                }
                
                // æ¸…é™¤ç‚¹æ ‡ç­¾ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (window.cornerPointLabels) {
                    window.cornerPointLabels.forEach(label => {
                        cesiumViewer.entities.remove(label);
                    });
                    window.cornerPointLabels = [];
                }
                
            } catch (error) {
                console.error('[Cesium JS Error] æ¸…é™¤å¯è§†åŒ–å¤±è´¥:', error);
            }
        }
        
        // è®¡ç®—è§’ç‚¹3Dåæ ‡ï¼ˆä½¿ç”¨å°„çº¿æ£€æµ‹ï¼Œå°†å››ä¸ªè§’ç‚¹çº¦æŸåˆ°XZå¹³é¢ä¸Šå®ç°è´´åœ°æ•ˆæœï¼‰
        function calculateCornerPoints3D(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const pixelPoints = data.pixelPoints || [];
                
                // è·å–ç¬¬ä¸€ä¸ªåŠ è½½çš„splat viewerå’Œmesh
                let splatViewer = null;
                let splatMesh = null;
                let threeCamera = null;
                let threeScene = null;
                
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        splatViewer = layer.splatViewer;
                        splatMesh = splatViewer.getSplatMesh();
                        threeCamera = splatViewer.camera;
                        threeScene = layer.scene;
                        if (splatMesh && threeCamera && threeScene) break;
                    }
                }
                
                if (!threeCamera) {
                    console.warn('[Cesium JS Warning] æœªæ‰¾åˆ°å¯ç”¨çš„THREE.jsç›¸æœºï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•');
                    calculateCornerPoints3DWithPlane(data);
                    return;
                }
                
                // è®¡ç®—åœ°é¢é«˜åº¦ï¼ˆXZå¹³é¢çš„Yåæ ‡ï¼‰
                // æ–¹æ³•1ï¼šå°è¯•ä»åœºæ™¯è¾¹ç•Œè·å–æœ€å°Yå€¼
                let groundY = 0.0;
                if (modelBoundingSphere && modelBoundingSphere.center && modelBoundingSphere.radius) {
                    // ä½¿ç”¨è¾¹ç•Œçƒä¸­å¿ƒYåæ ‡å‡å»åŠå¾„ä½œä¸ºåœ°é¢é«˜åº¦
                    groundY = modelBoundingSphere.center[1] - modelBoundingSphere.radius;
                    console.log('[Cesium JS Info] ä»è¾¹ç•Œçƒè®¡ç®—åœ°é¢é«˜åº¦:', groundY);
                } else if (splatMesh) {
                    // æ–¹æ³•2ï¼šä»meshçš„åŒ…å›´ç›’è·å–æœ€å°Yå€¼
                    try {
                        if (splatMesh.geometry && !splatMesh.geometry.boundingBox) {
                            splatMesh.geometry.computeBoundingBox();
                        }
                        if (splatMesh.geometry && splatMesh.geometry.boundingBox) {
                            const box = splatMesh.geometry.boundingBox;
                            const minWorld = new THREE.Vector3(box.min.x, box.min.y, box.min.z);
                            const maxWorld = new THREE.Vector3(box.max.x, box.max.y, box.max.z);
                            splatMesh.localToWorld(minWorld);
                            splatMesh.localToWorld(maxWorld);
                            groundY = Math.min(minWorld.y, maxWorld.y);
                            console.log('[Cesium JS Info] ä»meshåŒ…å›´ç›’è®¡ç®—åœ°é¢é«˜åº¦:', groundY);
                        }
                    } catch (e) {
                        console.warn('[Cesium JS Warning] æ— æ³•ä»meshè·å–åœ°é¢é«˜åº¦ï¼Œä½¿ç”¨é»˜è®¤å€¼0:', e);
                    }
                }
                
                // å¦‚æœgroundYä»ç„¶æ˜¯0ï¼Œå°è¯•ä½¿ç”¨ç¬¬ä¸€ä¸ªè§’ç‚¹çš„ä¸´æ—¶è®¡ç®—æ¥ä¼°ç®—
                // ä½†è¿™åªæ˜¯å¤‡ç”¨æ–¹æ¡ˆï¼Œä¸»è¦åº”è¯¥ä½¿ç”¨ä¸Šé¢çš„æ–¹æ³•
                if (groundY === 0.0 && pixelPoints.length > 0) {
                    console.warn('[Cesium JS Warning] åœ°é¢é«˜åº¦ä¸º0ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼ã€‚å»ºè®®æ£€æŸ¥åœºæ™¯è¾¹ç•Œè®¡ç®—ã€‚');
                }
                
                console.log('[Cesium JS Info] æœ€ç»ˆä½¿ç”¨åœ°é¢é«˜åº¦ï¼ˆYåæ ‡ï¼‰:', groundY);
                
                // åˆ›å»ºXZå¹³é¢ï¼ˆæ³•å‘é‡ä¸ºYè½´æ­£æ–¹å‘ï¼Œé€šè¿‡groundYç‚¹ï¼‰
                const planeNormal = new THREE.Vector3(0, 1, 0); // Yè½´æ­£æ–¹å‘
                const planePoint = new THREE.Vector3(0, groundY, 0);
                const xzPlane = new THREE.Plane(planeNormal, -groundY); // plane.d = -nÂ·point
                
                // åˆ›å»ºThree.jsçš„Raycasterç”¨äºè·å–å°„çº¿
                const threeRaycaster = new THREE.Raycaster();
                const cornerPoints3D = [];
                const cornerPoints3DThree = []; // å­˜å‚¨Three.jsåæ ‡ï¼Œç”¨äºåç»­è½¬æ¢
                
                // å¯¹æ¯ä¸ªè§’ç‚¹è¿›è¡Œå°„çº¿æ£€æµ‹
                for (let pixelPoint of pixelPoints) {
                    try {
                        // æ£€æŸ¥pixelPointæ˜¯å¦æœ‰æ•ˆ
                        if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                            console.warn('[Cesium JS Warning] æ— æ•ˆçš„è§’ç‚¹æ•°æ®ï¼Œè·³è¿‡:', pixelPoint);
                            cornerPoints3D.push({
                                longitude: 0.0,
                                latitude: 0.0,
                                height: 0.0
                            });
                            continue;
                        }
                        
                        // 1. å°†å±å¹•åæ ‡è½¬æ¢ä¸ºå½’ä¸€åŒ–è®¾å¤‡åæ ‡ï¼ˆNDCï¼‰
                        // Three.jsçš„Raycasteréœ€è¦NDCåæ ‡ï¼ŒèŒƒå›´æ˜¯[-1, 1]
                        const ndcX = (pixelPoint.x / imageWidth) * 2 - 1;
                        const ndcY = 1 - (pixelPoint.y / imageHeight) * 2; // Yè½´ç¿»è½¬
                        
                        // 2. ä½¿ç”¨Three.jsçš„Raycasterè®¾ç½®å°„çº¿
                        threeRaycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);
                        
                        // 3. è·å–å°„çº¿çš„èµ·ç‚¹å’Œæ–¹å‘
                        const ray = threeRaycaster.ray;
                        
                        // 4. è®¡ç®—å°„çº¿ä¸XZå¹³é¢çš„äº¤ç‚¹
                        const intersectionPoint = new THREE.Vector3();
                        const result = ray.intersectPlane(xzPlane, intersectionPoint);
                        
                        if (result) {
                            // æˆåŠŸè®¡ç®—åˆ°äº¤ç‚¹ï¼Œå­˜å‚¨åœ¨Three.jsåæ ‡ç³»ä¸­
                            cornerPoints3DThree.push(intersectionPoint.clone());
                            
                            // 5. å°†Three.jsä¸–ç•Œåæ ‡è½¬æ¢ä¸ºCesiumåæ ‡ï¼ˆå¯é€‰ï¼Œä¸»è¦ç”¨äºå…¼å®¹ï¼‰
                            // æ³¨æ„ï¼šThree.jsåæ ‡æ˜¯ä¸»è¦ç»“æœï¼ŒCesiumåæ ‡åªæ˜¯å¤‡ç”¨
                            
                            // å°è¯•å°†Three.jsåæ ‡è½¬æ¢ä¸ºCesium ECEFåæ ‡
                            // Three.jsåæ ‡å¯èƒ½å·²ç»æ˜¯ECEFåæ ‡ï¼Œæˆ–è€…éœ€è¦è½¬æ¢
                            try {
                                // å°†Three.jsåæ ‡è§†ä¸ºECEFåæ ‡ï¼ˆå¦‚æœåœºæ™¯ä½¿ç”¨ECEFåæ ‡ç³»ï¼‰
                                const ecefPoint = new Cesium.Cartesian3(
                                    intersectionPoint.x,
                                    intersectionPoint.y,
                                    intersectionPoint.z
                                );
                                
                                // è½¬æ¢ä¸ºåœ°ç†åæ ‡
                                const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                                
                                // æ£€æŸ¥åæ ‡æ˜¯å¦æœ‰æ•ˆï¼ˆç»çº¬åº¦åœ¨åˆç†èŒƒå›´å†…ï¼‰
                                if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude) &&
                                    cartographic.longitude >= -Math.PI && cartographic.longitude <= Math.PI &&
                                    cartographic.latitude >= -Math.PI/2 && cartographic.latitude <= Math.PI/2) {
                                    cornerPoints3D.push({
                                        longitude: cartographic.longitude,
                                        latitude: cartographic.latitude,
                                        height: cartographic.height
                                    });
                                } else {
                                    // å¦‚æœç›´æ¥è½¬æ¢å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨Cesiumç›¸æœºå°„çº¿
                                    const cesiumRay = cesiumViewer.camera.getPickRay(
                                        new Cesium.Cartesian2(pixelPoint.x, pixelPoint.y)
                                    );
                                    
                                    if (cesiumRay) {
                                        const cesiumIntersection = cesiumViewer.scene.globe.pick(cesiumRay, cesiumViewer.scene);
                                        if (cesiumIntersection) {
                                            const cartographic2 = Cesium.Cartographic.fromCartesian(cesiumIntersection);
                                            cornerPoints3D.push({
                                                longitude: cartographic2.longitude,
                                                latitude: cartographic2.latitude,
                                                height: cartographic2.height
                                            });
                                        } else {
                                            // ä½¿ç”¨æ¤­çƒé¢æ±‚äº¤
                                            const ellipsoid = cesiumViewer.scene.globe.ellipsoid;
                                            const intersectionResult = Cesium.IntersectionTests.rayEllipsoid(cesiumRay, ellipsoid);
                                            if (intersectionResult) {
                                                const intersectionPoint2 = intersectionResult.start;
                                                const cartographic3 = Cesium.Cartographic.fromCartesian(intersectionPoint2);
                                                cornerPoints3D.push({
                                                    longitude: cartographic3.longitude,
                                                    latitude: cartographic3.latitude,
                                                    height: 0.0
                                                });
                                            } else {
                                                // Cesiumåæ ‡è®¡ç®—å¤±è´¥ï¼Œä½†ä¸å½±å“Three.jsåæ ‡çš„ä½¿ç”¨
                                                // Three.jsåæ ‡æ˜¯ä¸»è¦ç»“æœï¼ŒCesiumåæ ‡åªæ˜¯å¤‡ç”¨
                                                cornerPoints3D.push({
                                                    longitude: 0.0,
                                                    latitude: 0.0,
                                                    height: 0.0
                                                });
                                            }
                                        }
                                    } else {
                                        cornerPoints3D.push({
                                            longitude: 0.0,
                                            latitude: 0.0,
                                            height: 0.0
                                        });
                                    }
                                }
                            } catch (e) {
                                // Three.jsåˆ°Cesiumåæ ‡è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼
                                // è¿™ä¸å½±å“Three.jsåæ ‡çš„ä½¿ç”¨ï¼ˆThree.jsåæ ‡æ˜¯ä¸»è¦ç»“æœï¼‰
                                cornerPoints3D.push({
                                    longitude: 0.0,
                                    latitude: 0.0,
                                    height: 0.0
                                });
                            }
                        } else {
                            // å°„çº¿ä¸å¹³é¢å¹³è¡Œæˆ–ä¸ç›¸äº¤
                            console.warn('[Cesium JS Warning] å°„çº¿ä¸XZå¹³é¢ä¸ç›¸äº¤ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                            cornerPoints3D.push({
                                longitude: 0.0,
                                latitude: 0.0,
                                height: 0.0
                            });
                        }
                    } catch (error) {
                        console.error('[Cesium JS Error] å¤„ç†è§’ç‚¹æ—¶å‡ºé”™:', error);
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                    }
                }
                
                // è¾“å‡ºThree.jsåæ ‡ç”¨äºè°ƒè¯•
                if (cornerPoints3DThree.length > 0) {
                    console.log('[Cesium JS Info] è®¡ç®—å¾—åˆ°çš„Three.jsåæ ‡ï¼ˆXZå¹³é¢ï¼‰:');
                    cornerPoints3DThree.forEach((pt, idx) => {
                        console.log(`  è§’ç‚¹${idx + 1}: (${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.z.toFixed(2)})`);
                    });
                    
                    // å¯è§†åŒ–è§’ç‚¹å’Œå°„çº¿
                    visualizeCornerPointsAndRays(cornerPoints3DThree, threeCamera, pixelPoints, imageWidth, imageHeight);
                }
                
                // å‘é€ç»“æœå›Pythonï¼ˆåŒ…å«Three.jsåæ ‡å’ŒCesiumåæ ‡ï¼‰
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cornerPoints3DCalculated',
                        data: {
                            cornerPoints: cornerPoints3D,
                            cornerPointsThree: cornerPoints3DThree.map(pt => ({
                                x: pt.x,
                                y: pt.y,
                                z: pt.z
                            }))
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] è®¡ç®—è§’ç‚¹3Dåæ ‡å¤±è´¥:', error);
                // å‡ºé”™æ—¶ä½¿ç”¨å¤‡ç”¨æ–¹æ³•
                calculateCornerPoints3DWithPlane(data);
            }
        }
        
        // è®¡ç®—åˆ†å‰²è½®å»“çš„3Dåæ ‡ï¼ˆå°†2Dè½®å»“ç‚¹çº¦æŸåˆ°XZå¹³é¢ä¸Šï¼‰
        function calculateContourPoints3D(data) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const contourPoints = data.contourPoints || []; // è½®å»“ç‚¹æ•°ç»„ï¼Œæ¯ä¸ªè½®å»“æ˜¯ä¸€ä¸ªç‚¹æ•°ç»„
                const contourId = data.contourId || 0; // è½®å»“IDï¼Œç”¨äºåŒºåˆ†ä¸åŒçš„åˆ†å‰²ç»“æœ
                
                if (!contourPoints || contourPoints.length === 0) {
                    console.warn('[Cesium JS Warning] æ²¡æœ‰è½®å»“ç‚¹æ•°æ®');
                    return;
                }
                
                // è·å–ç¬¬ä¸€ä¸ªåŠ è½½çš„splat viewerå’Œmesh
                let splatViewer = null;
                let splatMesh = null;
                let threeCamera = null;
                
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        splatViewer = layer.splatViewer;
                        splatMesh = splatViewer.getSplatMesh();
                        threeCamera = splatViewer.camera;
                        if (splatMesh && threeCamera) break;
                    }
                }
                
                if (!threeCamera) {
                    console.warn('[Cesium JS Warning] æœªæ‰¾åˆ°å¯ç”¨çš„THREE.jsç›¸æœº');
                    return;
                }
                
                // è®¡ç®—åœ°é¢é«˜åº¦ï¼ˆXZå¹³é¢çš„Yåæ ‡ï¼‰- ä½¿ç”¨å’Œè§’ç‚¹ç›¸åŒçš„æ–¹æ³•
                let groundY = 0.0;
                if (modelBoundingSphere && modelBoundingSphere.center && modelBoundingSphere.radius) {
                    groundY = modelBoundingSphere.center[1] - modelBoundingSphere.radius;
                } else if (splatMesh) {
                    try {
                        if (splatMesh.geometry && !splatMesh.geometry.boundingBox) {
                            splatMesh.geometry.computeBoundingBox();
                        }
                        if (splatMesh.geometry && splatMesh.geometry.boundingBox) {
                            const box = splatMesh.geometry.boundingBox;
                            const minWorld = new THREE.Vector3(box.min.x, box.min.y, box.min.z);
                            const maxWorld = new THREE.Vector3(box.max.x, box.max.y, box.max.z);
                            splatMesh.localToWorld(minWorld);
                            splatMesh.localToWorld(maxWorld);
                            groundY = Math.min(minWorld.y, maxWorld.y);
                        }
                    } catch (e) {
                        console.warn('[Cesium JS Warning] æ— æ³•ä»meshè·å–åœ°é¢é«˜åº¦ï¼Œä½¿ç”¨é»˜è®¤å€¼0:', e);
                    }
                }
                
                // åˆ›å»ºXZå¹³é¢
                const xzPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -groundY);
                
                // åˆ›å»ºThree.jsçš„Raycaster
                const threeRaycaster = new THREE.Raycaster();
                const allContourPoints3D = []; // å­˜å‚¨æ‰€æœ‰è½®å»“çš„3Dç‚¹
                
                // å¤„ç†æ¯ä¸ªè½®å»“
                contourPoints.forEach((contour, contourIdx) => {
                    if (!contour || contour.length < 3) {
                        console.warn(`[Cesium JS Warning] è½®å»“${contourIdx}ç‚¹æ•°ä¸è¶³ï¼Œè·³è¿‡`);
                        return;
                    }
                    
                    const contour3D = []; // å½“å‰è½®å»“çš„3Dç‚¹
                    
                    // å¯¹è½®å»“ä¸­çš„æ¯ä¸ªç‚¹è¿›è¡Œå°„çº¿æ£€æµ‹
                    contour.forEach((pixelPoint, pointIdx) => {
                        try {
                            if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                                return;
                            }
                            
                            // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºå½’ä¸€åŒ–è®¾å¤‡åæ ‡ï¼ˆNDCï¼‰
                            const ndcX = (pixelPoint.x / imageWidth) * 2 - 1;
                            const ndcY = 1 - (pixelPoint.y / imageHeight) * 2; // Yè½´ç¿»è½¬
                            
                            // ä½¿ç”¨Three.jsçš„Raycasterè®¾ç½®å°„çº¿
                            threeRaycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), threeCamera);
                            
                            // è·å–å°„çº¿
                            const ray = threeRaycaster.ray;
                            
                            // è®¡ç®—å°„çº¿ä¸XZå¹³é¢çš„äº¤ç‚¹
                            const intersectionPoint = new THREE.Vector3();
                            const result = ray.intersectPlane(xzPlane, intersectionPoint);
                            
                            if (result) {
                                contour3D.push(intersectionPoint.clone());
                            }
                        } catch (error) {
                            console.warn(`[Cesium JS Warning] å¤„ç†è½®å»“${contourIdx}çš„ç‚¹${pointIdx}æ—¶å‡ºé”™:`, error);
                        }
                    });
                    
                    if (contour3D.length > 0) {
                        allContourPoints3D.push(contour3D);
                    }
                });
                
                console.log(`[Cesium JS Info] æˆåŠŸè½¬æ¢${allContourPoints3D.length}ä¸ªè½®å»“åˆ°3Dåæ ‡`);
                
                // å¯è§†åŒ–è½®å»“çº¿
                visualizeContours3D(allContourPoints3D, contourId);
                
                // å‘é€ç»“æœå›Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'contourPoints3DCalculated',
                        data: {
                            contourId: contourId,
                            contours3D: allContourPoints3D.map(contour => 
                                contour.map(pt => ({ x: pt.x, y: pt.y, z: pt.z }))
                            )
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] è®¡ç®—è½®å»“3Dåæ ‡å¤±è´¥:', error);
            }
        }
        
        // å¯è§†åŒ–åˆ†å‰²è½®å»“çº¿ï¼ˆåœ¨3Dåœºæ™¯ä¸­ï¼‰
        function visualizeContours3D(contours3D, contourId) {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                // æ¸…é™¤ä¹‹å‰çš„è½®å»“å¯è§†åŒ–
                clearContourVisualization(contourId);
                
                // ä¸ºæ¯ä¸ªè½®å»“åˆ›å»ºå¯è§†åŒ–
                contours3D.forEach((contour, idx) => {
                    if (contour.length < 3) {
                        return;
                    }
                    
                    // å°†Three.jsåæ ‡è½¬æ¢ä¸ºCesiumåœ°ç†åæ ‡
                    const positions = [];
                    contour.forEach(pt => {
                        try {
                            const ecefPoint = new Cesium.Cartesian3(pt.x, pt.y, pt.z);
                            const cartographic = Cesium.Cartographic.fromCartesian(ecefPoint);
                            
                            if (isFinite(cartographic.longitude) && isFinite(cartographic.latitude)) {
                                positions.push(Cesium.Cartesian3.fromRadians(
                                    cartographic.longitude,
                                    cartographic.latitude,
                                    cartographic.height
                                ));
                            }
                        } catch (e) {
                            // å¿½ç•¥è½¬æ¢å¤±è´¥çš„ç‚¹
                        }
                    });
                    
                    // é—­åˆè½®å»“ï¼ˆæ·»åŠ ç¬¬ä¸€ä¸ªç‚¹åˆ°æœ€åï¼‰
                    if (positions.length > 0) {
                        positions.push(positions[0].clone());
                        
                        // åœ¨Cesiumä¸­ç»˜åˆ¶è½®å»“çº¿
                        const contourEntity = cesiumViewer.entities.add({
                            name: `Contour_${contourId}_${idx}`,
                            polyline: {
                                positions: positions,
                                width: 3,
                                material: Cesium.Color.MAGENTA.withAlpha(0.8), // ä½¿ç”¨æ´‹çº¢è‰²åŒºåˆ†è½®å»“
                                clampToGround: true,
                                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                                arcType: Cesium.ArcType.GEODESIC
                            }
                        });
                        
                        if (!window.contourVisualizationEntities) {
                            window.contourVisualizationEntities = {};
                        }
                        if (!window.contourVisualizationEntities[contourId]) {
                            window.contourVisualizationEntities[contourId] = [];
                        }
                        window.contourVisualizationEntities[contourId].push(contourEntity);
                    }
                });
                
                // åœ¨Three.jsä¸­ä¹Ÿç»˜åˆ¶è½®å»“çº¿ï¼ˆç”¨äºæ›´ç²¾ç¡®çš„æ˜¾ç¤ºï¼‰
                visualizeContoursInThreeJS(contours3D, contourId);
                
                console.log(`[Cesium JS Info] å·²å¯è§†åŒ–${contours3D.length}ä¸ªè½®å»“`);
            } catch (error) {
                console.error('[Cesium JS Error] å¯è§†åŒ–è½®å»“å¤±è´¥:', error);
            }
        }
        
        // åœ¨Three.jsä¸­ç»˜åˆ¶è½®å»“çº¿
        function visualizeContoursInThreeJS(contours3D, contourId) {
            try {
                // è·å–scene
                let scene = threeScene;
                if (!scene) {
                    for (let layer of gaussianSplatLayers) {
                        if (layer.splatViewer && layer.ready && layer.scene) {
                            scene = layer.scene;
                            break;
                        }
                    }
                }
                
                if (!scene) {
                    console.warn('[Cesium JS Warning] æ— æ³•æ‰¾åˆ°å¯ç”¨çš„Three.js scene');
                    return;
                }
                
                // æ¸…é™¤ä¹‹å‰çš„è½®å»“çº¿
                if (window.contourLines && window.contourLines[contourId]) {
                    window.contourLines[contourId].forEach(line => {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                }
                
                if (!window.contourLines) {
                    window.contourLines = {};
                }
                window.contourLines[contourId] = [];
                
                // ä¸ºæ¯ä¸ªè½®å»“åˆ›å»ºçº¿æ¡
                contours3D.forEach((contour, idx) => {
                    if (contour.length < 3) {
                        return;
                    }
                    
                    // é—­åˆè½®å»“
                    const closedContour = [...contour, contour[0]];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(closedContour);
                    const material = new THREE.LineBasicMaterial({
                        color: 0xff00ff, // æ´‹çº¢è‰²
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    window.contourLines[contourId].push(line);
                });
                
                console.log(`[Cesium JS Info] å·²åœ¨Three.jsä¸­ç»˜åˆ¶${contours3D.length}ä¸ªè½®å»“`);
            } catch (error) {
                console.error('[Cesium JS Error] åœ¨Three.jsä¸­ç»˜åˆ¶è½®å»“å¤±è´¥:', error);
            }
        }
        
        // æ¸…é™¤è½®å»“å¯è§†åŒ–
        function clearContourVisualization(contourId) {
            try {
                // æ¸…é™¤Cesiumå®ä½“
                if (window.contourVisualizationEntities && window.contourVisualizationEntities[contourId]) {
                    window.contourVisualizationEntities[contourId].forEach(entity => {
                        cesiumViewer.entities.remove(entity);
                    });
                    delete window.contourVisualizationEntities[contourId];
                }
                
                // æ¸…é™¤Three.jsçº¿æ¡
                if (window.contourLines && window.contourLines[contourId]) {
                    window.contourLines[contourId].forEach(line => {
                        // å°è¯•ä»æ‰€æœ‰å¯èƒ½çš„sceneä¸­ç§»é™¤
                        if (threeScene) threeScene.remove(line);
                        for (let layer of gaussianSplatLayers) {
                            if (layer.scene) {
                                try {
                                    layer.scene.remove(line);
                                } catch (e) {}
                            }
                        }
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    });
                    delete window.contourLines[contourId];
                }
            } catch (error) {
                console.error('[Cesium JS Error] æ¸…é™¤è½®å»“å¯è§†åŒ–å¤±è´¥:', error);
            }
        }
        
        // ä½¿ç”¨å°„çº¿ä¸Cesiumåœ°çƒè¡¨é¢æ±‚äº¤çš„æ–¹æ³•ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼Œä¹Ÿå®ç°è´´åœ°æ•ˆæœï¼‰
        function calculateCornerPoints3DWithPlane(data) {
            try {
                const imageWidth = data.imageWidth || cesiumViewer.scene.canvas.width;
                const imageHeight = data.imageHeight || cesiumViewer.scene.canvas.height;
                const pixelPoints = data.pixelPoints || [];
                
                const cornerPoints3D = [];
                
                // ç›´æ¥ä½¿ç”¨Cesiumç›¸æœºä¸åœ°çƒè¡¨é¢æ±‚äº¤ï¼ˆè´´åœ°æ•ˆæœï¼‰
                for (let pixelPoint of pixelPoints) {
                    // æ£€æŸ¥pixelPointæ˜¯å¦æœ‰æ•ˆ
                    if (!pixelPoint || typeof pixelPoint.x === 'undefined' || typeof pixelPoint.y === 'undefined') {
                        console.warn('[Cesium JS Warning] æ— æ•ˆçš„è§’ç‚¹æ•°æ®ï¼Œè·³è¿‡:', pixelPoint);
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                        continue;
                    }
                    
                    const ray = cesiumViewer.camera.getPickRay(new Cesium.Cartesian2(pixelPoint.x, pixelPoint.y));
                    if (ray) {
                        // ä¸åœ°çƒæ¤­çƒé¢æ±‚äº¤ï¼ˆè´´åœ°æ•ˆæœï¼‰
                        const intersection = cesiumViewer.scene.globe.pick(ray, cesiumViewer.scene);
                        if (intersection) {
                            const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                            cornerPoints3D.push({
                                longitude: cartographic.longitude,
                                latitude: cartographic.latitude,
                                height: cartographic.height
                            });
                        } else {
                            // å¦‚æœæ²¡æœ‰äº¤ç‚¹ï¼Œä½¿ç”¨æ¤­çƒé¢æ±‚äº¤ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰
                            const ellipsoid = cesiumViewer.scene.globe.ellipsoid;
                            const intersectionResult = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
                            if (intersectionResult) {
                                // intersectionResult åŒ…å« start å’Œ stop ä¸¤ä¸ªäº¤ç‚¹ï¼Œä½¿ç”¨è¾ƒè¿‘çš„ç‚¹ï¼ˆstartï¼‰
                                const intersectionPoint = intersectionResult.start;
                                const cartographic = Cesium.Cartographic.fromCartesian(intersectionPoint);
                                cornerPoints3D.push({
                                    longitude: cartographic.longitude,
                                    latitude: cartographic.latitude,
                                    height: 0.0  // æ¤­çƒé¢é«˜åº¦ä¸º0
                                });
                            } else {
                                cornerPoints3D.push({
                                    longitude: 0.0,
                                    latitude: 0.0,
                                    height: 0.0
                                });
                            }
                        }
                    } else {
                        cornerPoints3D.push({
                            longitude: 0.0,
                            latitude: 0.0,
                            height: 0.0
                        });
                    }
                }
                
                // å‘é€ç»“æœå›Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cornerPoints3DCalculated',
                        data: {
                            cornerPoints: cornerPoints3D
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] è®¡ç®—è§’ç‚¹3Dåæ ‡ï¼ˆå¹³é¢æ–¹æ³•ï¼‰å¤±è´¥:', error);
            }
        }
        
        // è·å–ç›¸æœºçŸ©é˜µ
        function getCameraMatrices() {
            try {
                if (!cesiumViewer || !cesiumViewer.scene) {
                    console.error('[Cesium JS Error] Cesium vieweræœªåˆå§‹åŒ–');
                    return;
                }
                
                // è·å–ç¬¬ä¸€ä¸ªsplat viewerçš„THREE.jsç›¸æœº
                let threeCamera = null;
                for (let layer of gaussianSplatLayers) {
                    if (layer.splatViewer && layer.ready) {
                        threeCamera = layer.splatViewer.camera;
                        if (threeCamera) break;
                    }
                }
                
                if (!threeCamera) {
                    console.error('[Cesium JS Error] æœªæ‰¾åˆ°THREE.jsç›¸æœº');
                    return;
                }
                
                // è·å–è§†å›¾çŸ©é˜µå’ŒæŠ•å½±çŸ©é˜µ
                const viewMatrix = threeCamera.matrixWorldInverse.clone();
                const projMatrix = threeCamera.projectionMatrix.clone();
                
                // è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼
                const viewArray = [];
                const projArray = [];
                
                for (let i = 0; i < 16; i++) {
                    viewArray.push(viewMatrix.elements[i]);
                    projArray.push(projMatrix.elements[i]);
                }
                
                // å‘é€ç»“æœå›Python
                if (pyBridge && pyBridge.receiveMessage) {
                    pyBridge.receiveMessage(JSON.stringify({
                        type: 'cameraMatricesReceived',
                        data: {
                            viewMatrix: viewArray,
                            projMatrix: projArray
                        }
                    }));
                }
            } catch (error) {
                console.error('[Cesium JS Error] è·å–ç›¸æœºçŸ©é˜µå¤±è´¥:', error);
            }
        }

        function flyToModel() {
            if (!cesiumViewer) {
                console.log('[Cesium JS Info] Cesium vieweræœªåˆå§‹åŒ–');
                return;
            }
            
            // å¦‚æœæœ‰è¾¹ç•Œçƒï¼Œä½¿ç”¨è¾¹ç•Œçƒ
            // å¢åŠ æ£€æŸ¥ï¼šä¸­å¿ƒç‚¹ä¸èƒ½å¤ªæ¥è¿‘(0,0,0)ï¼Œé‚£æ„å‘³ç€åœ¨åœ°å¿ƒ
            const center = modelBoundingSphere ? modelBoundingSphere.center : null;
            const distToCenter = center ? Math.sqrt(center[0]*center[0] + center[1]*center[1] + center[2]*center[2]) : 0;
            const isCenterValid = distToCenter > 1000000; // è‡³å°‘ç¦»åœ°å¿ƒ1000kmï¼ˆåœ°çƒåŠå¾„çº¦6371kmï¼‰

            if (modelBoundingSphere && center && isCenterValid) {
                console.log('[Cesium JS Info] ä½¿ç”¨è¾¹ç•Œçƒé£åˆ°æ¨¡å‹:', JSON.stringify(modelBoundingSphere));
                
                // æ£€æŸ¥åŠå¾„æ˜¯å¦å¼‚å¸¸å¤§ï¼ˆä¾‹å¦‚è¶…è¿‡100kmï¼‰ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é™åˆ¶åŠå¾„
                let radius = modelBoundingSphere.radius;
                if (radius > 100000) {
                    console.warn('[Cesium JS Warning] è¾¹ç•ŒçƒåŠå¾„è¿‡å¤§:', radius, 'é™åˆ¶ä¸º100m');
                    radius = 100;
                }
                // å¦‚æœåŠå¾„å¤ªå°ï¼ˆå°äº1mï¼‰ï¼Œä¹Ÿè°ƒæ•´ä¸€ä¸‹
                if (radius < 1) {
                    radius = 10;
                }

                const boundingSphere = new Cesium.BoundingSphere(
                    Cesium.Cartesian3.fromElements(center[0], center[1], center[2]),
                    radius
                );
                
                cesiumViewer.camera.flyToBoundingSphere(boundingSphere, {
                    duration: 2,
                    offset: new Cesium.HeadingPitchRange(0, -0.5, radius * 1.5)
                });
            } else if (gaussianSplatLayers.length > 0) {
                console.log('[Cesium JS Info] è¾¹ç•Œçƒæ— æ•ˆæˆ–æœªè®¡ç®—ï¼Œå›é€€åˆ°åœ°ç†ä½ç½®é£è¡Œ');
                // å¦‚æœæ²¡æœ‰è¾¹ç•Œçƒï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å‹çš„ä½ç½®
                const firstLayer = gaussianSplatLayers[0];
                if (firstLayer && firstLayer.geoLocation) {
                    console.log('[Cesium JS Info] ä½¿ç”¨æ¨¡å‹åœ°ç†ä½ç½®é£åˆ°æ¨¡å‹:', firstLayer.geoLocation);
                    const position = Cesium.Cartesian3.fromDegrees(
                        firstLayer.geoLocation.lon,
                        firstLayer.geoLocation.lat,
                        firstLayer.geoLocation.height + 100  // åœ¨æ¨¡å‹ä¸Šæ–¹100ç±³
                    );
                    
                    cesiumViewer.camera.flyTo({
                        destination: position,
                        orientation: {
                            heading: 0,
                            pitch: -Cesium.Math.PI_OVER_FOUR,
                            roll: 0
                        },
                        duration: 2
                    });
                }
            } else {
                console.log('[Cesium JS Info] æ²¡æœ‰æ¨¡å‹å¯é£è¡Œ');
            }
        }
        
        function toggleInfoPanel() {
            const content = document.getElementById('info-content');
            content.classList.toggle('collapsed');
        }
        
        function startInfoUpdate() {
            setInterval(updateInfo, 1000);
        }
        
        function updateInfo() {
            if (!cesiumViewer) return;
            
            // è·å–ç›¸æœºä½ç½®
            const cameraPosition = cesiumViewer.camera.position;
            const cartographic = Cesium.Cartographic.fromCartesian(cameraPosition);
            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
            const latitude = Cesium.Math.toDegrees(cartographic.latitude);
            const height = cartographic.height;
            
            // æ›´æ–°UI
            document.getElementById('cameraHeight').textContent = height.toFixed(1);
            document.getElementById('longitude').textContent = longitude.toFixed(6);
            document.getElementById('latitude').textContent = latitude.toFixed(6);
        }
        
        // åŠ è½½æœ¬åœ°æ–‡ä»¶
        function loadLocalFile() {
            const fileInput = document.getElementById('localFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                console.warn('[Cesium JS Warning] æœªé€‰æ‹©æ–‡ä»¶');
                return;
            }
            
            console.log('[Cesium JS Info] åŠ è½½æœ¬åœ°æ–‡ä»¶:', file.name);
            
            // åˆ›å»ºæ–‡ä»¶URL
            const fileUrl = URL.createObjectURL(file);
            
            // ç¡®å®šæ–‡ä»¶æ ¼å¼
            const fileName = file.name.toLowerCase();
            let format = null;
            if (fileName.endsWith('.splat')) {
                format = window.GaussianSplats3D.SceneFormat.Splat;
            } else if (fileName.endsWith('.ply')) {
                format = window.GaussianSplats3D.SceneFormat.Ply;
            } else if (fileName.endsWith('.ksplat')) {
                format = window.GaussianSplats3D.SceneFormat.KSplat;
            }
            
            // è·å–å½“å‰ç›¸æœºä¸­å¿ƒä½ç½®ä½œä¸ºé»˜è®¤åŠ è½½ä½ç½®
            let defaultLocation = {
                lon: 116.3974,
                lat: 39.9088,
                height: 0
            };

            if (cesiumViewer) {
                const center = cesiumViewer.camera.positionCartographic;
                defaultLocation = {
                    lon: Cesium.Math.toDegrees(center.longitude),
                    lat: Cesium.Math.toDegrees(center.latitude),
                    height: 0 // é»˜è®¤è´´åœ°
                };
            }
            
            // åŠ è½½æ¨¡å‹
            const modelData = {
                url: fileUrl,
                location: defaultLocation,
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1.0,
                modelId: `local_${Date.now()}`,
                format: format,
                flyTo: true
            };
            
            load3DGS(modelData);
            
            // æ¸…é™¤æ–‡ä»¶è¾“å…¥
            fileInput.value = '';
        }
        
        // æ›´æ–°æ¨¡å‹åˆ—è¡¨UI
        function updateModelListUI() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            modelList.innerHTML = '';
            
            if (gaussianSplatLayers.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'æ— æ¨¡å‹';
                modelList.appendChild(option);
                return;
            }
            
            // æ·»åŠ æ¯ä¸ªæ¨¡å‹
            gaussianSplatLayers.forEach(layer => {
                const option = document.createElement('option');
                option.value = layer.modelId;
                option.textContent = `${layer.modelId} ${layer.visible ? 'âœ“' : 'âœ—'}`;
                modelList.appendChild(option);
            });
        }
        
        // åˆ é™¤é€‰ä¸­çš„æ¨¡å‹
        function removeSelectedModel() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                console.warn('[Cesium JS Warning] æœªé€‰æ‹©æ¨¡å‹');
                return;
            }
            
            const modelId = selectedOption.value;
            removeModel({ modelId: modelId });
            updateModelListUI();
        }
        
        // åˆ‡æ¢æ¨¡å‹å¯è§æ€§
        function toggleModelVisibility() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                console.warn('[Cesium JS Warning] æœªé€‰æ‹©æ¨¡å‹');
                return;
            }
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (layer) {
                layer.visible = !layer.visible;
                if (layer.scene) {
                    layer.scene.visible = layer.visible;
                }
                updateModelListUI();
                console.log('[Cesium JS Info] æ¨¡å‹å¯è§æ€§å·²åˆ‡æ¢:', modelId, layer.visible);
            }
        }
        
        // é€‰ä¸­æ¨¡å‹æ—¶æ˜¾ç¤ºå±æ€§é¢æ¿
        function onModelSelected() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                // éšè—å±æ€§é¢æ¿
                document.getElementById('modelProperties').style.display = 'none';
                return;
            }
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (layer) {
                // æ˜¾ç¤ºå±æ€§é¢æ¿
                document.getElementById('modelProperties').style.display = 'block';
                
                // æ›´æ–°ä½ç½®è¾“å…¥æ¡†
                document.getElementById('propLon').value = layer.geoLocation.lon.toFixed(6);
                document.getElementById('propLat').value = layer.geoLocation.lat.toFixed(6);
                document.getElementById('propHeight').value = layer.geoLocation.height.toFixed(1);
                
                // æ›´æ–°æ—‹è½¬æ»‘å—
                document.getElementById('propRotX').value = layer.rotation.x;
                document.getElementById('propRotY').value = layer.rotation.y;
                document.getElementById('propRotZ').value = layer.rotation.z;
                document.getElementById('propRotXValue').textContent = layer.rotation.x.toFixed(2);
                document.getElementById('propRotYValue').textContent = layer.rotation.y.toFixed(2);
                document.getElementById('propRotZValue').textContent = layer.rotation.z.toFixed(2);
                
                // æ›´æ–°ç¼©æ”¾æ»‘å—
                document.getElementById('propScale').value = layer.scale;
                document.getElementById('propScaleValue').textContent = layer.scale.toFixed(2);
            }
        }
        
        // æ›´æ–°æ¨¡å‹å±æ€§
        function updateModelProperty(propertyType) {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer) return;
            
            if (propertyType === 'location') {
                // æ›´æ–°ä½ç½®
                const lon = parseFloat(document.getElementById('propLon').value);
                const lat = parseFloat(document.getElementById('propLat').value);
                const height = parseFloat(document.getElementById('propHeight').value);
                
                layer.geoLocation.lon = lon;
                layer.geoLocation.lat = lat;
                layer.geoLocation.height = height;
                
                // æ›´æ–°åœºæ™¯ä½ç½®
                const position = Cesium.Cartesian3.fromDegrees(lon, lat, height);
                if (layer.scene) {
                    layer.scene.position.set(position.x, position.y, position.z);
                }
                
                console.log('[Cesium JS Info] æ¨¡å‹ä½ç½®å·²æ›´æ–°:', modelId, {lon, lat, height});
            } else if (propertyType === 'rotation') {
                // æ›´æ–°æ—‹è½¬
                const rotX = parseFloat(document.getElementById('propRotX').value);
                const rotY = parseFloat(document.getElementById('propRotY').value);
                const rotZ = parseFloat(document.getElementById('propRotZ').value);
                
                layer.rotation.x = rotX;
                layer.rotation.y = rotY;
                layer.rotation.z = rotZ;
                
                // æ›´æ–°åœºæ™¯æ—‹è½¬
                if (layer.scene) {
                    layer.scene.rotation.set(rotX, rotY, rotZ);
                }
                
                // æ›´æ–°æ˜¾ç¤ºå€¼
                document.getElementById('propRotXValue').textContent = rotX.toFixed(2);
                document.getElementById('propRotYValue').textContent = rotY.toFixed(2);
                document.getElementById('propRotZValue').textContent = rotZ.toFixed(2);
                
                console.log('[Cesium JS Info] æ¨¡å‹æ—‹è½¬å·²æ›´æ–°:', modelId, {rotX, rotY, rotZ});
            } else if (propertyType === 'scale') {
                // æ›´æ–°ç¼©æ”¾
                const scale = parseFloat(document.getElementById('propScale').value);
                
                layer.scale = scale;
                
                // æ›´æ–°meshç¼©æ”¾
                const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
                if (mesh) {
                    mesh.scale.set(scale, scale, scale);
                }
                
                // æ›´æ–°æ˜¾ç¤ºå€¼
                document.getElementById('propScaleValue').textContent = scale.toFixed(2);
                
                console.log('[Cesium JS Info] æ¨¡å‹ç¼©æ”¾å·²æ›´æ–°:', modelId, scale);
            }
            
            // é‡æ–°è®¡ç®—è¾¹ç•Œçƒ
            layer._needsBoundsUpdate = true;
            calculateBoundingSphere();
        }
        
        // é‡ç½®æ¨¡å‹å˜æ¢
        function resetModelTransform() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer) return;
            
            // é‡ç½®æ—‹è½¬
            layer.rotation.x = 0;
            layer.rotation.y = 0;
            layer.rotation.z = 0;
            if (layer.scene) {
                layer.scene.rotation.set(0, 0, 0);
            }
            
            // é‡ç½®ç¼©æ”¾
            layer.scale = 1.0;
            const mesh = layer.splatViewer ? layer.splatViewer.getSplatMesh() : null;
            if (mesh) {
                mesh.scale.set(1, 1, 1);
            }
            
            // æ›´æ–°UI
            document.getElementById('propRotX').value = 0;
            document.getElementById('propRotY').value = 0;
            document.getElementById('propRotZ').value = 0;
            document.getElementById('propRotXValue').textContent = '0.00';
            document.getElementById('propRotYValue').textContent = '0.00';
            document.getElementById('propRotZValue').textContent = '0.00';
            document.getElementById('propScale').value = 1;
            document.getElementById('propScaleValue').textContent = '1.00';
            
            console.log('[Cesium JS Info] æ¨¡å‹å˜æ¢å·²é‡ç½®:', modelId);
            
            // é‡æ–°è®¡ç®—è¾¹ç•Œçƒ
            layer._needsBoundsUpdate = true;
            calculateBoundingSphere();
        }
        
        // é£åˆ°é€‰ä¸­çš„æ¨¡å‹
        function flyToSelectedModel() {
            const modelList = document.getElementById('modelList');
            if (!modelList) return;
            
            const selectedOption = modelList.options[modelList.selectedIndex];
            if (!selectedOption || !selectedOption.value) return;
            
            const modelId = selectedOption.value;
            const layer = gaussianSplatLayers.find(l => l.modelId === modelId);
            
            if (!layer || !layer.geoLocation) return;
            
            console.log('[Cesium JS Info] é£åˆ°é€‰ä¸­æ¨¡å‹:', modelId);
            
            // å°è¯•åŸºäºæ¨¡å‹åŒ…å›´çƒé£è¡Œ
            let boundingSphere = null;
            
            if (layer.splatViewer) {
                 const mesh = layer.splatViewer.getSplatMesh();
                 if (mesh) {
                     mesh.updateMatrixWorld(true);
                     if (mesh.geometry && !mesh.geometry.boundingBox) {
                         mesh.geometry.computeBoundingBox();
                     }
                     
                     let box = null;
                     if (mesh.geometry && mesh.geometry.boundingBox) {
                         box = mesh.geometry.boundingBox;
                     } else if (mesh.boundingBox) {
                         box = mesh.boundingBox;
                     }
                     
                     if (box) {
                         // è®¡ç®—åŒ…å›´ç›’çš„ä¸–ç•Œåæ ‡ä¸­å¿ƒå’ŒåŠå¾„
                         const corners = [
                             new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                             new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                         ];
                         
                         let minX = Infinity, minY = Infinity, minZ = Infinity;
                         let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                         
                         corners.forEach(c => {
                             // è¿™é‡Œåªå–æå€¼ç‚¹ç®€åŒ–è®¡ç®—ï¼Œå‡†ç¡®è®¡ç®—éœ€è¦8ä¸ªè§’
                             const corner = c.clone();
                             mesh.localToWorld(corner);
                             minX = Math.min(minX, corner.x); minY = Math.min(minY, corner.y); minZ = Math.min(minZ, corner.z);
                             maxX = Math.max(maxX, corner.x); maxY = Math.max(maxY, corner.y); maxZ = Math.max(maxZ, corner.z);
                         });
                         
                         const centerX = (minX + maxX) / 2;
                         const centerY = (minY + maxY) / 2;
                         const centerZ = (minZ + maxZ) / 2;
                         
                         // ä½¿ç”¨å¯¹è§’çº¿é•¿åº¦çš„ä¸€åŠä½œä¸ºåŠå¾„è¿‘ä¼¼
                         const radius = new THREE.Vector3(minX, minY, minZ).distanceTo(new THREE.Vector3(maxX, maxY, maxZ)) / 2;
                         
                         // æ£€æŸ¥ä¸­å¿ƒç‚¹æ˜¯å¦æœ‰æ•ˆï¼ˆé˜²æ­¢é£åˆ°åœ°å¿ƒï¼‰
                         if (Math.abs(centerX) > 1000 && Math.abs(centerY) > 1000) {
                             boundingSphere = new Cesium.BoundingSphere(
                                 new Cesium.Cartesian3(centerX, centerY, centerZ),
                                 radius
                             );
                         }
                     }
                 }
            }
            
            if (boundingSphere) {
                console.log('[Cesium JS Info] ä½¿ç”¨æ¨¡å‹åŒ…å›´çƒé£è¡Œ:', boundingSphere.radius);
                // é™åˆ¶åŠå¾„ï¼Œé˜²æ­¢è¿‡å¤§æˆ–è¿‡å°
                let r = boundingSphere.radius;
                if (r > 100000) r = 100;
                if (r < 1) r = 10;
                
                cesiumViewer.camera.flyToBoundingSphere(boundingSphere, {
                    duration: 1.5,
                    offset: new Cesium.HeadingPitchRange(0, -0.5, r * 1.5) // -0.5 rad çº¦ç­‰äº -28åº¦ï¼Œè§†è§’æ¯”è¾ƒè‡ªç„¶
                });
            } else {
                // å›é€€é€»è¾‘
                let offsetHeight = 50 * (layer.scale || 1.0); // é™ä½é»˜è®¤é«˜åº¦
                const position = Cesium.Cartesian3.fromDegrees(
                    layer.geoLocation.lon,
                    layer.geoLocation.lat,
                    layer.geoLocation.height + offsetHeight
                );
                
                cesiumViewer.camera.flyTo({
                    destination: position,
                    orientation: {
                        heading: 0,
                        pitch: -Cesium.Math.PI_OVER_FOUR,
                        roll: 0
                    },
                    duration: 1.5
                });
            }
        }
        
        // ä¿®æ”¹loadModelå‡½æ•°ä»¥æ”¯æŒformatå‚æ•°
        function loadModelWithFormat(data) {
            return loadModel(data);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            console.log('[Cesium JS Info] é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            
            // æ£€æŸ¥åº“æ˜¯å¦å·²åŠ è½½å’ŒDOMæ˜¯å¦å‡†å¤‡å¥½
            let checkCount = 0;
            const MAX_CHECK_COUNT = 100; // æœ€å¤šæ£€æŸ¥10ç§’
            
            function checkLibraries() {
                checkCount++;
                
                // æ£€æŸ¥DOMå…ƒç´ 
                const cesiumContainer = document.getElementById('cesiumContainer');
                if (!cesiumContainer) {
                    console.log('[Cesium JS Info] ç­‰å¾…DOMå…ƒç´ ...');
                    if (checkCount < MAX_CHECK_COUNT) {
                        setTimeout(checkLibraries, 100);
                    } else {
                        console.error('[Cesium JS Error] è¶…æ—¶ï¼šæ— æ³•æ‰¾åˆ°cesiumContainerå…ƒç´ ');
                    }
                    return;
                }
                
                // è¯¦ç»†æ£€æŸ¥åº“åŠ è½½çŠ¶æ€
                const cesiumLoaded = typeof Cesium !== 'undefined';
                const threeLoaded = typeof THREE !== 'undefined';
                
                if (!cesiumLoaded || !threeLoaded) {
                    // åªåœ¨ç¬¬ä¸€æ¬¡æˆ–æ¯10æ¬¡æ£€æŸ¥æ—¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯
                    if (checkCount === 1 || checkCount % 10 === 0) {
                        const status = {
                            Cesium: cesiumLoaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½',
                            THREE: threeLoaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½',
                            æ£€æŸ¥æ¬¡æ•°: checkCount
                        };
                        console.log('[Cesium JS Info] ç­‰å¾…åº“åŠ è½½... Cesium:', status.Cesium, 'THREE:', status.THREE, 'æ£€æŸ¥æ¬¡æ•°:', status.æ£€æŸ¥æ¬¡æ•°);
                    }
                    
                    if (checkCount < MAX_CHECK_COUNT) {
                        setTimeout(checkLibraries, 100);
                    } else {
                        console.error('[Cesium JS Error] è¶…æ—¶ï¼šåº“åŠ è½½å¤±è´¥ - Cesium:', cesiumLoaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½', 
                                    'THREE:', threeLoaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½', 
                                    'å»ºè®®: è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ–‡ä»¶è·¯å¾„');
                    }
                    return;
                }
                
                // åº“å·²åŠ è½½ï¼Œç›´æ¥åˆå§‹åŒ–ï¼ˆä¸ç­‰å¾…å®¹å™¨å°ºå¯¸ï¼‰
                // åœ¨Qt WebEngineä¸­ï¼Œæœªæ¿€æ´»çš„æ ‡ç­¾é¡µå®¹å™¨å°ºå¯¸å¯èƒ½ä¸º0ï¼Œä½†Cesiumå¯ä»¥åˆå§‹åŒ–
                // å½“æ ‡ç­¾é¡µè¢«æ¿€æ´»æ—¶ï¼Œå®¹å™¨ä¼šæœ‰å°ºå¯¸ï¼ŒCesiumä¼šè‡ªåŠ¨è°ƒæ•´
                console.log('[Cesium JS Info] æ‰€æœ‰åº“å·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–Cesium Viewer...', 
                           'å®¹å™¨å°ºå¯¸:', cesiumContainer.offsetWidth, 'x', cesiumContainer.offsetHeight);
                window.initCesiumViewer();
            }
            
            // å¯åŠ¨åˆå§‹åŒ–è¿‡ç¨‹
            setTimeout(checkLibraries, 100);
        };
        
        // å¦‚æœDOMå·²ç»å‡†å¤‡å¥½ï¼ˆåœ¨GUIä¸­å¯èƒ½å·²ç»åŠ è½½ï¼‰
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(function() {
                if (!isInitialized && !isInitializing) {
                    console.log('[Cesium JS Info] DOMå·²å‡†å¤‡å¥½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
                    window.onload();
                }
            }, 100);
        }
        // å…³é—­æ¨¡å‹å±æ€§é¢æ¿
        function closeModelProperties() {
            document.getElementById('modelProperties').style.display = 'none';
            // å¯é€‰ï¼šå–æ¶ˆé€‰æ‹©åˆ—è¡¨ä¸­çš„é€‰ä¸­çŠ¶æ€
            const modelList = document.getElementById('modelList');
            if (modelList) modelList.value = "";
        }

    </script>
</body>
</html>
