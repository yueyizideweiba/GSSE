<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GSSE Three.js 3DGSÁºñËæëÂô®</title>
    
    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js" 
            onerror="loadLocalThree();"></script>
    
    <script>
        function loadLocalThree() {
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                script.src = './lib/threejs/three.min.js';
                document.head.appendChild(script);
            }
        }
    </script>
    
    <!-- Gaussian Splats 3D -->
    <script>
        function loadGaussianSplats3D() {
            if (typeof THREE === 'undefined') {
                setTimeout(loadGaussianSplats3D, 100);
                return;
            }
            
            const script = document.createElement('script');
            script.src = './lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs';
            script.onload = function() {
                const GaussianSplats3D = window["Gaussian Splats 3D"] || window.GaussianSplats3D;
                if (GaussianSplats3D && typeof GaussianSplats3D.Viewer !== 'undefined') {
                    window.GaussianSplats3D = GaussianSplats3D;
                    console.log('[ThreeJS Info] GaussianSplats3DÂ∫ìÂ∑≤Âä†ËΩΩ');
                    console.log('[ThreeJS Info] GaussianSplats3DÁâàÊú¨:', GaussianSplats3D.version || 'Êú™Áü•');
                    console.log('[ThreeJS Info] GaussianSplats3D.ViewerÂèØÁî®:', typeof GaussianSplats3D.Viewer);
                }
            };
            document.head.appendChild(script);
        }
        loadGaussianSplats3D();
    </script>

    <style>
        :root {
            --bg-primary: #121218;
            --bg-secondary: #1e1e2e;
            --bg-tertiary: #2a2a3e;
            --bg-hover: #3d3d5c;
            --accent-color: #8b5cf6;
            --accent-hover: #a78bfa;
            --accent-light: rgba(139, 92, 246, 0.15);
            --text-primary: #e8e8f0;
            --text-secondary: #9898b0;
            --border-color: #3d3d5c;
            --success-color: #22c55e;
            --warning-color: #eab308;
            --danger-color: #ef4444;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-primary);
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* Â∑¶‰æßÂú∫ÊôØÁÆ°ÁêÜÂô®Èù¢Êùø */
        #scene-manager-panel {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 320px;
            z-index: 1000;
            background: var(--bg-secondary);
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            overflow: hidden;
            max-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }
        
        .panel-header:hover {
            background: var(--bg-hover);
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 15px;
        }
        
        .panel-title-icon {
            width: 22px;
            height: 22px;
            background: var(--accent-color);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .panel-actions {
            display: flex;
            gap: 6px;
        }
        
        .panel-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }
        
        .panel-action-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        /* Ê®°ÂûãÂàóË°®È°π */
        .model-item {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            margin-bottom: 6px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }
        
        .model-item:hover {
            background: var(--bg-hover);
        }
        
        .model-item.selected {
            border-color: var(--accent-color);
            background: var(--accent-light);
        }
        
        .model-item-icon {
            width: 36px;
            height: 36px;
            margin-right: 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .model-item-info {
            flex: 1;
            min-width: 0;
        }
        
        .model-item-name {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .model-item-type {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        
        .model-item-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .model-item:hover .model-item-actions {
            opacity: 1;
        }
        
        .model-action-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s;
        }
        
        .model-action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .model-action-btn.hidden-state {
            color: var(--text-secondary);
            opacity: 0.5;
        }
        
        .model-action-btn.delete:hover {
            background: var(--danger-color);
            color: white;
        }
        
        /* ÂèòÊç¢Èù¢Êùø */
        .transform-section {
            margin-top: 12px;
            padding: 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .transform-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-color);
        }
        
        .transform-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .transform-label {
            width: 50px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .transform-inputs {
            display: flex;
            gap: 6px;
            flex: 1;
        }
        
        .transform-input-group {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .transform-axis-label {
            width: 18px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }
        
        .transform-axis-label.x { color: #f87171; }
        .transform-axis-label.y { color: #4ade80; }
        .transform-axis-label.z { color: #60a5fa; }
        
        .transform-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            text-align: right;
        }
        
        .transform-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-light);
        }
        
        /* Âè≥‰æßÂ∑•ÂÖ∑Ê†è */
        #right-toolbar {
            position: absolute;
            top: 50%;
            right: 14px;
            transform: translateY(-50%);
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }
        
        .toolbar-divider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
        }
        
        .tool-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .tool-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .tool-btn.active {
            background: var(--accent-color);
            color: white;
        }
        
        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tool-btn[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            right: 54px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1001;
            box-shadow: 0 2px 12px rgba(0,0,0,0.4);
            border: 1px solid var(--border-color);
        }

        /* Â∫ïÈÉ®Â∑•ÂÖ∑Ê†è */
        #bottom-toolbar {
            position: absolute;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px 16px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }
        
        .bottom-tool-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .bottom-divider {
            width: 1px;
            height: 32px;
            background: var(--border-color);
            margin: 0 6px;
        }
        
        .bottom-btn {
            width: 38px;
            height: 38px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }
        
        .bottom-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .bottom-btn.active {
            background: var(--accent-color);
            color: white;
        }
        
        .bottom-btn[data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 52px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1001;
            border: 1px solid var(--border-color);
        }
        
        /* Âè≥‰∏äËßí3DÂùêÊ†áËΩ¥ÊåáÁ§∫Âô® */
        #axis-indicator {
            position: absolute;
            top: 14px;
            right: 80px;
            width: 100px;
            height: 100px;
            z-index: 1000;
            pointer-events: none;
        }
        
        #axis-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Â∫ïÈÉ®Áä∂ÊÄÅÊ†è */
        #status-bar {
            position: absolute;
            bottom: 14px;
            right: 14px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px 16px;
            border-radius: 8px;
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-value {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* Âä†ËΩΩÈÅÆÁΩ© */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 18, 24, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        #loading-overlay.hidden {
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--bg-tertiary);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading-text {
            color: var(--text-secondary);
            font-size: 15px;
        }
        
        /* ÈÄâÊã©Ê°ÜË¶ÜÁõñÂ±Ç */
        #selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }
        
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-color);
            background: var(--accent-light);
            pointer-events: none;
        }
        
        /* Á¨îÂà∑ÂÖâÊ†á */
        #brush-cursor {
            position: fixed;
            left: 0;
            top: 0;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 501;
            display: none;
            will-change: transform;
            background: var(--accent-light);
        }
        
        /* ÂèòÊç¢Ê®°ÂºèÊåáÁ§∫Âô® */
        #transform-mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 15px;
            color: var(--accent-color);
            display: none;
            z-index: 999;
            pointer-events: none;
            border: 1px solid var(--border-color);
            font-weight: 500;
        }
        
        #transform-mode-indicator.visible {
            display: block;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }
        
        /* Âø´Êç∑ÈîÆÈù¢Êùø */
        #shortcuts-panel {
            position: absolute;
            bottom: 70px;
            right: 14px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 10px;
            display: none;
            min-width: 220px;
            border: 1px solid var(--border-color);
        }
        
        #shortcuts-panel.visible {
            display: block;
        }
        
        .shortcuts-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 13px;
        }
        
        .shortcut-key {
            color: var(--accent-color);
            font-family: monospace;
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* Á©∫Áä∂ÊÄÅÊèêÁ§∫ */
        .empty-state {
            text-align: center;
            padding: 30px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 42px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .empty-state-text {
            font-size: 13px;
            line-height: 1.6;
        }
        
        /* Ê∏≤ÊüìÊ®°ÂºèÈÄâÊã©Âô® */
        .render-mode-select {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }
        
        .render-mode-select:hover {
            border-color: var(--accent-color);
        }
        
        .render-mode-select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-light);
        }
        
        /* ÁÇπ‰∫ëÂè†Âä†ÊéßÂà∂ */
        .overlay-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
        }
        
        .overlay-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-color);
            cursor: pointer;
        }
        
        .overlay-control label {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="loading-overlay" class="hidden">
        <div class="spinner"></div>
        <div id="loading-text">Âä†ËΩΩ‰∏≠...</div>
    </div>

    <!-- Â∑¶‰æßÂú∫ÊôØÁÆ°ÁêÜÂô®Èù¢Êùø -->
    <div id="scene-manager-panel">
        <div class="panel-header" onclick="togglePanel('scene-manager')">
            <div class="panel-title">
                <div class="panel-title-icon">üì¶</div>
                <span>Âú∫ÊôØÁÆ°ÁêÜÂô®</span>
            </div>
            <div class="panel-actions">
                <button class="panel-action-btn" onclick="event.stopPropagation(); addModelDialog()" title="Ê∑ªÂä†Ê®°Âûã">‚ûï</button>
                <button class="panel-action-btn" onclick="event.stopPropagation(); focusSelected()" title="ËÅöÁÑ¶ÈÄâ‰∏≠">üéØ</button>
            </div>
        </div>
        <div class="panel-content" id="scene-manager-content">
            <div id="model-list">
                <div class="empty-state">
                    <div class="empty-state-icon">üì≠</div>
                    <div class="empty-state-text">ÊöÇÊó†Ê®°Âûã<br>ÁÇπÂáª ‚ûï Ê∑ªÂä†Ê®°Âûã</div>
                </div>
            </div>
        </div>
        
        <!-- ÂèòÊç¢Èù¢Êùø -->
        <div class="transform-section" id="transform-panel" style="display: none;">
            <div class="transform-section-header">
                <span>‚ûï</span>
                <span>ÂèòÊç¢</span>
            </div>
            <div class="transform-row">
                <span class="transform-label">‰ΩçÁΩÆ</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <span class="transform-axis-label x">X</span>
                        <input type="number" class="transform-input" id="pos-x" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label y">Y</span>
                        <input type="number" class="transform-input" id="pos-y" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label z">Z</span>
                        <input type="number" class="transform-input" id="pos-z" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                </div>
            </div>
            <div class="transform-row">
                <span class="transform-label">ÊóãËΩ¨</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <span class="transform-axis-label x">X</span>
                        <input type="number" class="transform-input" id="rot-x" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label y">Y</span>
                        <input type="number" class="transform-input" id="rot-y" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label z">Z</span>
                        <input type="number" class="transform-input" id="rot-z" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                </div>
            </div>
            <div class="transform-row">
                <span class="transform-label">Áº©Êîæ</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <input type="number" class="transform-input" id="scale-uniform" step="0.1" value="1" min="0.01" onchange="updateTransformFromInput('scale')">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Âè≥‰æßÂ∑•ÂÖ∑Ê†è -->
    <div id="right-toolbar">
        <button class="tool-btn" id="tool-select" data-tooltip="ÈÄâÊã© (Q)" onclick="setTool('select')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
            </svg>
        </button>
        <button class="tool-btn active" id="tool-move-view" data-tooltip="ÁßªÂä®ËßÜËßí (V)" onclick="setTool('move')">üñêÔ∏è</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="tool-box" data-tooltip="Ê°ÜÈÄâ (B)" onclick="setTool('box')">‚¨ú</button>
        <button class="tool-btn" id="tool-lasso" data-tooltip="Â•óÁ¥¢ (L)" onclick="setTool('lasso')">„Ä∞Ô∏è</button>
        <button class="tool-btn" id="tool-brush" data-tooltip="Á¨îÂà∑ (P)" onclick="setTool('brush')">üñåÔ∏è</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="tool-translate" data-tooltip="ÁßªÂä® (G)" onclick="setTransformMode('translate')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20"/>
            </svg>
        </button>
        <button class="tool-btn" id="tool-rotate" data-tooltip="ÊóãËΩ¨ (R)" onclick="setTransformMode('rotate')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12a9 9 0 11-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                <path d="M21 3v5h-5"/>
            </svg>
        </button>
        <button class="tool-btn" id="tool-scale" data-tooltip="Áº©Êîæ (S)" onclick="setTransformMode('scale')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 21l-6-6m6 6v-4m0 4h-4M3 3l6 6M3 3v4m0-4h4"/>
            </svg>
        </button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="btn-deselect" data-tooltip="ÂèñÊ∂àÈÄâ‰∏≠ (Esc)" onclick="deselectAll()">‚úñÔ∏è</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" data-tooltip="ËÆæÁΩÆ" onclick="toggleShortcuts()">‚öôÔ∏è</button>
    </div>
    
    <!-- Â∫ïÈÉ®Â∑•ÂÖ∑Ê†è -->
    <div id="bottom-toolbar">
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="Êí§ÈîÄ" onclick="undo()">‚Ü©Ô∏è</button>
            <button class="bottom-btn" data-tooltip="ÈáçÂÅö" onclick="redo()">‚Ü™Ô∏è</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="ÂÖ®ÈÄâ" onclick="selectAll()">‚óªÔ∏è</button>
            <button class="bottom-btn" data-tooltip="ÂèçÈÄâ" onclick="selectInverse()">üîÑ</button>
            <button class="bottom-btn" data-tooltip="ÈöêËóèÈÄâ‰∏≠" onclick="hideSelected()">üëÅÔ∏è</button>
            <button class="bottom-btn" data-tooltip="ÊòæÁ§∫ÂÖ®ÈÉ®" onclick="showAll()">üëÄ</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" id="btn-grid" data-tooltip="ÁΩëÊ†º" onclick="toggleGrid()">‚ñ¶</button>
            <button class="bottom-btn" id="btn-axes" data-tooltip="ÂùêÊ†áËΩ¥" onclick="toggleAxes()">‚úõ</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <select class="render-mode-select" id="render-mode" onchange="setRenderMode(this.value)">
                <option value="splat">SplatÊ∏≤Êüì</option>
                <option value="points">ÁÇπ‰∫ëÊ∏≤Êüì</option>
                <option value="centers">‰∏≠ÂøÉÁÇπ</option>
            </select>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="overlay-control">
            <input type="checkbox" class="overlay-checkbox" id="pointcloud-overlay" onchange="togglePointCloudOverlay(this.checked)">
            <label for="pointcloud-overlay">Âè†Âä†ÁÇπ‰∫ë</label>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group" id="point-size-control" style="display: none;">
            <label style="font-size: 13px; color: var(--text-secondary); margin-right: 8px;">ÁÇπÂ§ßÂ∞è:</label>
            <input type="range" id="point-size-slider" min="0.5" max="10" step="0.5" value="3" 
                   style="width: 100px; accent-color: var(--accent-color);" 
                   oninput="updatePointSize(this.value)">
            <span id="point-size-value" style="font-size: 13px; color: var(--accent-color); margin-left: 8px; min-width: 30px;">3</span>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="Â§ç‰ΩçËßÜËßí" onclick="resetCamera()">üè†</button>
            <button class="bottom-btn danger" data-tooltip="Âà†Èô§ÈÄâ‰∏≠" onclick="deleteSelected()" style="color: var(--danger-color);">üóëÔ∏è</button>
        </div>
    </div>
    
    <!-- 3DÂùêÊ†áËΩ¥ÊåáÁ§∫Âô® -->
    <div id="axis-indicator">
        <canvas id="axis-canvas"></canvas>
    </div>
    
    <!-- Â∫ïÈÉ®Áä∂ÊÄÅÊ†è -->
    <div id="status-bar">
        <div class="status-item">
            <span>ÁÇπÊï∞:</span>
            <span class="status-value" id="pointCount">0</span>
        </div>
        <div class="status-item">
            <span>ÈÄâ‰∏≠:</span>
            <span class="status-value" id="selectedCount">0</span>
        </div>
        <div class="status-item">
            <span>FPS:</span>
            <span class="status-value" id="fps">0</span>
        </div>
    </div>
    
    <!-- ÈÄâÊã©Ê°ÜË¶ÜÁõñÂ±Ç -->
    <div id="selection-overlay"></div>
    
    <!-- Á¨îÂà∑ÂÖâÊ†á -->
    <div id="brush-cursor"></div>
    
    <!-- ÂèòÊç¢Ê®°ÂºèÊåáÁ§∫Âô® -->
    <div id="transform-mode-indicator"></div>
    
    <!-- Âø´Êç∑ÈîÆÈù¢Êùø -->
    <div id="shortcuts-panel">
        <div class="shortcuts-title">Âø´Êç∑ÈîÆ</div>
        <div class="shortcut-row"><span>Ê°ÜÈÄâ</span><span class="shortcut-key">B</span></div>
        <div class="shortcut-row"><span>Â•óÁ¥¢</span><span class="shortcut-key">L</span></div>
        <div class="shortcut-row"><span>Á¨îÂà∑</span><span class="shortcut-key">P</span></div>
        <div class="shortcut-row"><span>ÁßªÂä®ËßÜËßí</span><span class="shortcut-key">V</span></div>
        <div class="shortcut-row"><span>ÁßªÂä®Ê®°Âûã</span><span class="shortcut-key">G</span></div>
        <div class="shortcut-row"><span>ÊóãËΩ¨Ê®°Âûã</span><span class="shortcut-key">R</span></div>
        <div class="shortcut-row"><span>Áº©ÊîæÊ®°Âûã</span><span class="shortcut-key">S</span></div>
        <div class="shortcut-row"><span>ÂèñÊ∂àÈÄâ‰∏≠</span><span class="shortcut-key">Esc</span></div>
        <div class="shortcut-row"><span>ÂÖ®ÈÄâ</span><span class="shortcut-key">Ctrl+A</span></div>
        <div class="shortcut-row"><span>Âà†Èô§</span><span class="shortcut-key">Delete</span></div>
        <div class="shortcut-row"><span>Êí§ÈîÄ</span><span class="shortcut-key">Ctrl+Z</span></div>
    </div>

    <!-- Qt WebChannel -->
    <script>
        if (typeof qt !== 'undefined' && qt.webChannelTransport) {
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            document.head.appendChild(script);
        }
    </script>
""

    <script>
        // ==================== ÂÖ®Â±ÄÂèòÈáè ====================
        let scene = null;
        let camera = null;
        let renderer = null;
        let pyBridge = null;
        let isInitialized = false;
        
        // Âú∫ÊôØÁÆ°ÁêÜ
        const sceneModels = new Map(); // id -> { viewer, mesh, name, type, visible, position, rotation, scale }
        let selectedModelId = null;
        let modelIdCounter = 0;
        
        // ÁºñËæëÁä∂ÊÄÅ
        let currentTool = 'move';  // 'select', 'move', 'box', 'lasso', 'brush'
        let transformMode = null;  // 'translate', 'rotate', 'scale'
        let renderMode = 'splat';
        
        // ÈÄâÊã©Áä∂ÊÄÅ
        let selectedPointIndices = new Set();
        let hiddenPointIndices = new Set();
        let lockedPointIndices = new Set();
        
        // ÈÄâÊã©Êìç‰Ωú
        let isSelecting = false;
        let selectionStart = null;
        let selectionPath = [];
        let brushSize = 30;
        
        // Êí§ÈîÄ/ÈáçÂÅöÊ†à
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;
        
        // ËæÖÂä©ÂØπË±°
        let infiniteGrid = null;
        let axesHelper = null;
        let pointCloudMesh = null;
        let highlightMesh = null;
        let pointCloudOverlayMesh = null;
        let showPointCloudOverlay = false;
        let pointCloudSize = 3;  // ÁÇπ‰∫ëÂ§ßÂ∞è
        
        // TransformControls
        let transformControls = null;
        let transformHelper = null;
        
        // Áõ∏Êú∫ÊéßÂà∂
        let spherical = { radius: 15, phi: Math.PI / 4, theta: 0 };
        let target = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // ÂùêÊ†áËΩ¥ÊåáÁ§∫Âô®
        let axisScene = null;
        let axisCamera = null;
        let axisRenderer = null;
        
        // Ê∂àÊÅØÈòüÂàó
        const messageQueue = [];
        
        // ==================== ÂàùÂßãÂåñ ====================
        function init() {
            const container = document.getElementById('container');
            
            // ÂàõÂª∫Âú∫ÊôØ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121218);
            
            // ÂàõÂª∫Áõ∏Êú∫
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, 10);
            
            // ÂàõÂª∫Ê∏≤ÊüìÂô®
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // ÂàõÂª∫Êó†ÈôêÁΩëÊ†º
            createInfiniteGrid();
            
            // Ê∑ªÂä†ÂùêÊ†áËΩ¥
            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Ê∑ªÂä†ÁéØÂ¢ÉÂÖâ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Ê∑ªÂä†ÊñπÂêëÂÖâ
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // ÂàùÂßãÂåñTransformControls
            initTransformControls();
            
            // ÂàùÂßãÂåñÂùêÊ†áËΩ¥ÊåáÁ§∫Âô®
            initAxisIndicator();
            
            // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨
            setupEventListeners();
            
            // ÂàùÂßãÂåñWebChannel
            initWebChannel();
            
            // Êõ¥Êñ∞Áõ∏Êú∫‰ΩçÁΩÆ
            updateCameraPosition();
            
            // ÂºÄÂßãÊ∏≤ÊüìÂæ™ÁéØ
            animate();
            
            isInitialized = true;
            
            // Â§ÑÁêÜÈòüÂàó‰∏≠ÁöÑÊ∂àÊÅØ
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                window.receiveMessageFromPython(msg);
            }
            
            // ÈÄöÁü•PythonÂàùÂßãÂåñÂÆåÊàê
            sendToPython({ type: 'viewerReady' });
            
            // Á™óÂè£Â§ßÂ∞èË∞ÉÊï¥
            window.addEventListener('resize', onWindowResize);
            
            // ËÆæÁΩÆÈªòËÆ§Â∑•ÂÖ∑Áä∂ÊÄÅ
            setTool('move');
        }
        
        // ÂàõÂª∫Êó†ÈôêÁΩëÊ†ºÔºàÁ±ª‰ººSuperSplatÈ£éÊ†ºÔºâ
        function createInfiniteGrid() {
            const gridGroup = new THREE.Group();
            
            // Â∞èÁΩëÊ†ºÔºàÁªÜÁ∫øÔºâ
            const smallGridSize = 100;
            const smallGridDivisions = 100;
            const smallGrid = new THREE.GridHelper(smallGridSize, smallGridDivisions, 0x444466, 0x333344);
            smallGrid.material.opacity = 0.4;
            smallGrid.material.transparent = true;
            smallGrid.material.depthWrite = false;
            gridGroup.add(smallGrid);
            
            // Â§ßÁΩëÊ†ºÔºàÁ≤óÁ∫øÔºåÊØè10‰∏™Âçï‰ΩçÔºâ
            const largeGrid = new THREE.GridHelper(smallGridSize, smallGridDivisions / 10, 0x555577, 0x555577);
            largeGrid.material.opacity = 0.6;
            largeGrid.material.transparent = true;
            largeGrid.material.depthWrite = false;
            largeGrid.position.y = 0.001; // Á®çÂæÆÊä¨È´òÈÅøÂÖçz-fighting
            gridGroup.add(largeGrid);
            
            // XËΩ¥Á∫øÔºàÁ∫¢Ëâ≤Ôºâ
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-smallGridSize/2, 0, 0),
                new THREE.Vector3(smallGridSize/2, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 2, depthWrite: false });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            xAxis.position.y = 0.002;
            gridGroup.add(xAxis);
            
            // ZËΩ¥Á∫øÔºàËìùËâ≤Ôºâ
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -smallGridSize/2),
                new THREE.Vector3(0, 0, smallGridSize/2)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x4444ff, linewidth: 2, depthWrite: false });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            zAxis.position.y = 0.002;
            gridGroup.add(zAxis);
            
            infiniteGrid = gridGroup;
            scene.add(infiniteGrid);
        }
        
        // ÂèòÊç¢ÊéßÂà∂Âô®‰∫§‰∫íÁä∂ÊÄÅ
        let isTransforming = false;
        let transformAxis = null;
        let transformStartPoint = new THREE.Vector3();
        let transformStartValue = null;
        let transformRaycaster = new THREE.Raycaster();
        let transformPlane = new THREE.Plane();
        let transformStartMouse = new THREE.Vector2();
        let transformStartRotation = new THREE.Euler();
        
        // ÂèòÊç¢ÊéßÂà∂Âô®‰∏ìÁî®Âú∫ÊôØ
        let transformScene = null;
        
        // ÂàùÂßãÂåñTransformControlsÔºàËá™ÂÆö‰πâÂÆûÁé∞Ôºâ
        function initTransformControls() {
            // ÂàõÂª∫ÂèòÊç¢ÊéßÂà∂Âô®‰∏ìÁî®Âú∫ÊôØ
            transformScene = new THREE.Scene();
            
            // ÂàõÂª∫ÂèòÊç¢ËæÖÂä©Âô®ÁªÑ
            transformHelper = new THREE.Group();
            transformHelper.visible = false;
            transformHelper.renderOrder = 99999; // Á°Æ‰øùÂú®ÊúÄ‰∏äÂ±ÇÊ∏≤Êüì
            transformScene.add(transformHelper);
        }
        
        // ËÆæÁΩÆÊùêË¥®‰∏∫ÂßãÁªàÂú®ÊúÄ‰∏äÂ±Ç
        function setAlwaysOnTop(object) {
            object.traverse((child) => {
                if (child.material) {
                    // Á°Æ‰øùÊùêË¥®ÂßãÁªàÂú®ÊúÄ‰∏äÂ±ÇÊ∏≤Êüì
                    child.material.depthTest = false;
                    child.material.depthWrite = false;
                    child.material.transparent = true;
                    child.material.needsUpdate = true;
                    child.renderOrder = 99999;
                }
                child.renderOrder = 99999;
            });
            object.renderOrder = 99999;
        }
        
        // ÂàõÂª∫ÁßªÂä®ÊéßÂà∂Âô®
        function createTranslateHelper() {
            clearTransformHelper();
            
            const arrowLength = 2.5;
            const coneHeight = 0.4;
            const coneRadius = 0.12;
            const lineWidth = 0.04;
            
            // XËΩ¥ - Á∫¢Ëâ≤
            const xGroup = createTranslateAxis(0xff4444, 'x', new THREE.Vector3(1, 0, 0), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(xGroup);
            
            // YËΩ¥ - ÁªøËâ≤
            const yGroup = createTranslateAxis(0x44ff44, 'y', new THREE.Vector3(0, 1, 0), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(yGroup);
            
            // ZËΩ¥ - ËìùËâ≤
            const zGroup = createTranslateAxis(0x4488ff, 'z', new THREE.Vector3(0, 0, 1), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(zGroup);
            
            // Âπ≥Èù¢Ê≠£ÊñπÂΩ¢ÁöÑÂ§ßÂ∞èÂíåÂÅèÁßª
            const planeSize = 0.5;
            const planeOffset = 0.8;  // ‰ªé‰∏≠ÂøÉÂà∞Ê≠£ÊñπÂΩ¢‰∏≠ÂøÉÁöÑË∑ùÁ¶ª
            
            // XZÂπ≥Èù¢ÔºàÁ∫¢ËìùÂπ≥Èù¢Ôºâ- ÁªøËâ≤Ê≠£ÊñπÂΩ¢Ôºå‰Ωç‰∫éXÂíåZËΩ¥‰∫§ÁÇπÂ§Ñ
            const xzPlane = createTranslatePlane(0x44ff44, 'xz', planeSize);
            xzPlane.rotation.x = Math.PI / 2;
            xzPlane.position.set(planeOffset, 0, planeOffset);
            transformHelper.add(xzPlane);
            
            // XYÂπ≥Èù¢ÔºàÁ∫¢ÁªøÂπ≥Èù¢Ôºâ- ËìùËâ≤Ê≠£ÊñπÂΩ¢Ôºå‰Ωç‰∫éXÂíåYËΩ¥‰∫§ÁÇπÂ§Ñ
            const xyPlane = createTranslatePlane(0x4488ff, 'xy', planeSize);
            xyPlane.position.set(planeOffset, planeOffset, 0);
            transformHelper.add(xyPlane);
            
            // YZÂπ≥Èù¢ÔºàËìùÁªøÂπ≥Èù¢Ôºâ- Á∫¢Ëâ≤Ê≠£ÊñπÂΩ¢Ôºå‰Ωç‰∫éYÂíåZËΩ¥‰∫§ÁÇπÂ§Ñ
            const yzPlane = createTranslatePlane(0xff4444, 'yz', planeSize);
            yzPlane.rotation.y = Math.PI / 2;
            yzPlane.position.set(0, planeOffset, planeOffset);
            transformHelper.add(yzPlane);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createTranslateAxis(color, axis, direction, length, coneHeight, coneRadius, lineWidth) {
            const group = new THREE.Group();
            group.userData.axis = axis;
            group.userData.type = 'translate';
            
            // ÂúÜÊü±‰Ωì‰Ωú‰∏∫ËΩ¥Á∫ø
            const cylinderGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, length - coneHeight, 8);
            const cylinderMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.copy(direction.clone().multiplyScalar((length - coneHeight) / 2));
            
            // ÊóãËΩ¨ÂúÜÊü±‰Ωì‰ΩøÂÖ∂Ê≤øÁùÄÊ≠£Á°ÆÁöÑËΩ¥
            if (axis === 'x') cylinder.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cylinder.rotation.x = Math.PI / 2;
            
            group.add(cylinder);
            
            // ÂúÜÈî•‰Ωì‰Ωú‰∏∫ÁÆ≠Â§¥
            const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.copy(direction.clone().multiplyScalar(length - coneHeight / 2));
            
            if (axis === 'x') cone.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cone.rotation.x = Math.PI / 2;
            
            group.add(cone);
            
            return group;
        }
        
        function createTranslatePlane(color, axes, size) {
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.userData.axes = axes;
            plane.userData.type = 'translate';
            return plane;
        }
        
        // ÂàõÂª∫ÊóãËΩ¨ÊéßÂà∂Âô®
        function createRotateHelper() {
            clearTransformHelper();
            
            const radius = 2.0;
            const tubeRadius = 0.04;
            
            // XËΩ¥ÊóãËΩ¨ÁéØ - Á∫¢Ëâ≤
            const xRing = createRotationRing(0xff4444, 'x', radius, tubeRadius);
            xRing.rotation.y = Math.PI / 2;
            transformHelper.add(xRing);
            
            // YËΩ¥ÊóãËΩ¨ÁéØ - ÁªøËâ≤
            const yRing = createRotationRing(0x44ff44, 'y', radius, tubeRadius);
            yRing.rotation.x = Math.PI / 2;
            transformHelper.add(yRing);
            
            // ZËΩ¥ÊóãËΩ¨ÁéØ - ËìùËâ≤
            const zRing = createRotationRing(0x4488ff, 'z', radius, tubeRadius);
            transformHelper.add(zRing);
            
            // Â§ñÂúàÔºàÂ±èÂπïÁ©∫Èó¥ÊóãËΩ¨Ôºâ- ÁôΩËâ≤
            const outerRing = createRotationRing(0xaaaaaa, 'screen', radius * 1.15, tubeRadius * 0.8);
            transformHelper.add(outerRing);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createRotationRing(color, axis, radius, tubeRadius) {
            const geometry = new THREE.TorusGeometry(radius, tubeRadius, 8, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                depthTest: false,
                depthWrite: false
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.userData.axis = axis;
            ring.userData.type = 'rotate';
            return ring;
        }
        
        // ÂàõÂª∫Áº©ÊîæÊéßÂà∂Âô®
        function createScaleHelper() {
            clearTransformHelper();
            
            const lineLength = 2.0;
            const boxSize = 0.2;
            const lineWidth = 0.04;
            
            // XËΩ¥ - Á∫¢Ëâ≤
            const xLine = createScaleAxis(0xff4444, 'x', new THREE.Vector3(1, 0, 0), lineLength, boxSize, lineWidth);
            transformHelper.add(xLine);
            
            // YËΩ¥ - ÁªøËâ≤
            const yLine = createScaleAxis(0x44ff44, 'y', new THREE.Vector3(0, 1, 0), lineLength, boxSize, lineWidth);
            transformHelper.add(yLine);
            
            // ZËΩ¥ - ËìùËâ≤
            const zLine = createScaleAxis(0x4488ff, 'z', new THREE.Vector3(0, 0, 1), lineLength, boxSize, lineWidth);
            transformHelper.add(zLine);
            
            // ‰∏≠ÂøÉÁ´ãÊñπ‰ΩìÔºàÁªü‰∏ÄÁº©ÊîæÔºâ
            const centerGeometry = new THREE.BoxGeometry(boxSize * 1.5, boxSize * 1.5, boxSize * 1.5);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                depthTest: false,
                depthWrite: false
            });
            const centerBox = new THREE.Mesh(centerGeometry, centerMaterial);
            centerBox.userData.axis = 'uniform';
            centerBox.userData.type = 'scale';
            transformHelper.add(centerBox);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createScaleAxis(color, axis, direction, length, boxSize, lineWidth) {
            const group = new THREE.Group();
            group.userData.axis = axis;
            group.userData.type = 'scale';
            
            // ÂúÜÊü±‰Ωì‰Ωú‰∏∫ËΩ¥Á∫ø
            const cylinderGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, length - boxSize, 8);
            const cylinderMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.copy(direction.clone().multiplyScalar((length - boxSize) / 2));
            
            if (axis === 'x') cylinder.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cylinder.rotation.x = Math.PI / 2;
            
            group.add(cylinder);
            
            // Á´ãÊñπ‰Ωì‰Ωú‰∏∫Á´ØÁÇπ
            const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const boxMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.copy(direction.clone().multiplyScalar(length - boxSize / 2));
            group.add(box);
            
            return group;
        }
        
        function clearTransformHelper() {
            while (transformHelper.children.length > 0) {
                const child = transformHelper.children[0];
                transformHelper.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            transformHelper.visible = false;
            isTransforming = false;
            transformAxis = null;
        }
        
        // Êõ¥Êñ∞ÂèòÊç¢ÊéßÂà∂Âô®‰ΩçÁΩÆ
        function updateTransformHelperPosition() {
            if (!selectedModelId || !transformHelper.visible) return;
            
            const model = sceneModels.get(selectedModelId);
            if (model && model.mesh) {
                // ‰ΩøÁî®Ê®°ÂûãÁöÑÂÆûÈôÖ‰ΩçÁΩÆÔºàËÄå‰∏çÊòØËæπÁïåÊ°Ü‰∏≠ÂøÉÔºâ
                transformHelper.position.copy(model.mesh.position);
                
                // ÂêåÊ≠•Ê®°ÂûãÁöÑÊóãËΩ¨Âà∞ÊéßÂà∂Âô®
                transformHelper.rotation.copy(model.mesh.rotation);
                
                // Ê†πÊçÆÁõ∏Êú∫Ë∑ùÁ¶ªË∞ÉÊï¥ÊéßÂà∂Âô®Â§ßÂ∞è
                const distance = camera.position.distanceTo(model.mesh.position);
                const scale = distance * 0.15;
                transformHelper.scale.setScalar(Math.max(0.5, Math.min(scale, 3)));
            }
        }
        
        // Ê£ÄÊµãÂèòÊç¢ÊéßÂà∂Âô®ÁöÑÁÇπÂáª
        function checkTransformHelperIntersection(mouseX, mouseY) {
            if (!transformHelper.visible || !selectedModelId) return null;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((mouseX - rect.left) / rect.width) * 2 - 1,
                -((mouseY - rect.top) / rect.height) * 2 + 1
            );
            
            transformRaycaster.setFromCamera(mouse, camera);
            
            const intersects = transformRaycaster.intersectObjects(transformHelper.children, true);
            
            if (intersects.length > 0) {
                // ÊâæÂà∞Â∏¶ÊúâaxisÊàñaxesÂ±ûÊÄßÁöÑÂØπË±°
                let obj = intersects[0].object;
                while (obj && !obj.userData.axis && !obj.userData.axes && obj.parent !== transformHelper) {
                    obj = obj.parent;
                }
                if (obj && (obj.userData.axis || obj.userData.axes)) {
                    return { axis: obj.userData.axis, axes: obj.userData.axes, point: intersects[0].point };
                }
            }
            return null;
        }
        
        // ÂºÄÂßãÂèòÊç¢
        function startTransform(axis, axes, point, mouseX, mouseY) {
            if (!selectedModelId) return;
            
            isTransforming = true;
            transformAxis = axis || axes;
            transformStartPoint.copy(point);
            
            const model = sceneModels.get(selectedModelId);
            if (model) {
                if (transformMode === 'translate') {
                    transformStartValue = { x: model.position.x, y: model.position.y, z: model.position.z };
                } else if (transformMode === 'rotate') {
                    transformStartValue = { x: model.rotation.x, y: model.rotation.y, z: model.rotation.z };
                    transformStartRotation.copy(model.mesh.rotation);
                    
                    // ‰øùÂ≠òËµ∑ÂßãÈº†Ê†á‰ΩçÁΩÆÔºàÁî®‰∫étrackballÊóãËΩ¨Ôºâ
                    const rect = renderer.domElement.getBoundingClientRect();
                    transformStartMouse.set(
                        ((mouseX - rect.left) / rect.width) * 2 - 1,
                        -((mouseY - rect.top) / rect.height) * 2 + 1
                    );
                } else if (transformMode === 'scale') {
                    transformStartValue = model.scale;
                }
            }
            
            // ËÆæÁΩÆÂèòÊç¢Âπ≥Èù¢
            const normal = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            if (transformMode === 'translate') {
                if (axis === 'x') {
                    // XËΩ¥ÁßªÂä®ÔºöÈÄâÊã©‰∏éÁõ∏Êú∫ËßÜÁ∫øÊúÄÂûÇÁõ¥ÁöÑÂπ≥Èù¢ÔºàYÊàñZÔºâ
                    normal.set(0, Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 0 : 1, 
                               Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 1 : 0);
                } else if (axis === 'y') {
                    // YËΩ¥ÁßªÂä®ÔºöÈÄâÊã©‰∏éÁõ∏Êú∫ËßÜÁ∫øÊúÄÂûÇÁõ¥ÁöÑÂπ≥Èù¢ÔºàXÊàñZÔºâ
                    normal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 0 : 1, 0,
                               Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 1 : 0);
                } else if (axis === 'z') {
                    // ZËΩ¥ÁßªÂä®ÔºöÈÄâÊã©‰∏éÁõ∏Êú∫ËßÜÁ∫øÊúÄÂûÇÁõ¥ÁöÑÂπ≥Èù¢ÔºàXÊàñYÔºâ
                    normal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 0 : 1,
                               Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 1 : 0, 0);
                } else if (axes === 'xy') {
                    // XYÂπ≥Èù¢ÔºàÁ∫¢ÁªøÂπ≥Èù¢Ôºâ- ËìùËâ≤Ê≠£ÊñπÂΩ¢
                    normal.set(0, 0, 1);
                } else if (axes === 'xz') {
                    // XZÂπ≥Èù¢ÔºàÁ∫¢ËìùÂπ≥Èù¢Ôºâ- ÁªøËâ≤Ê≠£ÊñπÂΩ¢
                    normal.set(0, 1, 0);
                } else if (axes === 'yz') {
                    // YZÂπ≥Èù¢ÔºàËìùÁªøÂπ≥Èù¢Ôºâ- Á∫¢Ëâ≤Ê≠£ÊñπÂΩ¢
                    normal.set(1, 0, 0);
                }
            } else if (transformMode === 'rotate') {
                // ÊóãËΩ¨Ê®°ÂºèÔºöÊ†πÊçÆËΩ¥ËÆæÁΩÆÂπ≥Èù¢
                if (axis === 'x') {
                    normal.set(1, 0, 0);
                } else if (axis === 'y') {
                    normal.set(0, 1, 0);
                } else if (axis === 'z') {
                    normal.set(0, 0, 1);
                } else if (axis === 'screen') {
                    // Ëá™Áî±ÊóãËΩ¨ÔºàtrackballÔºâÔºö‰ΩøÁî®Èù¢ÂêëÁõ∏Êú∫ÁöÑÂπ≥Èù¢
                    normal.copy(cameraDir);
                }
            } else {
                // ÂØπ‰∫éÁº©ÊîæÔºå‰ΩøÁî®Èù¢ÂêëÁõ∏Êú∫ÁöÑÂπ≥Èù¢
                normal.copy(cameraDir);
            }
            
            transformPlane.setFromNormalAndCoplanarPoint(normal, transformHelper.position);
            
            // Á¶ÅÁî®ËΩ®ÈÅìÊéßÂà∂
            renderer.domElement.style.cursor = 'grabbing';
        }
        
        // Êõ¥Êñ∞ÂèòÊç¢
        function updateTransform(mouseX, mouseY) {
            if (!isTransforming || !selectedModelId || !transformAxis) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((mouseX - rect.left) / rect.width) * 2 - 1,
                -((mouseY - rect.top) / rect.height) * 2 + 1
            );
            
            transformRaycaster.setFromCamera(mouse, camera);
            
            const intersectPoint = new THREE.Vector3();
            if (!transformRaycaster.ray.intersectPlane(transformPlane, intersectPoint)) return;
            
            const delta = intersectPoint.clone().sub(transformStartPoint);
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            if (transformMode === 'translate') {
                // ÁßªÂä®Ê®°ÂºèÔºöÊ†πÊçÆËΩ¥ÂêëÁ∫¶Êùüdelta
                if (transformAxis === 'x') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'y') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'z') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z + delta.z;
                } else if (transformAxis === 'xy') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'xz') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z + delta.z;
                } else if (transformAxis === 'yz') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z + delta.z;
                }
                model.mesh.position.set(model.position.x, model.position.y, model.position.z);
            } else if (transformMode === 'rotate') {
                if (transformAxis === 'screen') {
                    // Ëá™Áî±ÊóãËΩ¨ÔºàtrackballÊ®°ÂºèÔºâ
                    const currentMouse = new THREE.Vector2(
                        ((mouseX - rect.left) / rect.width) * 2 - 1,
                        -((mouseY - rect.top) / rect.height) * 2 + 1
                    );
                    
                    const deltaX = currentMouse.x - transformStartMouse.x;
                    const deltaY = currentMouse.y - transformStartMouse.y;
                    
                    // ËÆ°ÁÆóÊóãËΩ¨ËΩ¥ÔºàÂûÇÁõ¥‰∫éÈº†Ê†áÁßªÂä®ÊñπÂêëÔºâ
                    const rotationAxis = new THREE.Vector3(-deltaY, deltaX, 0).normalize();
                    const rotationAngle = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * Math.PI * 2;
                    
                    // Â∞ÜÊóãËΩ¨ËΩ¥ËΩ¨Êç¢Âà∞‰∏ñÁïåÁ©∫Èó¥
                    const cameraRotation = new THREE.Matrix4().extractRotation(camera.matrixWorld);
                    rotationAxis.applyMatrix4(cameraRotation);
                    
                    // Â∫îÁî®ÊóãËΩ¨
                    const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);
                    const startQuaternion = new THREE.Quaternion().setFromEuler(transformStartRotation);
                    const newQuaternion = quaternion.multiply(startQuaternion);
                    
                    model.mesh.quaternion.copy(newQuaternion);
                    model.rotation.x = model.mesh.rotation.x;
                    model.rotation.y = model.mesh.rotation.y;
                    model.rotation.z = model.mesh.rotation.z;
                } else {
                    // Á∫¶ÊùüÊóãËΩ¨ÔºàÁªïÂçï‰∏™ËΩ¥Ôºâ
                    // ËÆ°ÁÆóÈº†Ê†áÂú®ÊóãËΩ¨Âπ≥Èù¢‰∏äÁöÑÊäïÂΩ±
                    const currentPoint = new THREE.Vector3();
                    if (transformRaycaster.ray.intersectPlane(transformPlane, currentPoint)) {
                        // ËÆ°ÁÆó‰ªé‰∏≠ÂøÉÂà∞Ëµ∑ÂßãÁÇπÂíåÂΩìÂâçÁÇπÁöÑÂêëÈáè
                        const center = transformHelper.position;
                        const startVec = transformStartPoint.clone().sub(center).normalize();
                        const currentVec = currentPoint.clone().sub(center).normalize();
                        
                        // ËÆ°ÁÆóÊóãËΩ¨ËßíÂ∫¶
                        let angle = Math.acos(Math.max(-1, Math.min(1, startVec.dot(currentVec))));
                        
                        // Á°ÆÂÆöÊóãËΩ¨ÊñπÂêë
                        const axis = new THREE.Vector3();
                        if (transformAxis === 'x') axis.set(1, 0, 0);
                        else if (transformAxis === 'y') axis.set(0, 1, 0);
                        else if (transformAxis === 'z') axis.set(0, 0, 1);
                        
                        const cross = new THREE.Vector3().crossVectors(startVec, currentVec);
                        if (cross.dot(axis) < 0) angle = -angle;
                        
                        // Â∫îÁî®ÊóãËΩ¨
                        if (transformAxis === 'x') {
                            model.rotation.x = transformStartValue.x + angle;
                        } else if (transformAxis === 'y') {
                            model.rotation.y = transformStartValue.y + angle;
                        } else if (transformAxis === 'z') {
                            model.rotation.z = transformStartValue.z + angle;
                        }
                        
                        model.mesh.rotation.set(model.rotation.x, model.rotation.y, model.rotation.z);
                    }
                }
            } else if (transformMode === 'scale') {
                // Áº©ÊîæÊ®°ÂºèÔºö‰ΩøÁî®Ë∑ùÁ¶ªÂèòÂåñÊù•ËÆ°ÁÆóÁº©Êîæ
                const startDist = transformStartPoint.distanceTo(transformHelper.position);
                const currentDist = intersectPoint.distanceTo(transformHelper.position);
                const scaleFactor = startDist > 0.001 ? currentDist / startDist : 1;
                
                if (transformAxis === 'uniform' || transformAxis === 'x' || transformAxis === 'y' || transformAxis === 'z') {
                    model.scale = Math.max(0.01, transformStartValue * scaleFactor);
                    model.mesh.scale.setScalar(model.scale);
                }
            }
            
            updateTransformInputs();
            updateTransformHelperPosition();
        }
        
        // ÁªìÊùüÂèòÊç¢
        function endTransform() {
            if (isTransforming && selectedModelId) {
                const model = sceneModels.get(selectedModelId);
                if (model) {
                    sendToPython({
                        type: 'modelTransformed',
                        data: {
                            id: selectedModelId,
                            position: model.position,
                            rotation: model.rotation,
                            scale: model.scale
                        }
                    });
                }
            }
            isTransforming = false;
            transformAxis = null;
            
            // ÊÅ¢Â§çÂÖâÊ†á
            renderer.domElement.style.cursor = 'default';
        }

        // ÂàùÂßãÂåñÂùêÊ†áËΩ¥ÊåáÁ§∫Âô®
        function initAxisIndicator() {
            const canvas = document.getElementById('axis-canvas');
            
            axisScene = new THREE.Scene();
            axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            axisCamera.position.set(0, 0, 3);
            
            axisRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            axisRenderer.setSize(100, 100);
            axisRenderer.setClearColor(0x000000, 0);
            
            // ÂàõÂª∫ÂùêÊ†áËΩ¥
            const axisLength = 0.8;
            
            // XËΩ¥ - Á∫¢Ëâ≤
            const xAxis = createAxisArrow(0xff4444, new THREE.Vector3(axisLength, 0, 0), 'X');
            axisScene.add(xAxis);
            
            // YËΩ¥ - ÁªøËâ≤
            const yAxis = createAxisArrow(0x44ff44, new THREE.Vector3(0, axisLength, 0), 'Y');
            axisScene.add(yAxis);
            
            // ZËΩ¥ - ËìùËâ≤
            const zAxis = createAxisArrow(0x4488ff, new THREE.Vector3(0, 0, axisLength), 'Z');
            axisScene.add(zAxis);
        }
        
        function createAxisArrow(color, direction, label) {
            const group = new THREE.Group();
            
            // ËΩ¥Á∫ø
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                direction
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);
            
            // ÁÆ≠Â§¥
            const arrowGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: color });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.copy(direction);
            
            if (direction.x !== 0) arrow.rotation.z = -Math.PI / 2;
            else if (direction.z !== 0) arrow.rotation.x = Math.PI / 2;
            
            group.add(arrow);
            
            return group;
        }
        
        function updateAxisIndicator() {
            if (!axisCamera || !camera) return;
            
            const quaternion = camera.quaternion.clone();
            axisCamera.position.set(0, 0, 3);
            axisCamera.position.applyQuaternion(quaternion.invert());
            axisCamera.lookAt(0, 0, 0);
            
            axisRenderer.render(axisScene, axisCamera);
        }
    </script>

    <script>
        // ==================== Âú∫ÊôØÁÆ°ÁêÜÂô® ====================
        function addModel(url, name, type = 'splat') {
            const id = 'model_' + (++modelIdCounter);
            
            const modelData = {
                id: id,
                name: name || `Ê®°Âûã ${modelIdCounter}`,
                type: type,
                url: url,
                visible: true,
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1,
                viewer: null,
                mesh: null,
                pointCount: 0
            };
            
            sceneModels.set(id, modelData);
            updateModelList();
            
            return id;
        }
        
        function loadModelToScene(id, url) {
            const modelData = sceneModels.get(id);
            if (!modelData) return;
            
            showLoading('Ê≠£Âú®Âä†ËΩΩÊ®°Âûã...');
            
            // Âä†ËΩΩ3DGSÊ®°Âûã
            if (typeof GaussianSplats3D !== 'undefined') {
                const splatConfig = {
                    selfDrivenMode: false,
                    renderer: renderer,
                    camera: camera,
                    useBuiltInControls: false,
                    ignoreDevicePixelRatio: true,
                    gpuAcceleratedSort: false,
                    sharedMemoryForWorkers: false,
                    enableSIMDInSort: false,
                    integerBasedSort: false,
                    halfPrecisionCovariancesOnGPU: false,
                    dynamicScene: false,
                    sceneRevealMode: GaussianSplats3D.SceneRevealMode ? GaussianSplats3D.SceneRevealMode.Instant : 0,
                    logLevel: GaussianSplats3D.LogLevel ? GaussianSplats3D.LogLevel.None : 0,
                    sphericalHarmonicsDegree: 0
                };
                
                const viewer = new GaussianSplats3D.Viewer(splatConfig);
                
                viewer.addSplatScene(url, {
                    splatAlphaRemovalThreshold: 1,
                    showLoadingUI: false,
                    position: [modelData.position.x, modelData.position.y, modelData.position.z],
                    rotation: [0, 0, 0, 1],
                    scale: [modelData.scale, modelData.scale, modelData.scale]
                }).then(() => {
                    modelData.viewer = viewer;
                    modelData.mesh = viewer.splatMesh;
                    
                    // Âª∂ËøüËé∑ÂèñÁÇπÊï∞ÔºåÁ°Æ‰øùÊ®°ÂûãÂÆåÂÖ®Âä†ËΩΩ
                    const tryGetSplatCount = () => {
                        if (viewer.getSplatCount) {
                            const count = viewer.getSplatCount();
                            if (count > 0) {
                                modelData.pointCount = count;
                                updateModelList();
                                updatePointCount();
                                console.log(`[ThreeJS Info] Ê®°Âûã ${modelData.name} ÁÇπÊï∞: ${count}`);
                                return;
                            }
                        }
                        // Â¶ÇÊûúÁÇπÊï∞‰∏∫0ÔºåÁ®çÂêéÈáçËØï
                        setTimeout(tryGetSplatCount, 100);
                    };
                    
                    // ÂÖàËÆæÁΩÆÂàùÂßãÂÄºÔºåÁÑ∂ÂêéÂ∞ùËØïËé∑ÂèñÁúüÂÆûÁÇπÊï∞
                    modelData.pointCount = viewer.getSplatCount ? viewer.getSplatCount() : 0;
                    setTimeout(tryGetSplatCount, 200);
                    
                    scene.add(viewer.splatMesh);
                    
                    hideLoading();
                    updateModelList();
                    updatePointCount();
                    
                    // Ëá™Âä®ÈÄâ‰∏≠Êñ∞Âä†ËΩΩÁöÑÊ®°Âûã
                    selectModel(id);
                    
                    sendToPython({
                        type: 'modelLoaded',
                        success: true,
                        data: { id: id, pointCount: modelData.pointCount }
                    });
                }).catch(error => {
                    console.error('[ThreeJS Error] Âä†ËΩΩÊ®°ÂûãÂ§±Ë¥•:', error);
                    hideLoading();
                    sceneModels.delete(id);
                    updateModelList();
                    
                    sendToPython({
                        type: 'modelLoaded',
                        success: false,
                        error: error.message
                    });
                });
            }
        }
        
        function selectModel(id) {
            selectedModelId = id;
            
            // Êõ¥Êñ∞UI
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            const modelItem = document.querySelector(`[data-model-id="${id}"]`);
            if (modelItem) {
                modelItem.classList.add('selected');
            }
            
            // ÊòæÁ§∫ÂèòÊç¢Èù¢Êùø
            const transformPanel = document.getElementById('transform-panel');
            if (id) {
                transformPanel.style.display = 'block';
                updateTransformInputs();
                
                // Â¶ÇÊûúÊúâÂèòÊç¢Ê®°ÂºèÔºåÊòæÁ§∫ÊéßÂà∂Âô®
                if (transformMode) {
                    updateTransformHelperPosition();
                }
            } else {
                transformPanel.style.display = 'none';
                clearTransformHelper();
            }
            
            sendToPython({
                type: 'modelSelected',
                data: { id: id }
            });
        }
        
        function deselectAll() {
            selectedModelId = null;
            selectedPointIndices.clear();
            
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            document.getElementById('transform-panel').style.display = 'none';
            clearTransformHelper();
            
            // Ê∏ÖÈô§È´ò‰∫Æ
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
            
            updateSelectionDisplay();
            
            sendToPython({ type: 'deselected' });
        }
        
        function toggleModelVisibility(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            model.visible = !model.visible;
            
            if (model.mesh) {
                model.mesh.visible = model.visible;
            }
            
            updateModelList();
        }
        
        function deleteModel(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            if (model.mesh) {
                scene.remove(model.mesh);
            }
            
            if (model.viewer && model.viewer.dispose) {
                model.viewer.dispose();
            }
            
            sceneModels.delete(id);
            
            if (selectedModelId === id) {
                deselectAll();
            }
            
            updateModelList();
            updatePointCount();
            
            sendToPython({
                type: 'modelDeleted',
                data: { id: id }
            });
        }
        
        function updateModelList() {
            const listContainer = document.getElementById('model-list');
            
            if (sceneModels.size === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <div class="empty-state-text">ÊöÇÊó†Ê®°Âûã<br>ÁÇπÂáª ‚ûï Ê∑ªÂä†Ê®°Âûã</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            sceneModels.forEach((model, id) => {
                const isSelected = id === selectedModelId;
                const visibilityIcon = model.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                const visibilityClass = model.visible ? '' : 'hidden-state';
                
                html += `
                    <div class="model-item ${isSelected ? 'selected' : ''}" data-model-id="${id}" onclick="selectModel('${id}')">
                        <div class="model-item-icon">üé®</div>
                        <div class="model-item-info">
                            <div class="model-item-name">${model.name}</div>
                        </div>
                        <div class="model-item-actions">
                            <button class="model-action-btn ${visibilityClass}" onclick="event.stopPropagation(); toggleModelVisibility('${id}')" title="ÊòæÁ§∫/ÈöêËóè">
                                ${visibilityIcon}
                            </button>
                            <button class="model-action-btn delete" onclick="event.stopPropagation(); confirmDeleteModel('${id}')" title="Âà†Èô§">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        function confirmDeleteModel(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Ê®°Âûã "${model.name}" ÂêóÔºü`)) {
                deleteModel(id);
            }
        }
        
        function addModelDialog() {
            sendToPython({ type: 'requestAddModel' });
        }
        
        function focusSelected() {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            const box = new THREE.Box3().setFromObject(model.mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            target.copy(center);
            spherical.radius = Math.max(size.x, size.y, size.z) * 2;
            
            updateCameraPosition();
        }
        
        function updateTransformInputs() {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model) return;
            
            document.getElementById('pos-x').value = model.position.x.toFixed(3);
            document.getElementById('pos-y').value = model.position.y.toFixed(3);
            document.getElementById('pos-z').value = model.position.z.toFixed(3);
            
            document.getElementById('rot-x').value = (model.rotation.x * 180 / Math.PI).toFixed(2);
            document.getElementById('rot-y').value = (model.rotation.y * 180 / Math.PI).toFixed(2);
            document.getElementById('rot-z').value = (model.rotation.z * 180 / Math.PI).toFixed(2);
            
            document.getElementById('scale-uniform').value = model.scale.toFixed(3);
        }
        
        function updateTransformFromInput(type) {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            if (type === 'position') {
                model.position.x = parseFloat(document.getElementById('pos-x').value) || 0;
                model.position.y = parseFloat(document.getElementById('pos-y').value) || 0;
                model.position.z = parseFloat(document.getElementById('pos-z').value) || 0;
                
                model.mesh.position.set(model.position.x, model.position.y, model.position.z);
            } else if (type === 'rotation') {
                model.rotation.x = (parseFloat(document.getElementById('rot-x').value) || 0) * Math.PI / 180;
                model.rotation.y = (parseFloat(document.getElementById('rot-y').value) || 0) * Math.PI / 180;
                model.rotation.z = (parseFloat(document.getElementById('rot-z').value) || 0) * Math.PI / 180;
                
                model.mesh.rotation.set(model.rotation.x, model.rotation.y, model.rotation.z);
            } else if (type === 'scale') {
                model.scale = parseFloat(document.getElementById('scale-uniform').value) || 1;
                model.mesh.scale.setScalar(model.scale);
            }
            
            updateTransformHelperPosition();
            
            sendToPython({
                type: 'modelTransformed',
                data: {
                    id: selectedModelId,
                    position: model.position,
                    rotation: model.rotation,
                    scale: model.scale
                }
            });
        }
        
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }
        
        function togglePanel(panelId) {
            const content = document.getElementById(panelId + '-content');
            if (content) {
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            }
        }

        // ==================== ‰∫ã‰ª∂ÁõëÂê¨ ====================
        function setupEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }
        
        function onMouseDown(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // È¶ñÂÖàÊ£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫ÜÂèòÊç¢ÊéßÂà∂Âô®
            if (transformMode && transformHelper.visible && e.button === 0) {
                const hit = checkTransformHelperIntersection(e.clientX, e.clientY);
                if (hit) {
                    startTransform(hit.axis, hit.axes, hit.point, e.clientX, e.clientY);
                    return;
                }
            }
            
            if (currentTool === 'move' || e.button === 2 || e.button === 1) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else if (currentTool === 'box' || currentTool === 'lasso' || currentTool === 'brush') {
                if (e.button === 0) {
                    isSelecting = true;
                    selectionStart = { x, y };
                    selectionPath = [{ x, y }];
                    
                    if (currentTool === 'box') {
                        createSelectionBox(x, y, 0, 0);
                    }
                }
            }
        }
        
        let lastMouseMoveTime = 0;
        const MOUSE_MOVE_THROTTLE = 8;
        
        function onMouseMove(e) {
            const now = performance.now();
            
            if (now - lastMouseMoveTime < MOUSE_MOVE_THROTTLE && !isDragging && !isTransforming) {
                return;
            }
            lastMouseMoveTime = now;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Â§ÑÁêÜÂèòÊç¢ÊéßÂà∂Âô®ÊãñÊãΩ
            if (isTransforming) {
                updateTransform(e.clientX, e.clientY);
                return;
            }
            
            // Êõ¥Êñ∞Á¨îÂà∑ÂÖâÊ†á
            if (currentTool === 'brush') {
                const cursor = document.getElementById('brush-cursor');
                cursor.style.display = 'block';
                cursor.style.transform = `translate(${e.clientX - brushSize}px, ${e.clientY - brushSize}px)`;
                cursor.style.width = (brushSize * 2) + 'px';
                cursor.style.height = (brushSize * 2) + 'px';
            } else {
                document.getElementById('brush-cursor').style.display = 'none';
            }
            
            // È´ò‰∫ÆÂèòÊç¢ÊéßÂà∂Âô®
            if (transformMode && transformHelper.visible && !isDragging && !isSelecting) {
                const hit = checkTransformHelperIntersection(e.clientX, e.clientY);
                highlightTransformAxis(hit ? (hit.axis || hit.axes) : null);
            }
            
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (e.buttons === 2 || (e.buttons === 1 && currentTool === 'move')) {
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi + deltaY * 0.01));
                } else if (e.buttons === 4) {
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(up);
                    right.crossVectors(up, camera.up).normalize();
                    up.crossVectors(right, camera.getWorldDirection(new THREE.Vector3())).normalize();
                    
                    target.add(right.multiplyScalar(-deltaX * 0.01));
                    target.add(up.multiplyScalar(deltaY * 0.01));
                }
                
                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else if (isSelecting) {
                if (currentTool === 'box') {
                    const width = x - selectionStart.x;
                    const height = y - selectionStart.y;
                    updateSelectionBox(selectionStart.x, selectionStart.y, width, height);
                } else if (currentTool === 'lasso' || currentTool === 'brush') {
                    const lastPoint = selectionPath[selectionPath.length - 1];
                    const dist = Math.sqrt((x - lastPoint.x) ** 2 + (y - lastPoint.y) ** 2);
                    if (dist > 3) {
                        selectionPath.push({ x, y });
                        drawSelectionPath();
                    }
                }
            }
        }
        
        // È´ò‰∫ÆÂèòÊç¢ÊéßÂà∂Âô®ÁöÑËΩ¥
        let highlightedAxis = null;
        function highlightTransformAxis(axis) {
            if (highlightedAxis === axis) return;
            highlightedAxis = axis;
            
            transformHelper.traverse((child) => {
                if (child.material && (child.userData.axis || child.userData.axes)) {
                    const isHighlighted = child.userData.axis === axis || child.userData.axes === axis;
                    if (isHighlighted) {
                        child.material.opacity = 1.0;
                        if (child.material.emissive) {
                            child.material.emissive.setHex(0x333333);
                        }
                    } else {
                        child.material.opacity = child.userData.type === 'rotate' ? 0.9 : 
                                                  (child.userData.axes ? 0.4 : 0.9);
                    }
                }
            });
            
            // Êõ¥Êñ∞ÂÖâÊ†á
            if (axis) {
                renderer.domElement.style.cursor = 'grab';
            } else if (transformMode) {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseUp(e) {
            // ÁªìÊùüÂèòÊç¢
            if (isTransforming) {
                endTransform();
                return;
            }
            
            if (isDragging) {
                isDragging = false;
            }
            
            if (isSelecting) {
                isSelecting = false;
                
                const shiftKey = e.shiftKey;
                const ctrlKey = e.ctrlKey;
                
                if (currentTool === 'box') {
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    selectByBox(selectionStart.x, selectionStart.y, x, y, shiftKey, ctrlKey);
                } else if (currentTool === 'lasso') {
                    selectByLasso(selectionPath, shiftKey, ctrlKey);
                } else if (currentTool === 'brush') {
                    selectByBrush(selectionPath, brushSize, shiftKey, ctrlKey);
                }
                
                clearSelectionOverlay();
            }
        }
        
        function onMouseWheel(e) {
            e.preventDefault();
            spherical.radius *= e.deltaY > 0 ? 1.1 : 0.9;
            spherical.radius = Math.max(1, Math.min(100, spherical.radius));
            updateCameraPosition();
        }
        
        function onKeyDown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'a':
                        e.preventDefault();
                        selectAll();
                        break;
                    case 'i':
                        e.preventDefault();
                        selectInverse();
                        break;
                    case 'z':
                        e.preventDefault();
                        undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                }
            } else if (e.shiftKey) {
                switch (e.key.toLowerCase()) {
                    case 'h':
                        e.preventDefault();
                        showAll();
                        break;
                }
            } else {
                switch (e.key.toLowerCase()) {
                    case 'q':
                        setTool('select');
                        break;
                    case 'b':
                        setTool('box');
                        break;
                    case 'l':
                        setTool('lasso');
                        break;
                    case 'p':
                        setTool('brush');
                        break;
                    case 'v':
                        setTool('move');
                        break;
                    case 'h':
                        hideSelected();
                        break;
                    case 'g':
                        setTransformMode('translate');
                        break;
                    case 'r':
                        setTransformMode('rotate');
                        break;
                    case 's':
                        if (!e.ctrlKey) setTransformMode('scale');
                        break;
                    case 'delete':
                    case 'backspace':
                        deleteSelected();
                        break;
                    case 'escape':
                        deselectAll();
                        break;
                }
            }
        }
        
        function onKeyUp(e) {}
        
        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // ==================== Áõ∏Êú∫ÊéßÂà∂ ====================
        function updateCameraPosition() {
            camera.position.x = target.x + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            camera.position.y = target.y + spherical.radius * Math.cos(spherical.phi);
            camera.position.z = target.z + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.lookAt(target);
            
        }
        
        function resetCamera() {
            spherical = { radius: 15, phi: Math.PI / 4, theta: 0 };
            target = new THREE.Vector3(0, 0, 0);
            updateCameraPosition();
        }
        
        // ==================== Â∑•ÂÖ∑ÂàáÊç¢ ====================
        function setTool(tool) {
            currentTool = tool;
            
            // Ê∏ÖÈô§ÂèòÊç¢Ê®°Âºè
            if (tool !== 'select') {
                transformMode = null;
                clearTransformHelper();
            }
            
            // Êõ¥Êñ∞UI
            document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolMap = {
                'select': 'tool-select',
                'move': 'tool-move-view',
                'box': 'tool-box',
                'lasso': 'tool-lasso',
                'brush': 'tool-brush'
            };
            
            const toolBtn = document.getElementById(toolMap[tool]);
            if (toolBtn) toolBtn.classList.add('active');
            
            // Êõ¥Êñ∞ÂÖâÊ†á
            if (tool === 'move') {
                renderer.domElement.style.cursor = 'grab';
            } else if (tool === 'brush') {
                renderer.domElement.style.cursor = 'none';
            } else if (tool === 'select') {
                renderer.domElement.style.cursor = 'default';
            } else {
                renderer.domElement.style.cursor = 'crosshair';
            }
            
            if (tool !== 'brush') {
                document.getElementById('brush-cursor').style.display = 'none';
            }
        }
        
        function setTransformMode(mode) {
            if (!selectedModelId) {
                showTransformModeIndicator('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã');
                return;
            }
            
            // ÂàáÊç¢Ê®°Âºè
            if (transformMode === mode) {
                transformMode = null;
                clearTransformHelper();
                
                document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                    if (btn.id.startsWith('tool-translate') || btn.id.startsWith('tool-rotate') || btn.id.startsWith('tool-scale')) {
                        btn.classList.remove('active');
                    }
                });
                return;
            }
            
            transformMode = mode;
            
            // Êõ¥Êñ∞UI
            document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                if (btn.id.startsWith('tool-translate') || btn.id.startsWith('tool-rotate') || btn.id.startsWith('tool-scale')) {
                    btn.classList.remove('active');
                }
            });
            
            const modeBtn = document.getElementById('tool-' + mode);
            if (modeBtn) modeBtn.classList.add('active');
            
            // ÂàõÂª∫ÂØπÂ∫îÁöÑÊéßÂà∂Âô®
            if (mode === 'translate') {
                createTranslateHelper();
                showTransformModeIndicator('ÁßªÂä®Ê®°Âºè (G)');
            } else if (mode === 'rotate') {
                createRotateHelper();
                showTransformModeIndicator('ÊóãËΩ¨Ê®°Âºè (R)');
            } else if (mode === 'scale') {
                createScaleHelper();
                showTransformModeIndicator('Áº©ÊîæÊ®°Âºè (S)');
            }
            
            updateTransformHelperPosition();
            
            sendToPython({
                type: 'transformModeChanged',
                data: { mode: mode }
            });
        }
        
        function showTransformModeIndicator(text) {
            const indicator = document.getElementById('transform-mode-indicator');
            indicator.textContent = text;
            indicator.classList.remove('visible');
            void indicator.offsetWidth; // Ëß¶ÂèëÈáçÊéí
            indicator.classList.add('visible');
            
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 2000);
        }

        // ==================== Ê∏≤ÊüìÊ®°Âºè ====================
        function setRenderMode(mode) {
            renderMode = mode;
            
            sendToPython({
                type: 'renderModeChanged',
                data: { mode: mode }
            });
            
            updateRenderMode();
            
            // ÊòæÁ§∫/ÈöêËóèÁÇπ‰∫ëÂ§ßÂ∞èÊéßÂà∂
            const pointSizeControl = document.getElementById('point-size-control');
            if (pointSizeControl) {
                // ÂΩìÊúâÁÇπ‰∫ëÊòæÁ§∫Êó∂ÔºàÁÇπ‰∫ëÊ∏≤ÊüìÊ®°ÂºèÊàñÂè†Âä†ÁÇπ‰∫ëÔºâÊòæÁ§∫ÊéßÂà∂
                const hasPointCloud = (mode === 'points' || mode === 'centers' || 
                                      (mode === 'splat' && showPointCloudOverlay));
                pointSizeControl.style.display = hasPointCloud ? 'flex' : 'none';
            }
        }
        
        function updateRenderMode() {
            sceneModels.forEach((model, id) => {
                if (model.viewer && model.viewer.splatMesh) {
                    if (renderMode === 'splat') {
                        model.viewer.splatMesh.visible = model.visible;
                        if (pointCloudMesh) pointCloudMesh.visible = false;
                    } else {
                        model.viewer.splatMesh.visible = false;
                        if (pointCloudMesh) pointCloudMesh.visible = model.visible;
                    }
                }
            });
            
            // ÁÇπ‰∫ëÂè†Âä†
            if (pointCloudOverlayMesh) {
                pointCloudOverlayMesh.visible = showPointCloudOverlay && renderMode === 'splat';
            }
        }
        
        function togglePointCloudOverlay(checked) {
            showPointCloudOverlay = checked;
            
            if (checked && renderMode === 'splat') {
                // ËØ∑Ê±ÇPythonÁ´ØÂèëÈÄÅÁÇπ‰∫ëÊï∞ÊçÆÁî®‰∫éÂè†Âä†ÊòæÁ§∫
                sendToPython({
                    type: 'requestPointCloudOverlay',
                    data: {}
                });
            }
            
            if (pointCloudOverlayMesh) {
                pointCloudOverlayMesh.visible = checked && renderMode === 'splat';
            }
            
            // ÊòæÁ§∫/ÈöêËóèÁÇπ‰∫ëÂ§ßÂ∞èÊéßÂà∂
            const pointSizeControl = document.getElementById('point-size-control');
            if (pointSizeControl) {
                const hasPointCloud = (renderMode === 'points' || renderMode === 'centers' || 
                                      (renderMode === 'splat' && checked));
                pointSizeControl.style.display = hasPointCloud ? 'flex' : 'none';
            }
        }
        
        function updatePointSize(size) {
            pointCloudSize = parseFloat(size);
            
            // Êõ¥Êñ∞ÊòæÁ§∫ÁöÑÊï∞ÂÄº
            const valueDisplay = document.getElementById('point-size-value');
            if (valueDisplay) {
                valueDisplay.textContent = pointCloudSize.toFixed(1);
            }
            
            // Êõ¥Êñ∞ÁÇπ‰∫ëÊùêË¥®Â§ßÂ∞èÔºàÈùûÈÄèËßÜÁº©ÊîæÔºâ
            if (pointCloudMesh && pointCloudMesh.material) {
                pointCloudMesh.material.size = pointCloudSize;
                pointCloudMesh.material.needsUpdate = true;
            }
            
            // Êõ¥Êñ∞Âè†Âä†ÁÇπ‰∫ëÊùêË¥®Â§ßÂ∞èÔºàÈùûÈÄèËßÜÁº©ÊîæÔºâ
            if (pointCloudOverlayMesh && pointCloudOverlayMesh.material) {
                pointCloudOverlayMesh.material.size = pointCloudSize * 0.67;  // Âè†Âä†ÁÇπ‰∫ëÁ®çÂ∞è‰∏Ä‰∫õ
                pointCloudOverlayMesh.material.needsUpdate = true;
            }
            
            // Êõ¥Êñ∞È´ò‰∫ÆÁÇπ‰∫ëÊùêË¥®Â§ßÂ∞èÔºàÈùûÈÄèËßÜÁº©ÊîæÔºâ
            if (highlightMesh && highlightMesh.material) {
                // Ê£ÄÊü•ÊòØÂê¶‰ΩøÁî®ÈÄèËßÜÁº©Êîæ
                if (highlightMesh.material.sizeAttenuation) {
                    highlightMesh.material.size = pointCloudSize * 0.044;  // ÈÄèËßÜÊ®°Âºè
                } else {
                    highlightMesh.material.size = pointCloudSize * 1.33;  // ÈùûÈÄèËßÜÊ®°Âºè
                }
                highlightMesh.material.needsUpdate = true;
            }
            
            // Êõ¥Êñ∞È¢ÑËßàÁÇπ‰∫ëÊùêË¥®Â§ßÂ∞èÔºàÈÄèËßÜÁº©ÊîæÔºâ
            if (typeof previewMesh !== 'undefined' && previewMesh && previewMesh.material) {
                previewMesh.material.size = pointCloudSize * 0.033;  // ÈÄèËßÜÊ®°Âºè‰∏ãÈúÄË¶ÅÊõ¥Â∞èÁöÑÂÄº
                previewMesh.material.needsUpdate = true;
            }
        }
        
        function createPointCloudOverlay(data) {
            const positions = data.positions;
            const colors = data.colors;
            
            if (!positions || positions.length === 0) return;
            
            // ÁßªÈô§ÊóßÁöÑÂè†Âä†ÁÇπ‰∫ë
            if (pointCloudOverlayMesh) {
                scene.remove(pointCloudOverlayMesh);
                if (pointCloudOverlayMesh.geometry) pointCloudOverlayMesh.geometry.dispose();
                if (pointCloudOverlayMesh.material) pointCloudOverlayMesh.material.dispose();
                pointCloudOverlayMesh = null;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            if (colors && colors.length > 0) {
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            }
            
            const material = new THREE.PointsMaterial({
                size: pointCloudSize * 0.67,  // ‰ΩøÁî®ÂÖ®Â±ÄÁÇπ‰∫ëÂ§ßÂ∞èÂèòÈáè
                vertexColors: colors && colors.length > 0,
                color: colors && colors.length > 0 ? undefined : 0x00ff00,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: false,
                depthTest: true,
                depthWrite: false
            });
            
            pointCloudOverlayMesh = new THREE.Points(geometry, material);
            pointCloudOverlayMesh.renderOrder = 100;
            pointCloudOverlayMesh.frustumCulled = false;
            scene.add(pointCloudOverlayMesh);
            
            pointCloudOverlayMesh.visible = showPointCloudOverlay && renderMode === 'splat';
        }
        
        function createPointCloudFromData(data) {
            const positions = data.positions;
            const colors = data.colors;
            
            if (!positions || positions.length === 0) return;
            
            if (pointCloudMesh) {
                scene.remove(pointCloudMesh);
                if (pointCloudMesh.geometry) pointCloudMesh.geometry.dispose();
                if (pointCloudMesh.material) pointCloudMesh.material.dispose();
                pointCloudMesh = null;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            if (colors && colors.length > 0) {
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
            }
            
            const material = new THREE.PointsMaterial({
                size: pointCloudSize,  // ‰ΩøÁî®ÂÖ®Â±ÄÁÇπ‰∫ëÂ§ßÂ∞èÂèòÈáè
                vertexColors: colors && colors.length > 0,
                color: colors && colors.length > 0 ? undefined : 0x888888,
                transparent: false,
                sizeAttenuation: false,
                depthWrite: true,
                depthTest: true
            });
            
            pointCloudMesh = new THREE.Points(geometry, material);
            pointCloudMesh.frustumCulled = false;
            scene.add(pointCloudMesh);
            
            pointCloudMesh.visible = (renderMode !== 'splat');
        }
        
        function updateHighlightFromData(data) {
            const positions = data.positions;
            const boundingBox = data.boundingBox;
            
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
            
            if (!positions || positions.length === 0) return;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffff00,
                size: pointCloudSize * 1.33,  // ‰ΩøÁî®ÂÖ®Â±ÄÁÇπ‰∫ëÂ§ßÂ∞èÂèòÈáèÔºåÈ´ò‰∫ÆÁÇπÁ®çÂ§ß
                transparent: true,
                opacity: 0.9,
                depthTest: false,
                depthWrite: false,
                sizeAttenuation: false
            });
            
            highlightMesh = new THREE.Points(geometry, material);
            highlightMesh.renderOrder = 999;
            highlightMesh.frustumCulled = false;
            scene.add(highlightMesh);
        }
        
        // ==================== ÈÄâÊã©Êìç‰Ωú ====================
        let selectionBox = null;
        let selectionSvg = null;
        let selectionPathEl = null;
        let lastPathUpdate = 0;
        const PATH_UPDATE_INTERVAL = 16;
        
        function createSelectionBox(x, y, width, height) {
            const overlay = document.getElementById('selection-overlay');
            if (!selectionBox) {
                selectionBox = document.createElement('div');
                selectionBox.className = 'selection-box';
                overlay.appendChild(selectionBox);
            }
            selectionBox.style.left = x + 'px';
            selectionBox.style.top = y + 'px';
            selectionBox.style.width = Math.abs(width) + 'px';
            selectionBox.style.height = Math.abs(height) + 'px';
            selectionBox.style.display = 'block';
        }
        
        function updateSelectionBox(x, y, width, height) {
            if (selectionBox) {
                const left = width < 0 ? x + width : x;
                const top = height < 0 ? y + height : y;
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = Math.abs(width) + 'px';
                selectionBox.style.height = Math.abs(height) + 'px';
            }
        }
        
        function drawSelectionPath() {
            const now = performance.now();
            if (now - lastPathUpdate < PATH_UPDATE_INTERVAL) return;
            lastPathUpdate = now;
            
            if (selectionPath.length < 2) return;
            
            const overlay = document.getElementById('selection-overlay');
            
            if (!selectionSvg) {
                selectionSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                selectionSvg.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;pointer-events:none;';
                selectionPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                selectionSvg.appendChild(selectionPathEl);
                overlay.appendChild(selectionSvg);
            }
            
            const simplifyRate = Math.max(1, Math.floor(selectionPath.length / 200));
            let pathD = `M ${selectionPath[0].x} ${selectionPath[0].y}`;
            for (let i = simplifyRate; i < selectionPath.length; i += simplifyRate) {
                pathD += ` L ${selectionPath[i].x} ${selectionPath[i].y}`;
            }
            if (selectionPath.length > 1) {
                const last = selectionPath[selectionPath.length - 1];
                pathD += ` L ${last.x} ${last.y}`;
            }
            
            if (currentTool === 'lasso') pathD += ' Z';
            
            selectionPathEl.setAttribute('d', pathD);
            selectionPathEl.setAttribute('stroke', '#8b5cf6');
            selectionPathEl.setAttribute('stroke-width', currentTool === 'brush' ? Math.min(brushSize, 30) : '2');
            selectionPathEl.setAttribute('fill', currentTool === 'lasso' ? 'rgba(139, 92, 246, 0.15)' : 'none');
            selectionPathEl.setAttribute('stroke-dasharray', currentTool === 'lasso' ? '5,5' : 'none');
            selectionPathEl.setAttribute('stroke-linecap', 'round');
            selectionPathEl.setAttribute('stroke-linejoin', 'round');
        }
        
        function clearSelectionOverlay() {
            if (selectionBox) selectionBox.style.display = 'none';
            if (selectionSvg) selectionSvg.remove();
            selectionSvg = null;
            selectionPathEl = null;
        }
        
        // Ëé∑ÂèñÈöêËóèÊ®°ÂûãÁöÑIDÂàóË°®
        function getHiddenModelIds() {
            const hiddenIds = [];
            sceneModels.forEach((model, id) => {
                if (!model.visible) {
                    hiddenIds.push(id);
                }
            });
            return hiddenIds;
        }
        
        // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïÂèØËßÅÁöÑÊ®°Âûã
        function hasVisibleModels() {
            let hasVisible = false;
            sceneModels.forEach((model) => {
                if (model.visible) {
                    hasVisible = true;
                }
            });
            return hasVisible;
        }
        
        function selectByBox(x1, y1, x2, y2, addToSelection, removeFromSelection) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            if (Math.abs(maxX - minX) < 5 && Math.abs(maxY - minY) < 5) return;
            
            // Â¶ÇÊûúÊ≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºå‰∏çÊâßË°åÈÄâÊã©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] Ê≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºåË∑≥ËøáÈÄâÊã©');
                return;
            }
            
            saveUndoState();
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByBox',
                data: {
                    minX, minY, maxX, maxY,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectByLasso(path, addToSelection, removeFromSelection) {
            if (path.length < 3) return;
            
            // Â¶ÇÊûúÊ≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºå‰∏çÊâßË°åÈÄâÊã©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] Ê≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºåË∑≥ËøáÈÄâÊã©');
                return;
            }
            
            saveUndoState();
            
            const simplifyRate = Math.max(1, Math.floor(path.length / 100));
            const simplifiedPath = path.filter((_, i) => i % simplifyRate === 0);
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByLasso',
                data: {
                    path: simplifiedPath,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectByBrush(path, radius, addToSelection, removeFromSelection) {
            if (path.length < 1) return;
            
            // Â¶ÇÊûúÊ≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºå‰∏çÊâßË°åÈÄâÊã©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] Ê≤°ÊúâÂèØËßÅÁöÑÊ®°ÂûãÔºåË∑≥ËøáÈÄâÊã©');
                return;
            }
            
            saveUndoState();
            
            const simplifyRate = Math.max(1, Math.floor(path.length / 50));
            const simplifiedPath = path.filter((_, i) => i % simplifyRate === 0);
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByBrush',
                data: {
                    path: simplifiedPath,
                    radius: radius,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectAll() {
            saveUndoState();
            sendToPython({ type: 'selectAll' });
        }
        
        function selectInverse() {
            saveUndoState();
            sendToPython({ type: 'selectInverse' });
        }
        
        function clearSelection() {
            saveUndoState();
            selectedPointIndices.clear();
            updateSelectionDisplay();
            sendToPython({ type: 'clearSelection' });
        }
        
        // ==================== ÁºñËæëÊìç‰Ωú ====================
        function hideSelected() {
            if (selectedPointIndices.size === 0) return;
            saveUndoState();
            
            selectedPointIndices.forEach(idx => {
                hiddenPointIndices.add(idx);
            });
            
            updateSelectionDisplay();
            sendToPython({ type: 'hideSelected' });
        }
        
        function showAll() {
            saveUndoState();
            hiddenPointIndices.clear();
            updateSelectionDisplay();
            sendToPython({ type: 'showAll' });
        }
        
        function deleteSelected() {
            if (selectedPointIndices.size === 0) return;
            
            const count = selectedPointIndices.size;
            if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ ${count} ‰∏™ÈÄâ‰∏≠ÁöÑÁÇπÂêóÔºü`)) return;
            
            saveUndoState();
            sendToPython({ type: 'deleteSelected' });
        }
        
        // ==================== Êí§ÈîÄ/ÈáçÂÅö ====================
        function saveUndoState() {
            const state = {
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            };
            
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            redoStack = [];
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            redoStack.push({
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            });
            
            const state = undoStack.pop();
            selectedPointIndices = state.selected;
            hiddenPointIndices = state.hidden;
            lockedPointIndices = state.locked;
            
            updateSelectionDisplay();
            sendToPython({ type: 'undo' });
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            undoStack.push({
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            });
            
            const state = redoStack.pop();
            selectedPointIndices = state.selected;
            hiddenPointIndices = state.hidden;
            lockedPointIndices = state.locked;
            
            updateSelectionDisplay();
            sendToPython({ type: 'redo' });
        }
        
        // ==================== ÊòæÁ§∫Êõ¥Êñ∞ ====================
        function updateSelectionDisplay() {
            document.getElementById('selectedCount').textContent = selectedPointIndices.size;
        }
        
        function updatePointCount() {
            let total = 0;
            sceneModels.forEach(model => {
                total += model.pointCount;
            });
            document.getElementById('pointCount').textContent = formatNumber(total);
        }
        
        function updateSelectionFromPython(data) {
            selectedPointIndices.clear();
            hiddenPointIndices.clear();
            lockedPointIndices.clear();
            
            if (data.selected) {
                data.selected.forEach(idx => selectedPointIndices.add(idx));
            }
            if (data.hidden) {
                data.hidden.forEach(idx => hiddenPointIndices.add(idx));
            }
            if (data.locked) {
                data.locked.forEach(idx => lockedPointIndices.add(idx));
            }
            
            updateSelectionDisplay();
        }

        // ==================== ËæÖÂä©ÂäüËÉΩ ====================
        function toggleGrid() {
            if (infiniteGrid) {
                infiniteGrid.visible = !infiniteGrid.visible;
                const btn = document.getElementById('btn-grid');
                btn.classList.toggle('active', infiniteGrid.visible);
            }
        }
        
        function toggleAxes() {
            if (axesHelper) {
                axesHelper.visible = !axesHelper.visible;
                const btn = document.getElementById('btn-axes');
                btn.classList.toggle('active', axesHelper.visible);
            }
        }
        
        function toggleShortcuts() {
            const panel = document.getElementById('shortcuts-panel');
            panel.classList.toggle('visible');
        }
        
        function showLoading(text) {
            document.getElementById('loading-text').textContent = text || 'Âä†ËΩΩ‰∏≠...';
            document.getElementById('loading-overlay').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }
    </script>

    <script>
        // ==================== Ê∏≤ÊüìÂæ™ÁéØ ====================
        let lastTime = performance.now();
        let frameCount = 0;
        let lastAxisUpdate = 0;
        const AXIS_UPDATE_INTERVAL = 50;
        let lastCameraQuaternion = new THREE.Quaternion();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Êõ¥Êñ∞ÊâÄÊúâSplat Viewer
            sceneModels.forEach(model => {
                if (model.viewer) {
                    model.viewer.update();
                }
            });
            
            // Êõ¥Êñ∞È¢ÑËßàviewerÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if (previewViewer && previewViewer.update) {
                try {
                    previewViewer.update();
                } catch (e) {
                    // ÂøΩÁï•Êõ¥Êñ∞ÈîôËØØ
                }
            }
            
            // Êõ¥Êñ∞ÂèòÊç¢ÊéßÂà∂Âô®‰ΩçÁΩÆÂíåÂ§ßÂ∞è
            if (transformHelper.visible && selectedModelId) {
                updateTransformHelperPosition();
            }
            
            // Ê∏≤Êüì‰∏ªÂú∫ÊôØ
            renderer.render(scene, camera);
            
            // ÂçïÁã¨Ê∏≤ÊüìÂèòÊç¢ÊéßÂà∂Âô®Âú∫ÊôØÔºàÁ°Æ‰øùÂú®ÊúÄ‰∏äÂ±ÇÔºå‰∏çË¢´Ê®°ÂûãÈÅÆÊå°Ôºâ
            if (transformHelper.visible && transformScene) {
                renderer.autoClear = false;
                renderer.clearDepth();
                renderer.render(transformScene, camera);
                renderer.autoClear = true;
            }
            
            // Êõ¥Êñ∞ÂùêÊ†áËΩ¥ÊåáÁ§∫Âô®
            const now = performance.now();
            if (now - lastAxisUpdate > AXIS_UPDATE_INTERVAL) {
                if (!camera.quaternion.equals(lastCameraQuaternion)) {
                    updateAxisIndicator();
                    lastCameraQuaternion.copy(camera.quaternion);
                }
                lastAxisUpdate = now;
            }
            
            // ËÆ°ÁÆóFPS
            frameCount++;
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // ==================== WebChannelÈÄö‰ø° ====================
        function initWebChannel() {
            if (typeof QWebChannel !== 'undefined' && typeof qt !== 'undefined' && qt.webChannelTransport) {
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    if (channel && channel.objects && channel.objects.pyBridge) {
                        pyBridge = channel.objects.pyBridge;
                        window.pyBridge = pyBridge;
                        console.log('[ThreeJS Info] WebChannelÂ∑≤ËøûÊé•');
                    }
                });
            }
        }
        
        function sendToPython(message) {
            if (pyBridge && pyBridge.receiveMessage) {
                pyBridge.receiveMessage(JSON.stringify(message));
            }
        }
        
        window.receiveMessageFromPython = function(messageStr) {
            if (!isInitialized) {
                messageQueue.push(messageStr);
                return;
            }
            
            const message = JSON.parse(messageStr);
            console.log('[ThreeJS Info] Êî∂Âà∞Ê∂àÊÅØ:', message.type);
            
            switch(message.type) {
                case 'loadModel':
                    handleLoadModel(message.data);
                    break;
                case 'captureScreenshot':
                    captureScreenshot();
                    break;
                case 'applySegmentationMask':
                    applySegmentationMask(message.data);
                    break;
                case 'selectPointsByMask':
                    selectPointsByMask(message.data);
                    break;
                case 'deleteUnselectedPoints':
                    deleteUnselectedPoints();
                    break;
                case 'deleteUnselectedPointsPermanently':
                    deleteUnselectedPointsPermanently(message.data);
                    break;
                case 'exportSplitModel':
                    exportSplitModel(message.data);
                    break;
                case 'resetView':
                    resetCamera();
                    break;
                case 'clearModel':
                    clearAllModels();
                    break;
                case 'highlightSelectedPoints':
                    highlightSelectedPoints(message.data);
                    break;
                case 'visualizeContours':
                    visualizeContoursFromData(message.data);
                    break;
                case 'clearVisualization':
                    clearVisualization();
                    break;
                case 'restoreModel':
                    restoreOriginalModel();
                    break;
                case 'clearHighlight':
                    clearHighlightMesh();
                    break;
                case 'hideOriginalModel':
                    hideOriginalModel();
                    break;
                case 'showOriginalModel':
                    showOriginalModel();
                    break;
                case 'previewSplitAsSplat':
                    previewSplitAsSplat(message.data);
                    break;
                case 'previewSplitAsPly':
                    previewSplitAsPly(message.data);
                    break;
                case 'previewSplitAsPoints':
                    previewSplitAsPoints(message.data);
                    break;
                case 'clearPreview':
                    clearPreview();
                    break;
                case 'updateSelection':
                    updateSelectionFromPython(message.data);
                    break;
                case 'setRenderMode':
                    document.getElementById('render-mode').value = message.data.mode;
                    setRenderMode(message.data.mode);
                    break;
                case 'createPointCloudFromData':
                    createPointCloudFromData(message.data);
                    break;
                case 'updateHighlightFromData':
                    updateHighlightFromData(message.data);
                    break;
                case 'createPointCloudOverlay':
                    createPointCloudOverlay(message.data);
                    break;
                default:
                    console.log('[ThreeJS Info] Êú™Áü•Ê∂àÊÅØÁ±ªÂûã:', message.type);
            }
        };
        
        function handleLoadModel(data) {
            const url = data.url;
            const name = data.name || url.split('/').pop();
            const flyTo = data.flyTo !== false;
            
            const id = addModel(url, name, 'splat');
            loadModelToScene(id, url);
        }
        
        function clearAllModels() {
            sceneModels.forEach((model, id) => {
                if (model.mesh) {
                    scene.remove(model.mesh);
                }
                if (model.viewer && model.viewer.dispose) {
                    model.viewer.dispose();
                }
            });
            
            sceneModels.clear();
            selectedModelId = null;
            
            if (pointCloudMesh) {
                scene.remove(pointCloudMesh);
                pointCloudMesh.geometry.dispose();
                pointCloudMesh.material.dispose();
                pointCloudMesh = null;
            }
            
            clearHighlightMesh();
            clearVisualization();
            
            selectedPointIndices.clear();
            hiddenPointIndices.clear();
            lockedPointIndices.clear();
            
            updateModelList();
            updatePointCount();
            updateSelectionDisplay();
        }
        
        function clearHighlightMesh() {
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
        }
        
        let contourLines = [];
        
        function clearVisualization() {
            // Ê∏ÖÈô§ËΩÆÂªìÁ∫ø
            contourLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            contourLines = [];
            
            // Ê∏ÖÈô§ËßÜÊ§é‰ΩìÁ∫ø
            frustumLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            frustumLines = [];
            
            // Ê∏ÖÈô§ËßíÁÇπÊ†áËÆ∞
            cornerMarkers.forEach(marker => {
                scene.remove(marker);
                if (marker.geometry) marker.geometry.dispose();
                if (marker.material) marker.material.dispose();
            });
            cornerMarkers = [];
        }
        
        function restoreOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = model.visible;
                }
            });
            clearHighlightMesh();
        }
        
        // ==================== È¢ÑËßàÂäüËÉΩ ====================
        let previewMesh = null;
        
        function hideOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            // ‰πüÈöêËóèÈ´ò‰∫Æ
            if (highlightMesh) {
                highlightMesh.visible = false;
            }
        }
        
        function showOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = model.visible;
                }
            });
            // ÊÅ¢Â§çÈ´ò‰∫ÆÊòæÁ§∫
            if (highlightMesh) {
                highlightMesh.visible = true;
            }
        }
        
        // È¢ÑËßàÁî®ÁöÑ‰∏¥Êó∂viewer
        let previewViewer = null;
        
        function previewSplitAsPly(data) {
            // PLYÊ∏≤ÊüìÊ®°ÂºèÔºöÁõ¥Êé•Âä†ËΩΩPLYÊñá‰ª∂
            clearPreview();
            
            const plyUrl = data.plyUrl || null;
            
            console.log('[ThreeJS Debug] PLYÈ¢ÑËßàÊï∞ÊçÆ:', {
                plyUrl: plyUrl
            });
            
            if (!plyUrl) {
                console.error('[ThreeJS Error] Ê≤°ÊúâPLY URL');
                return;
            }
            
            // ÈöêËóèÂéüÊ®°ÂûãÂíåÈ´ò‰∫Æ
            hideOriginalModel();
            
            // ‰ΩøÁî®GaussianSplats3DÂä†ËΩΩPLYÊñá‰ª∂
            if (typeof GaussianSplats3D !== 'undefined' && GaussianSplats3D.Viewer) {
                try {
                    console.log('[ThreeJS Info] ÂºÄÂßãÂä†ËΩΩÈ¢ÑËßàPLY:', plyUrl);
                    
                    // ‰øùÂ≠òÂΩìÂâçÁõ∏Êú∫Áä∂ÊÄÅ
                    const savedCameraPos = camera.position.clone();
                    const savedCameraQuat = camera.quaternion.clone();
                    const savedTarget = target.clone();
                    
                    // ÂàõÂª∫‰∏¥Êó∂viewerÔºà‰ΩøÁî®Áé∞ÊúâÁöÑrendererÂíåcameraÔºâ
                    previewViewer = new GaussianSplats3D.Viewer({
                        cameraUp: [0, 1, 0],
                        initialCameraPosition: savedCameraPos.toArray(),
                        initialCameraLookAt: savedTarget.toArray(),
                        sharedMemoryForWorkers: false,
                        enableSIMDInSort: false,
                        gpuAcceleratedSort: false,
                        integerBasedSort: false,
                        renderer: renderer,
                        camera: camera,
                        useBuiltInControls: false,
                        rootElement: null,
                        selfDrivenMode: false,
                        dynamicScene: false
                    });
                    
                    // Âä†ËΩΩPLYÂú∫ÊôØ
                    // Á°Æ‰øùURL‰ª•.plyÁªìÂ∞æÔºåGaussianSplats3DÈÄöËøáÊâ©Â±ïÂêçËØÜÂà´Ê†ºÂºè
                    let finalUrl = plyUrl;
                    if (!plyUrl.toLowerCase().includes('.ply')) {
                        // Â¶ÇÊûúURL‰∏≠ÂÆåÂÖ®Ê≤°Êúâ.plyÔºåÊ∑ªÂä†Âà∞Ë∑ØÂæÑ‰∏≠
                        const urlObj = new URL(plyUrl);
                        urlObj.pathname = urlObj.pathname + '.ply';
                        finalUrl = urlObj.toString();
                        console.log('[ThreeJS Info] URLÂ∑≤‰øÆÊîπ‰∏∫ÂåÖÂê´.plyÊâ©Â±ïÂêç:', finalUrl);
                    }
                    
                    console.log('[ThreeJS Info] ÊúÄÁªàPLY URL:', finalUrl);
                    
                    // ÂÖàÊµãËØïURLÊòØÂê¶ÂèØËÆøÈóÆ
                    console.log('[ThreeJS Info] ÊµãËØïPLYÊñá‰ª∂ÂèØËÆøÈóÆÊÄß:', finalUrl);
                    fetch(finalUrl, { method: 'HEAD' })
                        .then(response => {
                            console.log('[ThreeJS Info] PLYÊñá‰ª∂HTTPÁä∂ÊÄÅ:', response.status);
                            console.log('[ThreeJS Info] PLYÊñá‰ª∂Content-Type:', response.headers.get('Content-Type'));
                            console.log('[ThreeJS Info] PLYÊñá‰ª∂Content-Length:', response.headers.get('Content-Length'));
                        })
                        .catch(error => {
                            console.error('[ThreeJS Error] Êó†Ê≥ïËÆøÈóÆPLYÊñá‰ª∂:', error);
                        });
                    
                    // Â∞ùËØïÂä†ËΩΩPLYÂú∫ÊôØ
                    console.log('[ThreeJS Info] Ë∞ÉÁî®addSplatSceneÔºåURL:', finalUrl);
                    
                    previewViewer.addSplatScene(finalUrl, {
                        splatAlphaRemovalThreshold: 1,
                        showLoadingUI: false,
                        progressiveLoad: false,
                        position: [0, 0, 0],
                        rotation: [0, 0, 0, 1],
                        scale: [1, 1, 1],
                        streamView: false,
                        halfPrecisionCovariancesOnGPU: true,
                        sphericalHarmonicsDegree: 0
                    }).then(() => {
                        console.log('[ThreeJS Info] PLYÂú∫ÊôØÂä†ËΩΩÂÆåÊàê');
                        
                        // Ëé∑Âèñsplat meshÂπ∂Ê∑ªÂä†Âà∞Âú∫ÊôØ
                        if (previewViewer.splatMesh) {
                            previewMesh = previewViewer.splatMesh;
                            previewMesh.frustumCulled = false;
                            scene.add(previewMesh);
                            
                            // ÊÅ¢Â§çÁõ∏Êú∫Áä∂ÊÄÅ
                            camera.position.copy(savedCameraPos);
                            camera.quaternion.copy(savedCameraQuat);
                            target.copy(savedTarget);
                            camera.updateProjectionMatrix();
                            
                            // Âº∫Âà∂Êõ¥Êñ∞‰∏ÄÊ¨°
                            if (previewViewer.update) {
                                previewViewer.update();
                            }
                            
                            console.log('[ThreeJS Info] PLYÈ¢ÑËßàÂä†ËΩΩÊàêÂäü, meshÂèØËßÅÊÄß:', previewMesh.visible);
                        } else {
                            console.error('[ThreeJS Error] Êó†Ê≥ïËé∑Âèñsplat mesh');
                        }
                    }).catch(error => {
                        console.error('[ThreeJS Error] PLYÈ¢ÑËßàÂä†ËΩΩÂ§±Ë¥•:', error);
                        console.error('[ThreeJS Error] ÈîôËØØÁ±ªÂûã:', error.constructor.name);
                        console.error('[ThreeJS Error] ÈîôËØØÊ∂àÊÅØ:', error.message);
                        if (error.stack) {
                            console.error('[ThreeJS Error] ÈîôËØØÂ†ÜÊ†à:', error.stack);
                        }
                        
                        // Â∞ùËØïËé∑ÂèñÊõ¥Â§öÈîôËØØ‰ø°ÊÅØ
                        if (error.response) {
                            console.error('[ThreeJS Error] HTTPÂìçÂ∫î:', error.response);
                        }
                        
                        // Âä†ËΩΩÂ§±Ë¥•Êó∂ÊÅ¢Â§çÂéüÊ®°ÂûãÊòæÁ§∫
                        showOriginalModel();
                    });
                    
                } catch (error) {
                    console.error('[ThreeJS Error] ÂàõÂª∫PLYÊü•ÁúãÂô®Â§±Ë¥•:', error);
                    console.error('[ThreeJS Error] ÈîôËØØËØ¶ÊÉÖ:', error.stack);
                    
                    // ÂàõÂª∫Â§±Ë¥•Êó∂ÊÅ¢Â§çÂéüÊ®°ÂûãÊòæÁ§∫
                    showOriginalModel();
                }
            } else {
                console.error('[ThreeJS Error] GaussianSplats3DÂ∫ìÊú™Âä†ËΩΩ');
                showOriginalModel();
            }
            
            console.log('[ThreeJS Info] È¢ÑËßàÊ®°Âºè: PLYÊ∏≤Êüì');
        }
        
        function previewSplitAsSplat(data) {
            // SplatÊ∏≤ÊüìÊ®°ÂºèÔºöÂä†ËΩΩ‰∏¥Êó∂splatÊñá‰ª∂
            clearPreview();
            
            const splatUrl = data.splatUrl || null;
            
            console.log('[ThreeJS Debug] SplatÈ¢ÑËßàÊï∞ÊçÆ:', {
                splatUrl: splatUrl
            });
            
            if (!splatUrl) {
                console.error('[ThreeJS Error] Ê≤°Êúâsplat URL');
                return;
            }
            
            // ÈöêËóèÂéüÊ®°ÂûãÂíåÈ´ò‰∫Æ
            hideOriginalModel();
            
            // ‰ΩøÁî®GaussianSplats3DÂä†ËΩΩ‰∏¥Êó∂splatÊñá‰ª∂
            if (typeof GaussianSplats3D !== 'undefined' && GaussianSplats3D.Viewer) {
                try {
                    console.log('[ThreeJS Info] ÂºÄÂßãÂä†ËΩΩÈ¢ÑËßàsplat:', splatUrl);
                    
                    // ‰øùÂ≠òÂΩìÂâçÁõ∏Êú∫Áä∂ÊÄÅ
                    const savedCameraPos = camera.position.clone();
                    const savedCameraQuat = camera.quaternion.clone();
                    const savedTarget = target.clone();
                    
                    // ÂàõÂª∫‰∏¥Êó∂viewerÔºà‰ΩøÁî®Áé∞ÊúâÁöÑrendererÂíåcameraÔºâ
                    previewViewer = new GaussianSplats3D.Viewer({
                        cameraUp: [0, 1, 0],
                        initialCameraPosition: savedCameraPos.toArray(),
                        initialCameraLookAt: savedTarget.toArray(),
                        sharedMemoryForWorkers: false,  // Á¶ÅÁî®ÂÖ±‰∫´ÂÜÖÂ≠ò
                        enableSIMDInSort: false,        // Á¶ÅÁî®SIMD
                        gpuAcceleratedSort: false,      // Á¶ÅÁî®GPUÂä†ÈÄüÊéíÂ∫è
                        integerBasedSort: false,        // ‰ΩøÁî®ÊµÆÁÇπÊéíÂ∫è
                        renderer: renderer,             // ‰ΩøÁî®Áé∞ÊúâÁöÑrenderer
                        camera: camera,                 // ‰ΩøÁî®Áé∞ÊúâÁöÑcamera
                        useBuiltInControls: false,      // ‰∏ç‰ΩøÁî®ÂÜÖÁΩÆÊéßÂà∂
                        rootElement: null,              // ‰∏çÈôÑÂä†Âà∞DOM
                        selfDrivenMode: false,          // ‰∏çËá™Âä®È©±Âä®
                        dynamicScene: false             // ÈùôÊÄÅÂú∫ÊôØ
                    });
                    
                    previewViewer.addSplatScene(splatUrl, {
                        splatAlphaRemovalThreshold: 1,  // Èôç‰ΩéÈòàÂÄºÔºå‰øùÁïôÊõ¥Â§öÁÇπ
                        showLoadingUI: false,
                        progressiveLoad: false,
                        position: [0, 0, 0],
                        rotation: [0, 0, 0, 1],
                        scale: [1, 1, 1],
                        streamView: false,
                        halfPrecisionCovariancesOnGPU: true,  // ‰ΩøÁî®ÂçäÁ≤æÂ∫¶ÂáèÂ∞ëÂÜÖÂ≠ò
                        sphericalHarmonicsDegree: 0  // Âè™‰ΩøÁî®DCÈ°πÔºåÊèêÈ´òÊÄßËÉΩ
                    }).then(() => {
                        console.log('[ThreeJS Info] SplatÂú∫ÊôØÂä†ËΩΩÂÆåÊàê');
                        
                        // Ëé∑Âèñsplat meshÂπ∂Ê∑ªÂä†Âà∞Âú∫ÊôØ
                        if (previewViewer.splatMesh) {
                            previewMesh = previewViewer.splatMesh;
                            previewMesh.frustumCulled = false;  // Á¶ÅÁî®ËßÜÈî•‰ΩìÂâîÈô§
                            scene.add(previewMesh);
                            
                            // ÊÅ¢Â§çÁõ∏Êú∫Áä∂ÊÄÅ
                            camera.position.copy(savedCameraPos);
                            camera.quaternion.copy(savedCameraQuat);
                            target.copy(savedTarget);
                            camera.updateProjectionMatrix();
                            
                            // Âº∫Âà∂Êõ¥Êñ∞‰∏ÄÊ¨°
                            if (previewViewer.update) {
                                previewViewer.update();
                            }
                            
                            console.log('[ThreeJS Info] SplatÈ¢ÑËßàÂä†ËΩΩÊàêÂäü, meshÂèØËßÅÊÄß:', previewMesh.visible);
                        } else {
                            console.error('[ThreeJS Error] Êó†Ê≥ïËé∑Âèñsplat mesh');
                        }
                    }).catch(error => {
                        console.error('[ThreeJS Error] SplatÈ¢ÑËßàÂä†ËΩΩÂ§±Ë¥•:', error);
                        console.error('[ThreeJS Error] ÈîôËØØËØ¶ÊÉÖ:', error.stack);
                        
                        // Âä†ËΩΩÂ§±Ë¥•Êó∂ÊÅ¢Â§çÂéüÊ®°ÂûãÊòæÁ§∫
                        showOriginalModel();
                    });
                    
                } catch (error) {
                    console.error('[ThreeJS Error] ÂàõÂª∫SplatÊü•ÁúãÂô®Â§±Ë¥•:', error);
                    console.error('[ThreeJS Error] ÈîôËØØËØ¶ÊÉÖ:', error.stack);
                    
                    // ÂàõÂª∫Â§±Ë¥•Êó∂ÊÅ¢Â§çÂéüÊ®°ÂûãÊòæÁ§∫
                    showOriginalModel();
                }
            } else {
                console.error('[ThreeJS Error] GaussianSplats3DÂ∫ìÊú™Âä†ËΩΩ');
                showOriginalModel();
            }
            
            console.log('[ThreeJS Info] È¢ÑËßàÊ®°Âºè: SplatÊ∏≤Êüì');
        }
        
        function previewSplitAsPoints(data) {
            // ÁÇπ‰∫ëÊ∏≤ÊüìÊ®°ÂºèÔºöÂàõÂª∫Â∞èÁÇπÁöÑÁÇπ‰∫ëmesh
            clearPreview();
            
            const positions = data.positions || [];
            const colors = data.colors || [];
            
            console.log('[ThreeJS Debug] ÁÇπ‰∫ëÈ¢ÑËßàÊï∞ÊçÆ:', {
                positionsLength: positions.length,
                colorsLength: colors.length,
                pointCount: positions.length / 3,
                colorCount: colors.length / 3,
                colorSample: colors.length >= 9 ? [
                    `RGB(${colors[0].toFixed(2)}, ${colors[1].toFixed(2)}, ${colors[2].toFixed(2)})`,
                    `RGB(${colors[3].toFixed(2)}, ${colors[4].toFixed(2)}, ${colors[5].toFixed(2)})`,
                    `RGB(${colors[6].toFixed(2)}, ${colors[7].toFixed(2)}, ${colors[8].toFixed(2)})`
                ] : 'none'
            });
            
            if (positions.length === 0) {
                console.warn('[ThreeJS Warning] Ê≤°ÊúâÁÇπ‰∫ëÊï∞ÊçÆ');
                return;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            let hasColors = false;
            if (colors.length > 0 && colors.length === positions.length) {
                // Á°Æ‰øùÈ¢úËâ≤Êï∞ÊçÆÂú®0-1ËåÉÂõ¥ÂÜÖ
                const colorArray = new Float32Array(colors.length);
                for (let i = 0; i < colors.length; i++) {
                    colorArray[i] = Math.max(0, Math.min(1, colors[i]));
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
                hasColors = true;
                console.log('[ThreeJS Info] ËÆæÁΩÆÈ°∂ÁÇπÈ¢úËâ≤ÊàêÂäü, È¢úËâ≤ËåÉÂõ¥Ê£ÄÊü•:', {
                    min: Math.min(...colorArray),
                    max: Math.max(...colorArray),
                    sample: [colorArray[0], colorArray[1], colorArray[2]]
                });
            } else {
                console.warn('[ThreeJS Warning] È¢úËâ≤Êï∞ÊçÆÈïøÂ∫¶‰∏çÂåπÈÖçÊàñ‰∏∫Á©∫:', {
                    positionsLength: positions.length,
                    colorsLength: colors.length
                });
            }
            
            const material = new THREE.PointsMaterial({
                size: pointCloudSize * 0.033,  // ‰ΩøÁî®ÂÖ®Â±ÄÁÇπ‰∫ëÂ§ßÂ∞èÂèòÈáèÔºåÈÄèËßÜÊ®°Âºè‰∏ãÈúÄË¶ÅÊõ¥Â∞èÁöÑÂÄº
                vertexColors: hasColors,
                color: hasColors ? 0xffffff : 0xaaaaaa,
                sizeAttenuation: true,
                transparent: false,
                opacity: 1.0,
                depthTest: true,
                depthWrite: true
            });
            
            console.log('[ThreeJS Debug] ÊùêË¥®ËÆæÁΩÆ:', {
                vertexColors: material.vertexColors,
                color: material.color.getHexString(),
                size: material.size
            });
            
            previewMesh = new THREE.Points(geometry, material);
            previewMesh.frustumCulled = false;  // Á¶ÅÁî®ËßÜÈî•‰ΩìÂâîÈô§
            scene.add(previewMesh);
            
            // ÈöêËóèÂéüÊ®°ÂûãÂíåÈ´ò‰∫Æ
            hideOriginalModel();
            
            console.log('[ThreeJS Info] È¢ÑËßàÊ®°Âºè: ÁÇπ‰∫ëÊ∏≤Êüì, ÁÇπÊï∞:', positions.length / 3, 'È¢úËâ≤:', hasColors ? 'Êúâ' : 'Êó†');
        }
        
        function clearPreview() {
            if (previewMesh) {
                scene.remove(previewMesh);
                if (previewMesh.geometry) previewMesh.geometry.dispose();
                if (previewMesh.material) previewMesh.material.dispose();
                previewMesh = null;
            }
            
            // Ê∏ÖÁêÜÈ¢ÑËßàviewer
            if (previewViewer) {
                try {
                    if (previewViewer.dispose) {
                        previewViewer.dispose();
                    }
                } catch (e) {
                    console.warn('[ThreeJS Warning] Ê∏ÖÁêÜÈ¢ÑËßàviewerÂ§±Ë¥•:', e);
                }
                previewViewer = null;
            }
        }
        
        // ==================== Êà™ÂõæÂíåÂàÜÂâ≤ ====================
        function captureScreenshot() {
            try {
                const canvas = renderer.domElement;
                const imageData = canvas.toDataURL('image/png');
                
                camera.updateMatrix();
                camera.updateMatrixWorld(true);
                camera.updateProjectionMatrix();
                camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                
                const cameraPosition = camera.position.clone();
                const cameraDirection = new THREE.Vector3(0, 0, -1);
                cameraDirection.applyQuaternion(camera.quaternion);
                const cameraTarget = cameraPosition.clone().add(cameraDirection);
                
                sendToPython({
                    type: 'screenshotCaptured',
                    data: {
                        imageData: imageData,
                        width: canvas.width,
                        height: canvas.height,
                        cameraPosition: [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                        cameraTarget: [cameraTarget.x, cameraTarget.y, cameraTarget.z],
                        cameraFov: camera.fov,
                        viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                        projMatrix: Array.from(camera.projectionMatrix.elements)
                    }
                });
            } catch (error) {
                console.error('[ThreeJS Error] Êà™ÂõæÂ§±Ë¥•:', error);
                sendToPython({
                    type: 'screenshotCaptured',
                    success: false,
                    error: error.message
                });
            }
        }
        
        let segmentationMask = null;
        
        function applySegmentationMask(data) {
            segmentationMask = {
                data: data.mask,
                width: data.width,
                height: data.height
            };
            
            sendToPython({
                type: 'segmentationComplete',
                success: true
            });
        }
        
        function selectPointsByMask(data) {
            const keepSelected = data.keepSelected !== false;
            selectedPointIndices.clear();
            
            // ÈÅçÂéÜÊâÄÊúâÊ®°Âûã
            sceneModels.forEach(model => {
                if (!model.viewer || !segmentationMask) return;
                
                try {
                    const splatCount = model.viewer.getSplatCount ? model.viewer.getSplatCount() : 0;
                    
                    for (let i = 0; i < splatCount; i++) {
                        const position = new THREE.Vector3();
                        if (model.viewer.getSplatCenter) {
                            model.viewer.getSplatCenter(i, position);
                        }
                        
                        const screenPos = position.clone().project(camera);
                        
                        const x = Math.floor((screenPos.x + 1) / 2 * segmentationMask.width);
                        const y = Math.floor((1 - screenPos.y) / 2 * segmentationMask.height);
                        
                        if (x >= 0 && x < segmentationMask.width && 
                            y >= 0 && y < segmentationMask.height) {
                            const maskIndex = y * segmentationMask.width + x;
                            const maskValue = segmentationMask.data[maskIndex];
                            
                            if (keepSelected) {
                                if (maskValue > 0) {
                                    selectedPointIndices.add(i);
                                }
                            } else {
                                if (maskValue === 0) {
                                    selectedPointIndices.add(i);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('[ThreeJS Error] ÈÄâÊã©ÁÇπÂ§±Ë¥•:', error);
                }
            });
            
            updateSelectionDisplay();
            
            sendToPython({
                type: 'pointsSelected',
                data: {
                    selectedCount: selectedPointIndices.size
                }
            });
        }
        
        function deleteUnselectedPoints() {
            // ÊóßÁöÑÂà†Èô§ÂáΩÊï∞ - ‰ªÖÁî®‰∫éÂêëÂêéÂÖºÂÆπ
            if (selectedPointIndices.size === 0) return;
            
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            
            if (highlightMesh) {
                highlightMesh.material.opacity = 1.0;
                highlightMesh.material.size = 0.2;
                highlightMesh.material.needsUpdate = true;
            }
            
            sendToPython({
                type: 'pointsDeleted',
                data: { remainingCount: selectedPointIndices.size }
            });
        }
        
        function deleteUnselectedPointsPermanently(data) {
            // Ê∞∏‰πÖÂà†Èô§Êú™ÈÄâ‰∏≠ÁöÑÁÇπ - Âè™‰øùÁïôÈÄâ‰∏≠ÁöÑÁÇπ
            const selectedIndices = new Set(data.selectedIndices || []);
            
            if (selectedIndices.size === 0) {
                console.warn('[ThreeJS Warning] Ê≤°ÊúâÈÄâ‰∏≠ÁöÑÁÇπ');
                return;
            }
            
            // Ê∏ÖÈô§È¢ÑËßà
            clearPreview();
            
            // ÈöêËóèÂéüÂßãsplatÊ®°Âûã
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            
            // Ê∏ÖÈô§ÊóßÁöÑÈ´ò‰∫Æ
            clearHighlightMesh();
            
            // Âè™ÊòæÁ§∫ÈÄâ‰∏≠ÁöÑÁÇπÔºà‰Ωú‰∏∫ÁÇπ‰∫ëÔºâ
            // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨Êó†Ê≥ïÁúüÊ≠£‰øÆÊîπsplatÊï∞ÊçÆÔºåÂè™ËÉΩÈÄöËøáÊòæÁ§∫/ÈöêËóèÊù•Ê®°Êãü
            // ÁúüÊ≠£ÁöÑÂà†Èô§Âú®PythonÁ´ØÂÆåÊàê
            
            console.log('[ThreeJS Info] Ê∞∏‰πÖÂà†Èô§ÂÆåÊàêÔºå‰øùÁïô', selectedIndices.size, '‰∏™ÁÇπ');
            
            // Êõ¥Êñ∞ÈÄâ‰∏≠Áä∂ÊÄÅ
            selectedPointIndices = selectedIndices;
            updateSelectionDisplay();
            
            sendToPython({
                type: 'pointsDeletedPermanently',
                data: { remainingCount: selectedIndices.size }
            });
        }
        
        function exportSplitModel(data) {
            const outputPath = data.outputPath;
            
            sendToPython({
                type: 'modelSplitComplete',
                success: true,
                data: {
                    outputPath: outputPath,
                    selectedIndices: Array.from(selectedPointIndices)
                }
            });
        }
        
        function highlightSelectedPoints(data) {
            const indices = data.indices || [];
            const count = data.count || indices.length;
            const positions3D = data.positions || null;
            
            clearHighlightMesh();
            
            if (count === 0) {
                document.getElementById('selectedCount').textContent = '0';
                return;
            }
            
            selectedPointIndices.clear();
            indices.forEach(i => selectedPointIndices.add(i));
            
            try {
                let positions = [];
                
                if (positions3D && positions3D.length > 0) {
                    const maxDisplayPoints = 50000;
                    let sampleRate = 1;
                    if (positions3D.length > maxDisplayPoints) {
                        sampleRate = Math.ceil(positions3D.length / maxDisplayPoints);
                    }
                    
                    for (let i = 0; i < positions3D.length; i += sampleRate) {
                        const pt = positions3D[i];
                        positions.push(pt[0], pt[1], pt[2]);
                    }
                }
                
                if (positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    
                    const material = new THREE.PointsMaterial({
                        color: 0xffff00,  // ÈªÑËâ≤È´ò‰∫Æ
                        size: pointCloudSize * 0.044,  // ‰ΩøÁî®ÂÖ®Â±ÄÁÇπ‰∫ëÂ§ßÂ∞èÂèòÈáèÔºåÈÄèËßÜÊ®°Âºè‰∏ãÈúÄË¶ÅÊõ¥Â∞èÁöÑÂÄºÔºåÈ´ò‰∫ÆÁ®çÂ§ß
                        transparent: true,
                        opacity: 1.0,  // ÂÆåÂÖ®‰∏çÈÄèÊòé
                        depthTest: true,  // ÂêØÁî®Ê∑±Â∫¶ÊµãËØïÔºåÊõ¥ÁúüÂÆû
                        depthWrite: false,
                        sizeAttenuation: true  // ÂêØÁî®ÈÄèËßÜÁº©Êîæ
                    });
                    
                    highlightMesh = new THREE.Points(geometry, material);
                    highlightMesh.renderOrder = 999;
                    scene.add(highlightMesh);
                    
                    console.log('[ThreeJS Info] È´ò‰∫ÆÊòæÁ§∫', positions.length / 3, '‰∏™ÁÇπ');
                }
            } catch (error) {
                console.error('[ThreeJS Error] ÂàõÂª∫È´ò‰∫ÆÂ§±Ë¥•:', error);
            }
            
            document.getElementById('selectedCount').textContent = count;
            
            sendToPython({
                type: 'pointsHighlighted',
                data: { highlightedCount: count }
            });
        }
        
        // ËßÜÊ§é‰ΩìÂèØËßÜÂåñÁõ∏ÂÖ≥ÂèòÈáè
        let frustumLines = [];
        let cornerMarkers = [];
        
        function visualizeContoursFromData(data) {
            try {
                const contours = data.contours || [];
                const imageWidth = data.imageWidth || renderer.domElement.width;
                const imageHeight = data.imageHeight || renderer.domElement.height;
                const showFrustum = data.showFrustum !== false;  // ÈªòËÆ§ÊòæÁ§∫ËßÜÊ§é‰Ωì
                
                clearVisualization();
                
                if (contours.length === 0) return;
                
                const raycaster = new THREE.Raycaster();
                
                // ËÆ°ÁÆóÂõõ‰∏™ËßíÁÇπÁî®‰∫éËßÜÊ§é‰Ωì
                const cornerPixels = [
                    [0, 0],                           // Â∑¶‰∏ä
                    [imageWidth, 0],                  // Âè≥‰∏ä
                    [imageWidth, imageHeight],        // Âè≥‰∏ã
                    [0, imageHeight]                  // Â∑¶‰∏ã
                ];
                
                const cornerPoints3D = [];
                
                // ‰ΩøÁî®Â∞ÑÁ∫øÊ£ÄÊµãËÆ°ÁÆóËßíÁÇπÁöÑ3DÂùêÊ†á
                cornerPixels.forEach(pixel => {
                    const ndcX = (pixel[0] / imageWidth) * 2 - 1;
                    const ndcY = -((pixel[1] / imageHeight) * 2 - 1);
                    
                    raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), camera);
                    
                    // ‰ΩøÁî®Âõ∫ÂÆöË∑ùÁ¶ªÊàñ‰∏ésplat meshÁõ∏‰∫§
                    let intersectionPoint = null;
                    
                    // Â∞ùËØï‰∏ésplat meshÁõ∏‰∫§
                    const intersects = [];
                    sceneModels.forEach(model => {
                        if (model.viewer && model.viewer.splatMesh && model.visible) {
                            const meshIntersects = raycaster.intersectObject(model.viewer.splatMesh, false);
                            intersects.push(...meshIntersects);
                        }
                    });
                    
                    if (intersects.length > 0) {
                        // ‰ΩøÁî®ÊúÄËøëÁöÑ‰∫§ÁÇπ
                        intersects.sort((a, b) => a.distance - b.distance);
                        intersectionPoint = intersects[0].point.clone();
                    } else {
                        // Â¶ÇÊûúÊ≤°Êúâ‰∫§ÁÇπÔºå‰ΩøÁî®Âõ∫ÂÆöË∑ùÁ¶ª
                        const direction = raycaster.ray.direction.clone();
                        const distance = 10;  // ÈªòËÆ§Ë∑ùÁ¶ª
                        intersectionPoint = camera.position.clone().add(direction.multiplyScalar(distance));
                    }
                    
                    cornerPoints3D.push(intersectionPoint);
                });
                
                // ÁªòÂà∂ËßÜÊ§é‰ΩìÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
                if (showFrustum && cornerPoints3D.length === 4) {
                    // 1. ÁªòÂà∂‰ªéÁõ∏Êú∫Âà∞Âõõ‰∏™ËßíÁÇπÁöÑÂ∞ÑÁ∫øÔºàÁªøËâ≤Ôºâ
                    const rayMaterial = new THREE.LineBasicMaterial({
                        color: 0x00ff00,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    cornerPoints3D.forEach((cornerPoint, idx) => {
                        const rayGeometry = new THREE.BufferGeometry().setFromPoints([
                            camera.position.clone(),
                            cornerPoint
                        ]);
                        const rayLine = new THREE.Line(rayGeometry, rayMaterial);
                        scene.add(rayLine);
                        frustumLines.push(rayLine);
                    });
                    
                    // 2. ÁªòÂà∂Âõõ‰∏™ËßíÁÇπÂΩ¢ÊàêÁöÑÁü©ÂΩ¢ËæπÊ°ÜÔºàÈùíËâ≤Ôºâ
                    const frameMaterial = new THREE.LineBasicMaterial({
                        color: 0x00ffff,
                        linewidth: 3,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const framePoints = [
                        cornerPoints3D[0],
                        cornerPoints3D[1],
                        cornerPoints3D[2],
                        cornerPoints3D[3],
                        cornerPoints3D[0]  // Èó≠Âêà
                    ];
                    
                    const frameGeometry = new THREE.BufferGeometry().setFromPoints(framePoints);
                    const frameLine = new THREE.Line(frameGeometry, frameMaterial);
                    scene.add(frameLine);
                    frustumLines.push(frameLine);
                    
                    // 3. Âú®Âõõ‰∏™ËßíÁÇπ‰ΩçÁΩÆÊ∑ªÂä†Á∫¢Ëâ≤ÁêÉ‰ΩìÊ†áËÆ∞
                    const markerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const markerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        transparent: false
                    });
                    
                    cornerPoints3D.forEach((cornerPoint, idx) => {
                        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                        marker.position.copy(cornerPoint);
                        scene.add(marker);
                        cornerMarkers.push(marker);
                    });
                    
                    console.log('[ThreeJS Info] ËßÜÊ§é‰ΩìÂèØËßÜÂåñÂÆåÊàê: 4‰∏™ËßíÁÇπ, 4Êù°Â∞ÑÁ∫ø, 1‰∏™Áü©ÂΩ¢Ê°Ü');
                }
                
                // ÁªòÂà∂ËΩÆÂªìÁ∫ø
                contours.forEach((contour, contourIdx) => {
                    if (!contour || contour.length < 3) return;
                    
                    const contour3D = [];
                    const sampleRate = Math.max(1, Math.floor(contour.length / 100));
                    
                    for (let i = 0; i < contour.length; i += sampleRate) {
                        const point = contour[i];
                        
                        const ndcX = (point[0] / imageWidth) * 2 - 1;
                        const ndcY = -((point[1] / imageHeight) * 2 - 1);
                        
                        raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), camera);
                        
                        // Â∞ùËØï‰∏ésplat meshÁõ∏‰∫§
                        const intersects = [];
                        sceneModels.forEach(model => {
                            if (model.viewer && model.viewer.splatMesh && model.visible) {
                                const meshIntersects = raycaster.intersectObject(model.viewer.splatMesh, false);
                                intersects.push(...meshIntersects);
                            }
                        });
                        
                        let intersectionPoint;
                        if (intersects.length > 0) {
                            intersects.sort((a, b) => a.distance - b.distance);
                            intersectionPoint = intersects[0].point.clone();
                        } else {
                            const direction = raycaster.ray.direction.clone();
                            const distance = 8;
                            intersectionPoint = camera.position.clone().add(direction.multiplyScalar(distance));
                        }
                        
                        contour3D.push(intersectionPoint);
                    }
                    
                    if (contour3D.length > 2) {
                        contour3D.push(contour3D[0].clone());
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(contour3D);
                        const material = new THREE.LineBasicMaterial({
                            color: 0xff00ff,
                            linewidth: 3,
                            transparent: true,
                            opacity: 0.9
                        });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        contourLines.push(line);
                    }
                });
                
                console.log('[ThreeJS Info] ËΩÆÂªìÂèØËßÜÂåñÂÆåÊàê:', contours.length, '‰∏™ËΩÆÂªì');
            } catch (error) {
                console.error('[ThreeJS Error] ÂèØËßÜÂåñËΩÆÂªìÂ§±Ë¥•:', error);
                console.error(error.stack);
            }
        }
        
        // ==================== È°µÈù¢Âä†ËΩΩ ====================
        window.addEventListener('load', function() {
            function waitForLibraries() {
                if (typeof THREE !== 'undefined') {
                    init();
                } else {
                    setTimeout(waitForLibraries, 100);
                }
            }
            waitForLibraries();
        });
    </script>
</body>
</html>
