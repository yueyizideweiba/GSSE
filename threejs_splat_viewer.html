<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GSSE Three.js 3DGSç¼–è¾‘å™¨</title>
    
    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js" 
            onerror="loadLocalThree();"></script>
    
    <script>
        function loadLocalThree() {
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                script.src = './lib/threejs/three.min.js';
                document.head.appendChild(script);
            }
        }
    </script>
    
    <!-- Gaussian Splats 3D -->
    <script>
        function loadGaussianSplats3D() {
            if (typeof THREE === 'undefined') {
                setTimeout(loadGaussianSplats3D, 100);
                return;
            }
            
            const script = document.createElement('script');
            script.src = './lib/gaussian-splats-3d/gaussian-splats-3d.umd.cjs';
            script.onload = function() {
                const GaussianSplats3D = window["Gaussian Splats 3D"] || window.GaussianSplats3D;
                if (GaussianSplats3D && typeof GaussianSplats3D.Viewer !== 'undefined') {
                    window.GaussianSplats3D = GaussianSplats3D;
                    console.log('[ThreeJS Info] GaussianSplats3Dåº“å·²åŠ è½½');
                }
            };
            document.head.appendChild(script);
        }
        loadGaussianSplats3D();
    </script>

    <style>
        :root {
            --bg-primary: #121218;
            --bg-secondary: #1e1e2e;
            --bg-tertiary: #2a2a3e;
            --bg-hover: #3d3d5c;
            --accent-color: #8b5cf6;
            --accent-hover: #a78bfa;
            --accent-light: rgba(139, 92, 246, 0.15);
            --text-primary: #e8e8f0;
            --text-secondary: #9898b0;
            --border-color: #3d3d5c;
            --success-color: #22c55e;
            --warning-color: #eab308;
            --danger-color: #ef4444;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-primary);
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* å·¦ä¾§åœºæ™¯ç®¡ç†å™¨é¢æ¿ */
        #scene-manager-panel {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 320px;
            z-index: 1000;
            background: var(--bg-secondary);
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            overflow: hidden;
            max-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }
        
        .panel-header:hover {
            background: var(--bg-hover);
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 15px;
        }
        
        .panel-title-icon {
            width: 22px;
            height: 22px;
            background: var(--accent-color);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .panel-actions {
            display: flex;
            gap: 6px;
        }
        
        .panel-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }
        
        .panel-action-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        /* æ¨¡å‹åˆ—è¡¨é¡¹ */
        .model-item {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            margin-bottom: 6px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }
        
        .model-item:hover {
            background: var(--bg-hover);
        }
        
        .model-item.selected {
            border-color: var(--accent-color);
            background: var(--accent-light);
        }
        
        .model-item-icon {
            width: 36px;
            height: 36px;
            margin-right: 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .model-item-info {
            flex: 1;
            min-width: 0;
        }
        
        .model-item-name {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .model-item-type {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        
        .model-item-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .model-item:hover .model-item-actions {
            opacity: 1;
        }
        
        .model-action-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s;
        }
        
        .model-action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .model-action-btn.hidden-state {
            color: var(--text-secondary);
            opacity: 0.5;
        }
        
        .model-action-btn.delete:hover {
            background: var(--danger-color);
            color: white;
        }
        
        /* å˜æ¢é¢æ¿ */
        .transform-section {
            margin-top: 12px;
            padding: 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .transform-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-color);
        }
        
        .transform-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .transform-label {
            width: 50px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .transform-inputs {
            display: flex;
            gap: 6px;
            flex: 1;
        }
        
        .transform-input-group {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .transform-axis-label {
            width: 18px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }
        
        .transform-axis-label.x { color: #f87171; }
        .transform-axis-label.y { color: #4ade80; }
        .transform-axis-label.z { color: #60a5fa; }
        
        .transform-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            text-align: right;
        }
        
        .transform-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-light);
        }
        
        /* å³ä¾§å·¥å…·æ  */
        #right-toolbar {
            position: absolute;
            top: 50%;
            right: 14px;
            transform: translateY(-50%);
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }
        
        .toolbar-divider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
        }
        
        .tool-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .tool-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .tool-btn.active {
            background: var(--accent-color);
            color: white;
        }
        
        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .tool-btn[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            right: 54px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1001;
            box-shadow: 0 2px 12px rgba(0,0,0,0.4);
            border: 1px solid var(--border-color);
        }

        /* åº•éƒ¨å·¥å…·æ  */
        #bottom-toolbar {
            position: absolute;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px 16px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }
        
        .bottom-tool-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .bottom-divider {
            width: 1px;
            height: 32px;
            background: var(--border-color);
            margin: 0 6px;
        }
        
        .bottom-btn {
            width: 38px;
            height: 38px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }
        
        .bottom-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .bottom-btn.active {
            background: var(--accent-color);
            color: white;
        }
        
        .bottom-btn[data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 52px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1001;
            border: 1px solid var(--border-color);
        }
        
        /* å³ä¸Šè§’3Dåæ ‡è½´æŒ‡ç¤ºå™¨ */
        #axis-indicator {
            position: absolute;
            top: 14px;
            right: 80px;
            width: 100px;
            height: 100px;
            z-index: 1000;
            pointer-events: none;
        }
        
        #axis-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* åº•éƒ¨çŠ¶æ€æ  */
        #status-bar {
            position: absolute;
            bottom: 14px;
            right: 14px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px 16px;
            border-radius: 8px;
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-value {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* åŠ è½½é®ç½© */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 18, 24, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        #loading-overlay.hidden {
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--bg-tertiary);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading-text {
            color: var(--text-secondary);
            font-size: 15px;
        }
        
        /* é€‰æ‹©æ¡†è¦†ç›–å±‚ */
        #selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }
        
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-color);
            background: var(--accent-light);
            pointer-events: none;
        }
        
        /* ç¬”åˆ·å…‰æ ‡ */
        #brush-cursor {
            position: fixed;
            left: 0;
            top: 0;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 501;
            display: none;
            will-change: transform;
            background: var(--accent-light);
        }
        
        /* å˜æ¢æ¨¡å¼æŒ‡ç¤ºå™¨ */
        #transform-mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 15px;
            color: var(--accent-color);
            display: none;
            z-index: 999;
            pointer-events: none;
            border: 1px solid var(--border-color);
            font-weight: 500;
        }
        
        #transform-mode-indicator.visible {
            display: block;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }
        
        /* å¿«æ·é”®é¢æ¿ */
        #shortcuts-panel {
            position: absolute;
            bottom: 70px;
            right: 14px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 10px;
            display: none;
            min-width: 220px;
            border: 1px solid var(--border-color);
        }
        
        #shortcuts-panel.visible {
            display: block;
        }
        
        .shortcuts-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 13px;
        }
        
        .shortcut-key {
            color: var(--accent-color);
            font-family: monospace;
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* ç©ºçŠ¶æ€æç¤º */
        .empty-state {
            text-align: center;
            padding: 30px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 42px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        
        .empty-state-text {
            font-size: 13px;
            line-height: 1.6;
        }
        
        /* æ¸²æŸ“æ¨¡å¼é€‰æ‹©å™¨ */
        .render-mode-select {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }
        
        .render-mode-select:hover {
            border-color: var(--accent-color);
        }
        
        .render-mode-select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-light);
        }
        
        /* ç‚¹äº‘å åŠ æ§åˆ¶ */
        .overlay-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
        }
        
        .overlay-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-color);
            cursor: pointer;
        }
        
        .overlay-control label {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="loading-overlay" class="hidden">
        <div class="spinner"></div>
        <div id="loading-text">åŠ è½½ä¸­...</div>
    </div>

    <!-- å·¦ä¾§åœºæ™¯ç®¡ç†å™¨é¢æ¿ -->
    <div id="scene-manager-panel">
        <div class="panel-header" onclick="togglePanel('scene-manager')">
            <div class="panel-title">
                <div class="panel-title-icon">ğŸ“¦</div>
                <span>åœºæ™¯ç®¡ç†å™¨</span>
            </div>
            <div class="panel-actions">
                <button class="panel-action-btn" onclick="event.stopPropagation(); addModelDialog()" title="æ·»åŠ æ¨¡å‹">â•</button>
                <button class="panel-action-btn" onclick="event.stopPropagation(); focusSelected()" title="èšç„¦é€‰ä¸­">ğŸ¯</button>
            </div>
        </div>
        <div class="panel-content" id="scene-manager-content">
            <div id="model-list">
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“­</div>
                    <div class="empty-state-text">æš‚æ— æ¨¡å‹<br>ç‚¹å‡» â• æ·»åŠ æ¨¡å‹</div>
                </div>
            </div>
        </div>
        
        <!-- å˜æ¢é¢æ¿ -->
        <div class="transform-section" id="transform-panel" style="display: none;">
            <div class="transform-section-header">
                <span>â•</span>
                <span>å˜æ¢</span>
            </div>
            <div class="transform-row">
                <span class="transform-label">ä½ç½®</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <span class="transform-axis-label x">X</span>
                        <input type="number" class="transform-input" id="pos-x" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label y">Y</span>
                        <input type="number" class="transform-input" id="pos-y" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label z">Z</span>
                        <input type="number" class="transform-input" id="pos-z" step="0.1" value="0" onchange="updateTransformFromInput('position')">
                    </div>
                </div>
            </div>
            <div class="transform-row">
                <span class="transform-label">æ—‹è½¬</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <span class="transform-axis-label x">X</span>
                        <input type="number" class="transform-input" id="rot-x" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label y">Y</span>
                        <input type="number" class="transform-input" id="rot-y" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                    <div class="transform-input-group">
                        <span class="transform-axis-label z">Z</span>
                        <input type="number" class="transform-input" id="rot-z" step="1" value="0" onchange="updateTransformFromInput('rotation')">
                    </div>
                </div>
            </div>
            <div class="transform-row">
                <span class="transform-label">ç¼©æ”¾</span>
                <div class="transform-inputs">
                    <div class="transform-input-group">
                        <input type="number" class="transform-input" id="scale-uniform" step="0.1" value="1" min="0.01" onchange="updateTransformFromInput('scale')">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- å³ä¾§å·¥å…·æ  -->
    <div id="right-toolbar">
        <button class="tool-btn" id="tool-select" data-tooltip="é€‰æ‹© (Q)" onclick="setTool('select')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
            </svg>
        </button>
        <button class="tool-btn active" id="tool-move-view" data-tooltip="ç§»åŠ¨è§†è§’ (V)" onclick="setTool('move')">ğŸ–ï¸</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="tool-box" data-tooltip="æ¡†é€‰ (B)" onclick="setTool('box')">â¬œ</button>
        <button class="tool-btn" id="tool-lasso" data-tooltip="å¥—ç´¢ (L)" onclick="setTool('lasso')">ã€°ï¸</button>
        <button class="tool-btn" id="tool-brush" data-tooltip="ç¬”åˆ· (P)" onclick="setTool('brush')">ğŸ–Œï¸</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="tool-translate" data-tooltip="ç§»åŠ¨ (G)" onclick="setTransformMode('translate')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20"/>
            </svg>
        </button>
        <button class="tool-btn" id="tool-rotate" data-tooltip="æ—‹è½¬ (R)" onclick="setTransformMode('rotate')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12a9 9 0 11-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                <path d="M21 3v5h-5"/>
            </svg>
        </button>
        <button class="tool-btn" id="tool-scale" data-tooltip="ç¼©æ”¾ (S)" onclick="setTransformMode('scale')">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 21l-6-6m6 6v-4m0 4h-4M3 3l6 6M3 3v4m0-4h4"/>
            </svg>
        </button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" id="btn-deselect" data-tooltip="å–æ¶ˆé€‰ä¸­ (Esc)" onclick="deselectAll()">âœ–ï¸</button>
        
        <div class="toolbar-divider"></div>
        
        <button class="tool-btn" data-tooltip="è®¾ç½®" onclick="toggleShortcuts()">âš™ï¸</button>
    </div>
    
    <!-- åº•éƒ¨å·¥å…·æ  -->
    <div id="bottom-toolbar">
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="æ’¤é”€" onclick="undo()">â†©ï¸</button>
            <button class="bottom-btn" data-tooltip="é‡åš" onclick="redo()">â†ªï¸</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="å…¨é€‰" onclick="selectAll()">â—»ï¸</button>
            <button class="bottom-btn" data-tooltip="åé€‰" onclick="selectInverse()">ğŸ”„</button>
            <button class="bottom-btn" data-tooltip="éšè—é€‰ä¸­" onclick="hideSelected()">ğŸ‘ï¸</button>
            <button class="bottom-btn" data-tooltip="æ˜¾ç¤ºå…¨éƒ¨" onclick="showAll()">ğŸ‘€</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" id="btn-grid" data-tooltip="ç½‘æ ¼" onclick="toggleGrid()">â–¦</button>
            <button class="bottom-btn" id="btn-axes" data-tooltip="åæ ‡è½´" onclick="toggleAxes()">âœ›</button>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <select class="render-mode-select" id="render-mode" onchange="setRenderMode(this.value)">
                <option value="splat">Splatæ¸²æŸ“</option>
                <option value="points">ç‚¹äº‘æ¸²æŸ“</option>
                <option value="centers">ä¸­å¿ƒç‚¹</option>
            </select>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="overlay-control">
            <input type="checkbox" class="overlay-checkbox" id="pointcloud-overlay" onchange="togglePointCloudOverlay(this.checked)">
            <label for="pointcloud-overlay">å åŠ ç‚¹äº‘</label>
        </div>
        
        <div class="bottom-divider"></div>
        
        <div class="bottom-tool-group">
            <button class="bottom-btn" data-tooltip="å¤ä½è§†è§’" onclick="resetCamera()">ğŸ </button>
            <button class="bottom-btn danger" data-tooltip="åˆ é™¤é€‰ä¸­" onclick="deleteSelected()" style="color: var(--danger-color);">ğŸ—‘ï¸</button>
        </div>
    </div>
    
    <!-- 3Dåæ ‡è½´æŒ‡ç¤ºå™¨ -->
    <div id="axis-indicator">
        <canvas id="axis-canvas"></canvas>
    </div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <div id="status-bar">
        <div class="status-item">
            <span>ç‚¹æ•°:</span>
            <span class="status-value" id="pointCount">0</span>
        </div>
        <div class="status-item">
            <span>é€‰ä¸­:</span>
            <span class="status-value" id="selectedCount">0</span>
        </div>
        <div class="status-item">
            <span>FPS:</span>
            <span class="status-value" id="fps">0</span>
        </div>
    </div>
    
    <!-- é€‰æ‹©æ¡†è¦†ç›–å±‚ -->
    <div id="selection-overlay"></div>
    
    <!-- ç¬”åˆ·å…‰æ ‡ -->
    <div id="brush-cursor"></div>
    
    <!-- å˜æ¢æ¨¡å¼æŒ‡ç¤ºå™¨ -->
    <div id="transform-mode-indicator"></div>
    
    <!-- å¿«æ·é”®é¢æ¿ -->
    <div id="shortcuts-panel">
        <div class="shortcuts-title">å¿«æ·é”®</div>
        <div class="shortcut-row"><span>æ¡†é€‰</span><span class="shortcut-key">B</span></div>
        <div class="shortcut-row"><span>å¥—ç´¢</span><span class="shortcut-key">L</span></div>
        <div class="shortcut-row"><span>ç¬”åˆ·</span><span class="shortcut-key">P</span></div>
        <div class="shortcut-row"><span>ç§»åŠ¨è§†è§’</span><span class="shortcut-key">V</span></div>
        <div class="shortcut-row"><span>ç§»åŠ¨æ¨¡å‹</span><span class="shortcut-key">G</span></div>
        <div class="shortcut-row"><span>æ—‹è½¬æ¨¡å‹</span><span class="shortcut-key">R</span></div>
        <div class="shortcut-row"><span>ç¼©æ”¾æ¨¡å‹</span><span class="shortcut-key">S</span></div>
        <div class="shortcut-row"><span>å–æ¶ˆé€‰ä¸­</span><span class="shortcut-key">Esc</span></div>
        <div class="shortcut-row"><span>å…¨é€‰</span><span class="shortcut-key">Ctrl+A</span></div>
        <div class="shortcut-row"><span>åˆ é™¤</span><span class="shortcut-key">Delete</span></div>
        <div class="shortcut-row"><span>æ’¤é”€</span><span class="shortcut-key">Ctrl+Z</span></div>
    </div>

    <!-- Qt WebChannel -->
    <script>
        if (typeof qt !== 'undefined' && qt.webChannelTransport) {
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            document.head.appendChild(script);
        }
    </script>
""

    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let scene = null;
        let camera = null;
        let renderer = null;
        let pyBridge = null;
        let isInitialized = false;
        
        // åœºæ™¯ç®¡ç†
        const sceneModels = new Map(); // id -> { viewer, mesh, name, type, visible, position, rotation, scale }
        let selectedModelId = null;
        let modelIdCounter = 0;
        
        // ç¼–è¾‘çŠ¶æ€
        let currentTool = 'move';  // 'select', 'move', 'box', 'lasso', 'brush'
        let transformMode = null;  // 'translate', 'rotate', 'scale'
        let renderMode = 'splat';
        
        // é€‰æ‹©çŠ¶æ€
        let selectedPointIndices = new Set();
        let hiddenPointIndices = new Set();
        let lockedPointIndices = new Set();
        
        // é€‰æ‹©æ“ä½œ
        let isSelecting = false;
        let selectionStart = null;
        let selectionPath = [];
        let brushSize = 30;
        
        // æ’¤é”€/é‡åšæ ˆ
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;
        
        // è¾…åŠ©å¯¹è±¡
        let infiniteGrid = null;
        let axesHelper = null;
        let pointCloudMesh = null;
        let highlightMesh = null;
        let pointCloudOverlayMesh = null;
        let showPointCloudOverlay = false;
        
        // TransformControls
        let transformControls = null;
        let transformHelper = null;
        
        // ç›¸æœºæ§åˆ¶
        let spherical = { radius: 15, phi: Math.PI / 4, theta: 0 };
        let target = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // åæ ‡è½´æŒ‡ç¤ºå™¨
        let axisScene = null;
        let axisCamera = null;
        let axisRenderer = null;
        
        // æ¶ˆæ¯é˜Ÿåˆ—
        const messageQueue = [];
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            const container = document.getElementById('container');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121218);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, 10);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // åˆ›å»ºæ— é™ç½‘æ ¼
            createInfiniteGrid();
            
            // æ·»åŠ åæ ‡è½´
            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // åˆå§‹åŒ–TransformControls
            initTransformControls();
            
            // åˆå§‹åŒ–åæ ‡è½´æŒ‡ç¤ºå™¨
            initAxisIndicator();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();
            
            // åˆå§‹åŒ–WebChannel
            initWebChannel();
            
            // æ›´æ–°ç›¸æœºä½ç½®
            updateCameraPosition();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
            
            isInitialized = true;
            
            // å¤„ç†é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                window.receiveMessageFromPython(msg);
            }
            
            // é€šçŸ¥Pythonåˆå§‹åŒ–å®Œæˆ
            sendToPython({ type: 'viewerReady' });
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // è®¾ç½®é»˜è®¤å·¥å…·çŠ¶æ€
            setTool('move');
        }
        
        // åˆ›å»ºæ— é™ç½‘æ ¼ï¼ˆç±»ä¼¼SuperSplaté£æ ¼ï¼‰
        function createInfiniteGrid() {
            const gridGroup = new THREE.Group();
            
            // å°ç½‘æ ¼ï¼ˆç»†çº¿ï¼‰
            const smallGridSize = 100;
            const smallGridDivisions = 100;
            const smallGrid = new THREE.GridHelper(smallGridSize, smallGridDivisions, 0x444466, 0x333344);
            smallGrid.material.opacity = 0.4;
            smallGrid.material.transparent = true;
            smallGrid.material.depthWrite = false;
            gridGroup.add(smallGrid);
            
            // å¤§ç½‘æ ¼ï¼ˆç²—çº¿ï¼Œæ¯10ä¸ªå•ä½ï¼‰
            const largeGrid = new THREE.GridHelper(smallGridSize, smallGridDivisions / 10, 0x555577, 0x555577);
            largeGrid.material.opacity = 0.6;
            largeGrid.material.transparent = true;
            largeGrid.material.depthWrite = false;
            largeGrid.position.y = 0.001; // ç¨å¾®æŠ¬é«˜é¿å…z-fighting
            gridGroup.add(largeGrid);
            
            // Xè½´çº¿ï¼ˆçº¢è‰²ï¼‰
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-smallGridSize/2, 0, 0),
                new THREE.Vector3(smallGridSize/2, 0, 0)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 2, depthWrite: false });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            xAxis.position.y = 0.002;
            gridGroup.add(xAxis);
            
            // Zè½´çº¿ï¼ˆè“è‰²ï¼‰
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -smallGridSize/2),
                new THREE.Vector3(0, 0, smallGridSize/2)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x4444ff, linewidth: 2, depthWrite: false });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            zAxis.position.y = 0.002;
            gridGroup.add(zAxis);
            
            infiniteGrid = gridGroup;
            scene.add(infiniteGrid);
        }
        
        // å˜æ¢æ§åˆ¶å™¨äº¤äº’çŠ¶æ€
        let isTransforming = false;
        let transformAxis = null;
        let transformStartPoint = new THREE.Vector3();
        let transformStartValue = null;
        let transformRaycaster = new THREE.Raycaster();
        let transformPlane = new THREE.Plane();
        let transformStartMouse = new THREE.Vector2();
        let transformStartRotation = new THREE.Euler();
        
        // å˜æ¢æ§åˆ¶å™¨ä¸“ç”¨åœºæ™¯
        let transformScene = null;
        
        // åˆå§‹åŒ–TransformControlsï¼ˆè‡ªå®šä¹‰å®ç°ï¼‰
        function initTransformControls() {
            // åˆ›å»ºå˜æ¢æ§åˆ¶å™¨ä¸“ç”¨åœºæ™¯
            transformScene = new THREE.Scene();
            
            // åˆ›å»ºå˜æ¢è¾…åŠ©å™¨ç»„
            transformHelper = new THREE.Group();
            transformHelper.visible = false;
            transformHelper.renderOrder = 99999; // ç¡®ä¿åœ¨æœ€ä¸Šå±‚æ¸²æŸ“
            transformScene.add(transformHelper);
        }
        
        // è®¾ç½®æè´¨ä¸ºå§‹ç»ˆåœ¨æœ€ä¸Šå±‚
        function setAlwaysOnTop(object) {
            object.traverse((child) => {
                if (child.material) {
                    // ç¡®ä¿æè´¨å§‹ç»ˆåœ¨æœ€ä¸Šå±‚æ¸²æŸ“
                    child.material.depthTest = false;
                    child.material.depthWrite = false;
                    child.material.transparent = true;
                    child.material.needsUpdate = true;
                    child.renderOrder = 99999;
                }
                child.renderOrder = 99999;
            });
            object.renderOrder = 99999;
        }
        
        // åˆ›å»ºç§»åŠ¨æ§åˆ¶å™¨
        function createTranslateHelper() {
            clearTransformHelper();
            
            const arrowLength = 2.5;
            const coneHeight = 0.4;
            const coneRadius = 0.12;
            const lineWidth = 0.04;
            
            // Xè½´ - çº¢è‰²
            const xGroup = createTranslateAxis(0xff4444, 'x', new THREE.Vector3(1, 0, 0), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(xGroup);
            
            // Yè½´ - ç»¿è‰²
            const yGroup = createTranslateAxis(0x44ff44, 'y', new THREE.Vector3(0, 1, 0), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(yGroup);
            
            // Zè½´ - è“è‰²
            const zGroup = createTranslateAxis(0x4488ff, 'z', new THREE.Vector3(0, 0, 1), arrowLength, coneHeight, coneRadius, lineWidth);
            transformHelper.add(zGroup);
            
            // å¹³é¢æ­£æ–¹å½¢çš„å¤§å°å’Œåç§»
            const planeSize = 0.5;
            const planeOffset = 0.8;  // ä»ä¸­å¿ƒåˆ°æ­£æ–¹å½¢ä¸­å¿ƒçš„è·ç¦»
            
            // XZå¹³é¢ï¼ˆçº¢è“å¹³é¢ï¼‰- ç»¿è‰²æ­£æ–¹å½¢ï¼Œä½äºXå’ŒZè½´äº¤ç‚¹å¤„
            const xzPlane = createTranslatePlane(0x44ff44, 'xz', planeSize);
            xzPlane.rotation.x = Math.PI / 2;
            xzPlane.position.set(planeOffset, 0, planeOffset);
            transformHelper.add(xzPlane);
            
            // XYå¹³é¢ï¼ˆçº¢ç»¿å¹³é¢ï¼‰- è“è‰²æ­£æ–¹å½¢ï¼Œä½äºXå’ŒYè½´äº¤ç‚¹å¤„
            const xyPlane = createTranslatePlane(0x4488ff, 'xy', planeSize);
            xyPlane.position.set(planeOffset, planeOffset, 0);
            transformHelper.add(xyPlane);
            
            // YZå¹³é¢ï¼ˆè“ç»¿å¹³é¢ï¼‰- çº¢è‰²æ­£æ–¹å½¢ï¼Œä½äºYå’ŒZè½´äº¤ç‚¹å¤„
            const yzPlane = createTranslatePlane(0xff4444, 'yz', planeSize);
            yzPlane.rotation.y = Math.PI / 2;
            yzPlane.position.set(0, planeOffset, planeOffset);
            transformHelper.add(yzPlane);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createTranslateAxis(color, axis, direction, length, coneHeight, coneRadius, lineWidth) {
            const group = new THREE.Group();
            group.userData.axis = axis;
            group.userData.type = 'translate';
            
            // åœ†æŸ±ä½“ä½œä¸ºè½´çº¿
            const cylinderGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, length - coneHeight, 8);
            const cylinderMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.copy(direction.clone().multiplyScalar((length - coneHeight) / 2));
            
            // æ—‹è½¬åœ†æŸ±ä½“ä½¿å…¶æ²¿ç€æ­£ç¡®çš„è½´
            if (axis === 'x') cylinder.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cylinder.rotation.x = Math.PI / 2;
            
            group.add(cylinder);
            
            // åœ†é”¥ä½“ä½œä¸ºç®­å¤´
            const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.copy(direction.clone().multiplyScalar(length - coneHeight / 2));
            
            if (axis === 'x') cone.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cone.rotation.x = Math.PI / 2;
            
            group.add(cone);
            
            return group;
        }
        
        function createTranslatePlane(color, axes, size) {
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.userData.axes = axes;
            plane.userData.type = 'translate';
            return plane;
        }
        
        // åˆ›å»ºæ—‹è½¬æ§åˆ¶å™¨
        function createRotateHelper() {
            clearTransformHelper();
            
            const radius = 2.0;
            const tubeRadius = 0.04;
            
            // Xè½´æ—‹è½¬ç¯ - çº¢è‰²
            const xRing = createRotationRing(0xff4444, 'x', radius, tubeRadius);
            xRing.rotation.y = Math.PI / 2;
            transformHelper.add(xRing);
            
            // Yè½´æ—‹è½¬ç¯ - ç»¿è‰²
            const yRing = createRotationRing(0x44ff44, 'y', radius, tubeRadius);
            yRing.rotation.x = Math.PI / 2;
            transformHelper.add(yRing);
            
            // Zè½´æ—‹è½¬ç¯ - è“è‰²
            const zRing = createRotationRing(0x4488ff, 'z', radius, tubeRadius);
            transformHelper.add(zRing);
            
            // å¤–åœˆï¼ˆå±å¹•ç©ºé—´æ—‹è½¬ï¼‰- ç™½è‰²
            const outerRing = createRotationRing(0xaaaaaa, 'screen', radius * 1.15, tubeRadius * 0.8);
            transformHelper.add(outerRing);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createRotationRing(color, axis, radius, tubeRadius) {
            const geometry = new THREE.TorusGeometry(radius, tubeRadius, 8, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                depthTest: false,
                depthWrite: false
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.userData.axis = axis;
            ring.userData.type = 'rotate';
            return ring;
        }
        
        // åˆ›å»ºç¼©æ”¾æ§åˆ¶å™¨
        function createScaleHelper() {
            clearTransformHelper();
            
            const lineLength = 2.0;
            const boxSize = 0.2;
            const lineWidth = 0.04;
            
            // Xè½´ - çº¢è‰²
            const xLine = createScaleAxis(0xff4444, 'x', new THREE.Vector3(1, 0, 0), lineLength, boxSize, lineWidth);
            transformHelper.add(xLine);
            
            // Yè½´ - ç»¿è‰²
            const yLine = createScaleAxis(0x44ff44, 'y', new THREE.Vector3(0, 1, 0), lineLength, boxSize, lineWidth);
            transformHelper.add(yLine);
            
            // Zè½´ - è“è‰²
            const zLine = createScaleAxis(0x4488ff, 'z', new THREE.Vector3(0, 0, 1), lineLength, boxSize, lineWidth);
            transformHelper.add(zLine);
            
            // ä¸­å¿ƒç«‹æ–¹ä½“ï¼ˆç»Ÿä¸€ç¼©æ”¾ï¼‰
            const centerGeometry = new THREE.BoxGeometry(boxSize * 1.5, boxSize * 1.5, boxSize * 1.5);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                depthTest: false,
                depthWrite: false
            });
            const centerBox = new THREE.Mesh(centerGeometry, centerMaterial);
            centerBox.userData.axis = 'uniform';
            centerBox.userData.type = 'scale';
            transformHelper.add(centerBox);
            
            setAlwaysOnTop(transformHelper);
            transformHelper.visible = true;
        }
        
        function createScaleAxis(color, axis, direction, length, boxSize, lineWidth) {
            const group = new THREE.Group();
            group.userData.axis = axis;
            group.userData.type = 'scale';
            
            // åœ†æŸ±ä½“ä½œä¸ºè½´çº¿
            const cylinderGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, length - boxSize, 8);
            const cylinderMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.copy(direction.clone().multiplyScalar((length - boxSize) / 2));
            
            if (axis === 'x') cylinder.rotation.z = -Math.PI / 2;
            else if (axis === 'z') cylinder.rotation.x = Math.PI / 2;
            
            group.add(cylinder);
            
            // ç«‹æ–¹ä½“ä½œä¸ºç«¯ç‚¹
            const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const boxMaterial = new THREE.MeshBasicMaterial({ color: color, depthTest: false, depthWrite: false });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.copy(direction.clone().multiplyScalar(length - boxSize / 2));
            group.add(box);
            
            return group;
        }
        
        function clearTransformHelper() {
            while (transformHelper.children.length > 0) {
                const child = transformHelper.children[0];
                transformHelper.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            transformHelper.visible = false;
            isTransforming = false;
            transformAxis = null;
        }
        
        // æ›´æ–°å˜æ¢æ§åˆ¶å™¨ä½ç½®
        function updateTransformHelperPosition() {
            if (!selectedModelId || !transformHelper.visible) return;
            
            const model = sceneModels.get(selectedModelId);
            if (model && model.mesh) {
                // ä½¿ç”¨æ¨¡å‹çš„å®é™…ä½ç½®ï¼ˆè€Œä¸æ˜¯è¾¹ç•Œæ¡†ä¸­å¿ƒï¼‰
                transformHelper.position.copy(model.mesh.position);
                
                // åŒæ­¥æ¨¡å‹çš„æ—‹è½¬åˆ°æ§åˆ¶å™¨
                transformHelper.rotation.copy(model.mesh.rotation);
                
                // æ ¹æ®ç›¸æœºè·ç¦»è°ƒæ•´æ§åˆ¶å™¨å¤§å°
                const distance = camera.position.distanceTo(model.mesh.position);
                const scale = distance * 0.15;
                transformHelper.scale.setScalar(Math.max(0.5, Math.min(scale, 3)));
            }
        }
        
        // æ£€æµ‹å˜æ¢æ§åˆ¶å™¨çš„ç‚¹å‡»
        function checkTransformHelperIntersection(mouseX, mouseY) {
            if (!transformHelper.visible || !selectedModelId) return null;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((mouseX - rect.left) / rect.width) * 2 - 1,
                -((mouseY - rect.top) / rect.height) * 2 + 1
            );
            
            transformRaycaster.setFromCamera(mouse, camera);
            
            const intersects = transformRaycaster.intersectObjects(transformHelper.children, true);
            
            if (intersects.length > 0) {
                // æ‰¾åˆ°å¸¦æœ‰axisæˆ–axeså±æ€§çš„å¯¹è±¡
                let obj = intersects[0].object;
                while (obj && !obj.userData.axis && !obj.userData.axes && obj.parent !== transformHelper) {
                    obj = obj.parent;
                }
                if (obj && (obj.userData.axis || obj.userData.axes)) {
                    return { axis: obj.userData.axis, axes: obj.userData.axes, point: intersects[0].point };
                }
            }
            return null;
        }
        
        // å¼€å§‹å˜æ¢
        function startTransform(axis, axes, point, mouseX, mouseY) {
            if (!selectedModelId) return;
            
            isTransforming = true;
            transformAxis = axis || axes;
            transformStartPoint.copy(point);
            
            const model = sceneModels.get(selectedModelId);
            if (model) {
                if (transformMode === 'translate') {
                    transformStartValue = { x: model.position.x, y: model.position.y, z: model.position.z };
                } else if (transformMode === 'rotate') {
                    transformStartValue = { x: model.rotation.x, y: model.rotation.y, z: model.rotation.z };
                    transformStartRotation.copy(model.mesh.rotation);
                    
                    // ä¿å­˜èµ·å§‹é¼ æ ‡ä½ç½®ï¼ˆç”¨äºtrackballæ—‹è½¬ï¼‰
                    const rect = renderer.domElement.getBoundingClientRect();
                    transformStartMouse.set(
                        ((mouseX - rect.left) / rect.width) * 2 - 1,
                        -((mouseY - rect.top) / rect.height) * 2 + 1
                    );
                } else if (transformMode === 'scale') {
                    transformStartValue = model.scale;
                }
            }
            
            // è®¾ç½®å˜æ¢å¹³é¢
            const normal = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            if (transformMode === 'translate') {
                if (axis === 'x') {
                    // Xè½´ç§»åŠ¨ï¼šé€‰æ‹©ä¸ç›¸æœºè§†çº¿æœ€å‚ç›´çš„å¹³é¢ï¼ˆYæˆ–Zï¼‰
                    normal.set(0, Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 0 : 1, 
                               Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 1 : 0);
                } else if (axis === 'y') {
                    // Yè½´ç§»åŠ¨ï¼šé€‰æ‹©ä¸ç›¸æœºè§†çº¿æœ€å‚ç›´çš„å¹³é¢ï¼ˆXæˆ–Zï¼‰
                    normal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 0 : 1, 0,
                               Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 1 : 0);
                } else if (axis === 'z') {
                    // Zè½´ç§»åŠ¨ï¼šé€‰æ‹©ä¸ç›¸æœºè§†çº¿æœ€å‚ç›´çš„å¹³é¢ï¼ˆXæˆ–Yï¼‰
                    normal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 0 : 1,
                               Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 1 : 0, 0);
                } else if (axes === 'xy') {
                    // XYå¹³é¢ï¼ˆçº¢ç»¿å¹³é¢ï¼‰- è“è‰²æ­£æ–¹å½¢
                    normal.set(0, 0, 1);
                } else if (axes === 'xz') {
                    // XZå¹³é¢ï¼ˆçº¢è“å¹³é¢ï¼‰- ç»¿è‰²æ­£æ–¹å½¢
                    normal.set(0, 1, 0);
                } else if (axes === 'yz') {
                    // YZå¹³é¢ï¼ˆè“ç»¿å¹³é¢ï¼‰- çº¢è‰²æ­£æ–¹å½¢
                    normal.set(1, 0, 0);
                }
            } else if (transformMode === 'rotate') {
                // æ—‹è½¬æ¨¡å¼ï¼šæ ¹æ®è½´è®¾ç½®å¹³é¢
                if (axis === 'x') {
                    normal.set(1, 0, 0);
                } else if (axis === 'y') {
                    normal.set(0, 1, 0);
                } else if (axis === 'z') {
                    normal.set(0, 0, 1);
                } else if (axis === 'screen') {
                    // è‡ªç”±æ—‹è½¬ï¼ˆtrackballï¼‰ï¼šä½¿ç”¨é¢å‘ç›¸æœºçš„å¹³é¢
                    normal.copy(cameraDir);
                }
            } else {
                // å¯¹äºç¼©æ”¾ï¼Œä½¿ç”¨é¢å‘ç›¸æœºçš„å¹³é¢
                normal.copy(cameraDir);
            }
            
            transformPlane.setFromNormalAndCoplanarPoint(normal, transformHelper.position);
            
            // ç¦ç”¨è½¨é“æ§åˆ¶
            renderer.domElement.style.cursor = 'grabbing';
        }
        
        // æ›´æ–°å˜æ¢
        function updateTransform(mouseX, mouseY) {
            if (!isTransforming || !selectedModelId || !transformAxis) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((mouseX - rect.left) / rect.width) * 2 - 1,
                -((mouseY - rect.top) / rect.height) * 2 + 1
            );
            
            transformRaycaster.setFromCamera(mouse, camera);
            
            const intersectPoint = new THREE.Vector3();
            if (!transformRaycaster.ray.intersectPlane(transformPlane, intersectPoint)) return;
            
            const delta = intersectPoint.clone().sub(transformStartPoint);
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            if (transformMode === 'translate') {
                // ç§»åŠ¨æ¨¡å¼ï¼šæ ¹æ®è½´å‘çº¦æŸdelta
                if (transformAxis === 'x') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'y') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'z') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z + delta.z;
                } else if (transformAxis === 'xy') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z;
                } else if (transformAxis === 'xz') {
                    model.position.x = transformStartValue.x + delta.x;
                    model.position.y = transformStartValue.y;
                    model.position.z = transformStartValue.z + delta.z;
                } else if (transformAxis === 'yz') {
                    model.position.x = transformStartValue.x;
                    model.position.y = transformStartValue.y + delta.y;
                    model.position.z = transformStartValue.z + delta.z;
                }
                model.mesh.position.set(model.position.x, model.position.y, model.position.z);
            } else if (transformMode === 'rotate') {
                if (transformAxis === 'screen') {
                    // è‡ªç”±æ—‹è½¬ï¼ˆtrackballæ¨¡å¼ï¼‰
                    const currentMouse = new THREE.Vector2(
                        ((mouseX - rect.left) / rect.width) * 2 - 1,
                        -((mouseY - rect.top) / rect.height) * 2 + 1
                    );
                    
                    const deltaX = currentMouse.x - transformStartMouse.x;
                    const deltaY = currentMouse.y - transformStartMouse.y;
                    
                    // è®¡ç®—æ—‹è½¬è½´ï¼ˆå‚ç›´äºé¼ æ ‡ç§»åŠ¨æ–¹å‘ï¼‰
                    const rotationAxis = new THREE.Vector3(-deltaY, deltaX, 0).normalize();
                    const rotationAngle = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * Math.PI * 2;
                    
                    // å°†æ—‹è½¬è½´è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´
                    const cameraRotation = new THREE.Matrix4().extractRotation(camera.matrixWorld);
                    rotationAxis.applyMatrix4(cameraRotation);
                    
                    // åº”ç”¨æ—‹è½¬
                    const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);
                    const startQuaternion = new THREE.Quaternion().setFromEuler(transformStartRotation);
                    const newQuaternion = quaternion.multiply(startQuaternion);
                    
                    model.mesh.quaternion.copy(newQuaternion);
                    model.rotation.x = model.mesh.rotation.x;
                    model.rotation.y = model.mesh.rotation.y;
                    model.rotation.z = model.mesh.rotation.z;
                } else {
                    // çº¦æŸæ—‹è½¬ï¼ˆç»•å•ä¸ªè½´ï¼‰
                    // è®¡ç®—é¼ æ ‡åœ¨æ—‹è½¬å¹³é¢ä¸Šçš„æŠ•å½±
                    const currentPoint = new THREE.Vector3();
                    if (transformRaycaster.ray.intersectPlane(transformPlane, currentPoint)) {
                        // è®¡ç®—ä»ä¸­å¿ƒåˆ°èµ·å§‹ç‚¹å’Œå½“å‰ç‚¹çš„å‘é‡
                        const center = transformHelper.position;
                        const startVec = transformStartPoint.clone().sub(center).normalize();
                        const currentVec = currentPoint.clone().sub(center).normalize();
                        
                        // è®¡ç®—æ—‹è½¬è§’åº¦
                        let angle = Math.acos(Math.max(-1, Math.min(1, startVec.dot(currentVec))));
                        
                        // ç¡®å®šæ—‹è½¬æ–¹å‘
                        const axis = new THREE.Vector3();
                        if (transformAxis === 'x') axis.set(1, 0, 0);
                        else if (transformAxis === 'y') axis.set(0, 1, 0);
                        else if (transformAxis === 'z') axis.set(0, 0, 1);
                        
                        const cross = new THREE.Vector3().crossVectors(startVec, currentVec);
                        if (cross.dot(axis) < 0) angle = -angle;
                        
                        // åº”ç”¨æ—‹è½¬
                        if (transformAxis === 'x') {
                            model.rotation.x = transformStartValue.x + angle;
                        } else if (transformAxis === 'y') {
                            model.rotation.y = transformStartValue.y + angle;
                        } else if (transformAxis === 'z') {
                            model.rotation.z = transformStartValue.z + angle;
                        }
                        
                        model.mesh.rotation.set(model.rotation.x, model.rotation.y, model.rotation.z);
                    }
                }
            } else if (transformMode === 'scale') {
                // ç¼©æ”¾æ¨¡å¼ï¼šä½¿ç”¨è·ç¦»å˜åŒ–æ¥è®¡ç®—ç¼©æ”¾
                const startDist = transformStartPoint.distanceTo(transformHelper.position);
                const currentDist = intersectPoint.distanceTo(transformHelper.position);
                const scaleFactor = startDist > 0.001 ? currentDist / startDist : 1;
                
                if (transformAxis === 'uniform' || transformAxis === 'x' || transformAxis === 'y' || transformAxis === 'z') {
                    model.scale = Math.max(0.01, transformStartValue * scaleFactor);
                    model.mesh.scale.setScalar(model.scale);
                }
            }
            
            updateTransformInputs();
            updateTransformHelperPosition();
        }
        
        // ç»“æŸå˜æ¢
        function endTransform() {
            if (isTransforming && selectedModelId) {
                const model = sceneModels.get(selectedModelId);
                if (model) {
                    sendToPython({
                        type: 'modelTransformed',
                        data: {
                            id: selectedModelId,
                            position: model.position,
                            rotation: model.rotation,
                            scale: model.scale
                        }
                    });
                }
            }
            isTransforming = false;
            transformAxis = null;
            
            // æ¢å¤å…‰æ ‡
            renderer.domElement.style.cursor = 'default';
        }

        // åˆå§‹åŒ–åæ ‡è½´æŒ‡ç¤ºå™¨
        function initAxisIndicator() {
            const canvas = document.getElementById('axis-canvas');
            
            axisScene = new THREE.Scene();
            axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            axisCamera.position.set(0, 0, 3);
            
            axisRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            axisRenderer.setSize(100, 100);
            axisRenderer.setClearColor(0x000000, 0);
            
            // åˆ›å»ºåæ ‡è½´
            const axisLength = 0.8;
            
            // Xè½´ - çº¢è‰²
            const xAxis = createAxisArrow(0xff4444, new THREE.Vector3(axisLength, 0, 0), 'X');
            axisScene.add(xAxis);
            
            // Yè½´ - ç»¿è‰²
            const yAxis = createAxisArrow(0x44ff44, new THREE.Vector3(0, axisLength, 0), 'Y');
            axisScene.add(yAxis);
            
            // Zè½´ - è“è‰²
            const zAxis = createAxisArrow(0x4488ff, new THREE.Vector3(0, 0, axisLength), 'Z');
            axisScene.add(zAxis);
        }
        
        function createAxisArrow(color, direction, label) {
            const group = new THREE.Group();
            
            // è½´çº¿
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                direction
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);
            
            // ç®­å¤´
            const arrowGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: color });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.copy(direction);
            
            if (direction.x !== 0) arrow.rotation.z = -Math.PI / 2;
            else if (direction.z !== 0) arrow.rotation.x = Math.PI / 2;
            
            group.add(arrow);
            
            return group;
        }
        
        function updateAxisIndicator() {
            if (!axisCamera || !camera) return;
            
            const quaternion = camera.quaternion.clone();
            axisCamera.position.set(0, 0, 3);
            axisCamera.position.applyQuaternion(quaternion.invert());
            axisCamera.lookAt(0, 0, 0);
            
            axisRenderer.render(axisScene, axisCamera);
        }
    </script>

    <script>
        // ==================== åœºæ™¯ç®¡ç†å™¨ ====================
        function addModel(url, name, type = 'splat') {
            const id = 'model_' + (++modelIdCounter);
            
            const modelData = {
                id: id,
                name: name || `æ¨¡å‹ ${modelIdCounter}`,
                type: type,
                url: url,
                visible: true,
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1,
                viewer: null,
                mesh: null,
                pointCount: 0
            };
            
            sceneModels.set(id, modelData);
            updateModelList();
            
            return id;
        }
        
        function loadModelToScene(id, url) {
            const modelData = sceneModels.get(id);
            if (!modelData) return;
            
            showLoading('æ­£åœ¨åŠ è½½æ¨¡å‹...');
            
            // åŠ è½½3DGSæ¨¡å‹
            if (typeof GaussianSplats3D !== 'undefined') {
                const splatConfig = {
                    selfDrivenMode: false,
                    renderer: renderer,
                    camera: camera,
                    useBuiltInControls: false,
                    ignoreDevicePixelRatio: true,
                    gpuAcceleratedSort: false,
                    sharedMemoryForWorkers: false,
                    enableSIMDInSort: false,
                    integerBasedSort: false,
                    halfPrecisionCovariancesOnGPU: false,
                    dynamicScene: false,
                    sceneRevealMode: GaussianSplats3D.SceneRevealMode ? GaussianSplats3D.SceneRevealMode.Instant : 0,
                    logLevel: GaussianSplats3D.LogLevel ? GaussianSplats3D.LogLevel.None : 0,
                    sphericalHarmonicsDegree: 0
                };
                
                const viewer = new GaussianSplats3D.Viewer(splatConfig);
                
                viewer.addSplatScene(url, {
                    splatAlphaRemovalThreshold: 1,
                    showLoadingUI: false,
                    position: [modelData.position.x, modelData.position.y, modelData.position.z],
                    rotation: [0, 0, 0, 1],
                    scale: [modelData.scale, modelData.scale, modelData.scale]
                }).then(() => {
                    modelData.viewer = viewer;
                    modelData.mesh = viewer.splatMesh;
                    
                    // å»¶è¿Ÿè·å–ç‚¹æ•°ï¼Œç¡®ä¿æ¨¡å‹å®Œå…¨åŠ è½½
                    const tryGetSplatCount = () => {
                        if (viewer.getSplatCount) {
                            const count = viewer.getSplatCount();
                            if (count > 0) {
                                modelData.pointCount = count;
                                updateModelList();
                                updatePointCount();
                                console.log(`[ThreeJS Info] æ¨¡å‹ ${modelData.name} ç‚¹æ•°: ${count}`);
                                return;
                            }
                        }
                        // å¦‚æœç‚¹æ•°ä¸º0ï¼Œç¨åé‡è¯•
                        setTimeout(tryGetSplatCount, 100);
                    };
                    
                    // å…ˆè®¾ç½®åˆå§‹å€¼ï¼Œç„¶åå°è¯•è·å–çœŸå®ç‚¹æ•°
                    modelData.pointCount = viewer.getSplatCount ? viewer.getSplatCount() : 0;
                    setTimeout(tryGetSplatCount, 200);
                    
                    scene.add(viewer.splatMesh);
                    
                    hideLoading();
                    updateModelList();
                    updatePointCount();
                    
                    // è‡ªåŠ¨é€‰ä¸­æ–°åŠ è½½çš„æ¨¡å‹
                    selectModel(id);
                    
                    sendToPython({
                        type: 'modelLoaded',
                        success: true,
                        data: { id: id, pointCount: modelData.pointCount }
                    });
                }).catch(error => {
                    console.error('[ThreeJS Error] åŠ è½½æ¨¡å‹å¤±è´¥:', error);
                    hideLoading();
                    sceneModels.delete(id);
                    updateModelList();
                    
                    sendToPython({
                        type: 'modelLoaded',
                        success: false,
                        error: error.message
                    });
                });
            }
        }
        
        function selectModel(id) {
            selectedModelId = id;
            
            // æ›´æ–°UI
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            const modelItem = document.querySelector(`[data-model-id="${id}"]`);
            if (modelItem) {
                modelItem.classList.add('selected');
            }
            
            // æ˜¾ç¤ºå˜æ¢é¢æ¿
            const transformPanel = document.getElementById('transform-panel');
            if (id) {
                transformPanel.style.display = 'block';
                updateTransformInputs();
                
                // å¦‚æœæœ‰å˜æ¢æ¨¡å¼ï¼Œæ˜¾ç¤ºæ§åˆ¶å™¨
                if (transformMode) {
                    updateTransformHelperPosition();
                }
            } else {
                transformPanel.style.display = 'none';
                clearTransformHelper();
            }
            
            sendToPython({
                type: 'modelSelected',
                data: { id: id }
            });
        }
        
        function deselectAll() {
            selectedModelId = null;
            selectedPointIndices.clear();
            
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            document.getElementById('transform-panel').style.display = 'none';
            clearTransformHelper();
            
            // æ¸…é™¤é«˜äº®
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
            
            updateSelectionDisplay();
            
            sendToPython({ type: 'deselected' });
        }
        
        function toggleModelVisibility(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            model.visible = !model.visible;
            
            if (model.mesh) {
                model.mesh.visible = model.visible;
            }
            
            updateModelList();
        }
        
        function deleteModel(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            if (model.mesh) {
                scene.remove(model.mesh);
            }
            
            if (model.viewer && model.viewer.dispose) {
                model.viewer.dispose();
            }
            
            sceneModels.delete(id);
            
            if (selectedModelId === id) {
                deselectAll();
            }
            
            updateModelList();
            updatePointCount();
            
            sendToPython({
                type: 'modelDeleted',
                data: { id: id }
            });
        }
        
        function updateModelList() {
            const listContainer = document.getElementById('model-list');
            
            if (sceneModels.size === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ğŸ“­</div>
                        <div class="empty-state-text">æš‚æ— æ¨¡å‹<br>ç‚¹å‡» â• æ·»åŠ æ¨¡å‹</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            sceneModels.forEach((model, id) => {
                const isSelected = id === selectedModelId;
                const visibilityIcon = model.visible ? 'ğŸ‘ï¸' : 'ğŸ‘ï¸â€ğŸ—¨ï¸';
                const visibilityClass = model.visible ? '' : 'hidden-state';
                
                html += `
                    <div class="model-item ${isSelected ? 'selected' : ''}" data-model-id="${id}" onclick="selectModel('${id}')">
                        <div class="model-item-icon">ğŸ¨</div>
                        <div class="model-item-info">
                            <div class="model-item-name">${model.name}</div>
                        </div>
                        <div class="model-item-actions">
                            <button class="model-action-btn ${visibilityClass}" onclick="event.stopPropagation(); toggleModelVisibility('${id}')" title="æ˜¾ç¤º/éšè—">
                                ${visibilityIcon}
                            </button>
                            <button class="model-action-btn delete" onclick="event.stopPropagation(); confirmDeleteModel('${id}')" title="åˆ é™¤">
                                ğŸ—‘ï¸
                            </button>
                        </div>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        function confirmDeleteModel(id) {
            const model = sceneModels.get(id);
            if (!model) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤æ¨¡å‹ "${model.name}" å—ï¼Ÿ`)) {
                deleteModel(id);
            }
        }
        
        function addModelDialog() {
            sendToPython({ type: 'requestAddModel' });
        }
        
        function focusSelected() {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            const box = new THREE.Box3().setFromObject(model.mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            target.copy(center);
            spherical.radius = Math.max(size.x, size.y, size.z) * 2;
            
            updateCameraPosition();
        }
        
        function updateTransformInputs() {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model) return;
            
            document.getElementById('pos-x').value = model.position.x.toFixed(3);
            document.getElementById('pos-y').value = model.position.y.toFixed(3);
            document.getElementById('pos-z').value = model.position.z.toFixed(3);
            
            document.getElementById('rot-x').value = (model.rotation.x * 180 / Math.PI).toFixed(2);
            document.getElementById('rot-y').value = (model.rotation.y * 180 / Math.PI).toFixed(2);
            document.getElementById('rot-z').value = (model.rotation.z * 180 / Math.PI).toFixed(2);
            
            document.getElementById('scale-uniform').value = model.scale.toFixed(3);
        }
        
        function updateTransformFromInput(type) {
            if (!selectedModelId) return;
            
            const model = sceneModels.get(selectedModelId);
            if (!model || !model.mesh) return;
            
            if (type === 'position') {
                model.position.x = parseFloat(document.getElementById('pos-x').value) || 0;
                model.position.y = parseFloat(document.getElementById('pos-y').value) || 0;
                model.position.z = parseFloat(document.getElementById('pos-z').value) || 0;
                
                model.mesh.position.set(model.position.x, model.position.y, model.position.z);
            } else if (type === 'rotation') {
                model.rotation.x = (parseFloat(document.getElementById('rot-x').value) || 0) * Math.PI / 180;
                model.rotation.y = (parseFloat(document.getElementById('rot-y').value) || 0) * Math.PI / 180;
                model.rotation.z = (parseFloat(document.getElementById('rot-z').value) || 0) * Math.PI / 180;
                
                model.mesh.rotation.set(model.rotation.x, model.rotation.y, model.rotation.z);
            } else if (type === 'scale') {
                model.scale = parseFloat(document.getElementById('scale-uniform').value) || 1;
                model.mesh.scale.setScalar(model.scale);
            }
            
            updateTransformHelperPosition();
            
            sendToPython({
                type: 'modelTransformed',
                data: {
                    id: selectedModelId,
                    position: model.position,
                    rotation: model.rotation,
                    scale: model.scale
                }
            });
        }
        
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }
        
        function togglePanel(panelId) {
            const content = document.getElementById(panelId + '-content');
            if (content) {
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            }
        }

        // ==================== äº‹ä»¶ç›‘å¬ ====================
        function setupEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }
        
        function onMouseDown(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å˜æ¢æ§åˆ¶å™¨
            if (transformMode && transformHelper.visible && e.button === 0) {
                const hit = checkTransformHelperIntersection(e.clientX, e.clientY);
                if (hit) {
                    startTransform(hit.axis, hit.axes, hit.point, e.clientX, e.clientY);
                    return;
                }
            }
            
            if (currentTool === 'move' || e.button === 2 || e.button === 1) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else if (currentTool === 'box' || currentTool === 'lasso' || currentTool === 'brush') {
                if (e.button === 0) {
                    isSelecting = true;
                    selectionStart = { x, y };
                    selectionPath = [{ x, y }];
                    
                    if (currentTool === 'box') {
                        createSelectionBox(x, y, 0, 0);
                    }
                }
            }
        }
        
        let lastMouseMoveTime = 0;
        const MOUSE_MOVE_THROTTLE = 8;
        
        function onMouseMove(e) {
            const now = performance.now();
            
            if (now - lastMouseMoveTime < MOUSE_MOVE_THROTTLE && !isDragging && !isTransforming) {
                return;
            }
            lastMouseMoveTime = now;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // å¤„ç†å˜æ¢æ§åˆ¶å™¨æ‹–æ‹½
            if (isTransforming) {
                updateTransform(e.clientX, e.clientY);
                return;
            }
            
            // æ›´æ–°ç¬”åˆ·å…‰æ ‡
            if (currentTool === 'brush') {
                const cursor = document.getElementById('brush-cursor');
                cursor.style.display = 'block';
                cursor.style.transform = `translate(${e.clientX - brushSize}px, ${e.clientY - brushSize}px)`;
                cursor.style.width = (brushSize * 2) + 'px';
                cursor.style.height = (brushSize * 2) + 'px';
            } else {
                document.getElementById('brush-cursor').style.display = 'none';
            }
            
            // é«˜äº®å˜æ¢æ§åˆ¶å™¨
            if (transformMode && transformHelper.visible && !isDragging && !isSelecting) {
                const hit = checkTransformHelperIntersection(e.clientX, e.clientY);
                highlightTransformAxis(hit ? (hit.axis || hit.axes) : null);
            }
            
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (e.buttons === 2 || (e.buttons === 1 && currentTool === 'move')) {
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi + deltaY * 0.01));
                } else if (e.buttons === 4) {
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(up);
                    right.crossVectors(up, camera.up).normalize();
                    up.crossVectors(right, camera.getWorldDirection(new THREE.Vector3())).normalize();
                    
                    target.add(right.multiplyScalar(-deltaX * 0.01));
                    target.add(up.multiplyScalar(deltaY * 0.01));
                }
                
                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else if (isSelecting) {
                if (currentTool === 'box') {
                    const width = x - selectionStart.x;
                    const height = y - selectionStart.y;
                    updateSelectionBox(selectionStart.x, selectionStart.y, width, height);
                } else if (currentTool === 'lasso' || currentTool === 'brush') {
                    const lastPoint = selectionPath[selectionPath.length - 1];
                    const dist = Math.sqrt((x - lastPoint.x) ** 2 + (y - lastPoint.y) ** 2);
                    if (dist > 3) {
                        selectionPath.push({ x, y });
                        drawSelectionPath();
                    }
                }
            }
        }
        
        // é«˜äº®å˜æ¢æ§åˆ¶å™¨çš„è½´
        let highlightedAxis = null;
        function highlightTransformAxis(axis) {
            if (highlightedAxis === axis) return;
            highlightedAxis = axis;
            
            transformHelper.traverse((child) => {
                if (child.material && (child.userData.axis || child.userData.axes)) {
                    const isHighlighted = child.userData.axis === axis || child.userData.axes === axis;
                    if (isHighlighted) {
                        child.material.opacity = 1.0;
                        if (child.material.emissive) {
                            child.material.emissive.setHex(0x333333);
                        }
                    } else {
                        child.material.opacity = child.userData.type === 'rotate' ? 0.9 : 
                                                  (child.userData.axes ? 0.4 : 0.9);
                    }
                }
            });
            
            // æ›´æ–°å…‰æ ‡
            if (axis) {
                renderer.domElement.style.cursor = 'grab';
            } else if (transformMode) {
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        function onMouseUp(e) {
            // ç»“æŸå˜æ¢
            if (isTransforming) {
                endTransform();
                return;
            }
            
            if (isDragging) {
                isDragging = false;
            }
            
            if (isSelecting) {
                isSelecting = false;
                
                const shiftKey = e.shiftKey;
                const ctrlKey = e.ctrlKey;
                
                if (currentTool === 'box') {
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    selectByBox(selectionStart.x, selectionStart.y, x, y, shiftKey, ctrlKey);
                } else if (currentTool === 'lasso') {
                    selectByLasso(selectionPath, shiftKey, ctrlKey);
                } else if (currentTool === 'brush') {
                    selectByBrush(selectionPath, brushSize, shiftKey, ctrlKey);
                }
                
                clearSelectionOverlay();
            }
        }
        
        function onMouseWheel(e) {
            e.preventDefault();
            spherical.radius *= e.deltaY > 0 ? 1.1 : 0.9;
            spherical.radius = Math.max(1, Math.min(100, spherical.radius));
            updateCameraPosition();
        }
        
        function onKeyDown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'a':
                        e.preventDefault();
                        selectAll();
                        break;
                    case 'i':
                        e.preventDefault();
                        selectInverse();
                        break;
                    case 'z':
                        e.preventDefault();
                        undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                }
            } else if (e.shiftKey) {
                switch (e.key.toLowerCase()) {
                    case 'h':
                        e.preventDefault();
                        showAll();
                        break;
                }
            } else {
                switch (e.key.toLowerCase()) {
                    case 'q':
                        setTool('select');
                        break;
                    case 'b':
                        setTool('box');
                        break;
                    case 'l':
                        setTool('lasso');
                        break;
                    case 'p':
                        setTool('brush');
                        break;
                    case 'v':
                        setTool('move');
                        break;
                    case 'h':
                        hideSelected();
                        break;
                    case 'g':
                        setTransformMode('translate');
                        break;
                    case 'r':
                        setTransformMode('rotate');
                        break;
                    case 's':
                        if (!e.ctrlKey) setTransformMode('scale');
                        break;
                    case 'delete':
                    case 'backspace':
                        deleteSelected();
                        break;
                    case 'escape':
                        deselectAll();
                        break;
                }
            }
        }
        
        function onKeyUp(e) {}
        
        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // ==================== ç›¸æœºæ§åˆ¶ ====================
        function updateCameraPosition() {
            camera.position.x = target.x + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            camera.position.y = target.y + spherical.radius * Math.cos(spherical.phi);
            camera.position.z = target.z + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.lookAt(target);
            
        }
        
        function resetCamera() {
            spherical = { radius: 15, phi: Math.PI / 4, theta: 0 };
            target = new THREE.Vector3(0, 0, 0);
            updateCameraPosition();
        }
        
        // ==================== å·¥å…·åˆ‡æ¢ ====================
        function setTool(tool) {
            currentTool = tool;
            
            // æ¸…é™¤å˜æ¢æ¨¡å¼
            if (tool !== 'select') {
                transformMode = null;
                clearTransformHelper();
            }
            
            // æ›´æ–°UI
            document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolMap = {
                'select': 'tool-select',
                'move': 'tool-move-view',
                'box': 'tool-box',
                'lasso': 'tool-lasso',
                'brush': 'tool-brush'
            };
            
            const toolBtn = document.getElementById(toolMap[tool]);
            if (toolBtn) toolBtn.classList.add('active');
            
            // æ›´æ–°å…‰æ ‡
            if (tool === 'move') {
                renderer.domElement.style.cursor = 'grab';
            } else if (tool === 'brush') {
                renderer.domElement.style.cursor = 'none';
            } else if (tool === 'select') {
                renderer.domElement.style.cursor = 'default';
            } else {
                renderer.domElement.style.cursor = 'crosshair';
            }
            
            if (tool !== 'brush') {
                document.getElementById('brush-cursor').style.display = 'none';
            }
        }
        
        function setTransformMode(mode) {
            if (!selectedModelId) {
                showTransformModeIndicator('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¨¡å‹');
                return;
            }
            
            // åˆ‡æ¢æ¨¡å¼
            if (transformMode === mode) {
                transformMode = null;
                clearTransformHelper();
                
                document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                    if (btn.id.startsWith('tool-translate') || btn.id.startsWith('tool-rotate') || btn.id.startsWith('tool-scale')) {
                        btn.classList.remove('active');
                    }
                });
                return;
            }
            
            transformMode = mode;
            
            // æ›´æ–°UI
            document.querySelectorAll('#right-toolbar .tool-btn').forEach(btn => {
                if (btn.id.startsWith('tool-translate') || btn.id.startsWith('tool-rotate') || btn.id.startsWith('tool-scale')) {
                    btn.classList.remove('active');
                }
            });
            
            const modeBtn = document.getElementById('tool-' + mode);
            if (modeBtn) modeBtn.classList.add('active');
            
            // åˆ›å»ºå¯¹åº”çš„æ§åˆ¶å™¨
            if (mode === 'translate') {
                createTranslateHelper();
                showTransformModeIndicator('ç§»åŠ¨æ¨¡å¼ (G)');
            } else if (mode === 'rotate') {
                createRotateHelper();
                showTransformModeIndicator('æ—‹è½¬æ¨¡å¼ (R)');
            } else if (mode === 'scale') {
                createScaleHelper();
                showTransformModeIndicator('ç¼©æ”¾æ¨¡å¼ (S)');
            }
            
            updateTransformHelperPosition();
            
            sendToPython({
                type: 'transformModeChanged',
                data: { mode: mode }
            });
        }
        
        function showTransformModeIndicator(text) {
            const indicator = document.getElementById('transform-mode-indicator');
            indicator.textContent = text;
            indicator.classList.remove('visible');
            void indicator.offsetWidth; // è§¦å‘é‡æ’
            indicator.classList.add('visible');
            
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 2000);
        }

        // ==================== æ¸²æŸ“æ¨¡å¼ ====================
        function setRenderMode(mode) {
            renderMode = mode;
            
            sendToPython({
                type: 'renderModeChanged',
                data: { mode: mode }
            });
            
            updateRenderMode();
        }
        
        function updateRenderMode() {
            sceneModels.forEach((model, id) => {
                if (model.viewer && model.viewer.splatMesh) {
                    if (renderMode === 'splat') {
                        model.viewer.splatMesh.visible = model.visible;
                        if (pointCloudMesh) pointCloudMesh.visible = false;
                    } else {
                        model.viewer.splatMesh.visible = false;
                        if (pointCloudMesh) pointCloudMesh.visible = model.visible;
                    }
                }
            });
            
            // ç‚¹äº‘å åŠ 
            if (pointCloudOverlayMesh) {
                pointCloudOverlayMesh.visible = showPointCloudOverlay && renderMode === 'splat';
            }
        }
        
        function togglePointCloudOverlay(checked) {
            showPointCloudOverlay = checked;
            
            if (checked && renderMode === 'splat') {
                // è¯·æ±‚Pythonç«¯å‘é€ç‚¹äº‘æ•°æ®ç”¨äºå åŠ æ˜¾ç¤º
                sendToPython({
                    type: 'requestPointCloudOverlay',
                    data: {}
                });
            }
            
            if (pointCloudOverlayMesh) {
                pointCloudOverlayMesh.visible = checked && renderMode === 'splat';
            }
        }
        
        function createPointCloudOverlay(data) {
            const positions = data.positions;
            const colors = data.colors;
            
            if (!positions || positions.length === 0) return;
            
            // ç§»é™¤æ—§çš„å åŠ ç‚¹äº‘
            if (pointCloudOverlayMesh) {
                scene.remove(pointCloudOverlayMesh);
                if (pointCloudOverlayMesh.geometry) pointCloudOverlayMesh.geometry.dispose();
                if (pointCloudOverlayMesh.material) pointCloudOverlayMesh.material.dispose();
                pointCloudOverlayMesh = null;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            if (colors && colors.length > 0) {
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            }
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: colors && colors.length > 0,
                color: colors && colors.length > 0 ? undefined : 0x00ff00,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: false,
                depthTest: true,
                depthWrite: false
            });
            
            pointCloudOverlayMesh = new THREE.Points(geometry, material);
            pointCloudOverlayMesh.renderOrder = 100;
            pointCloudOverlayMesh.frustumCulled = false;
            scene.add(pointCloudOverlayMesh);
            
            pointCloudOverlayMesh.visible = showPointCloudOverlay && renderMode === 'splat';
        }
        
        function createPointCloudFromData(data) {
            const positions = data.positions;
            const colors = data.colors;
            
            if (!positions || positions.length === 0) return;
            
            if (pointCloudMesh) {
                scene.remove(pointCloudMesh);
                if (pointCloudMesh.geometry) pointCloudMesh.geometry.dispose();
                if (pointCloudMesh.material) pointCloudMesh.material.dispose();
                pointCloudMesh = null;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            if (colors && colors.length > 0) {
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
            }
            
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: colors && colors.length > 0,
                color: colors && colors.length > 0 ? undefined : 0x888888,
                transparent: false,
                sizeAttenuation: false,
                depthWrite: true,
                depthTest: true
            });
            
            pointCloudMesh = new THREE.Points(geometry, material);
            pointCloudMesh.frustumCulled = false;
            scene.add(pointCloudMesh);
            
            pointCloudMesh.visible = (renderMode !== 'splat');
        }
        
        function updateHighlightFromData(data) {
            const positions = data.positions;
            const boundingBox = data.boundingBox;
            
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
            
            if (!positions || positions.length === 0) return;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 4,
                transparent: true,
                opacity: 0.9,
                depthTest: false,
                depthWrite: false,
                sizeAttenuation: false
            });
            
            highlightMesh = new THREE.Points(geometry, material);
            highlightMesh.renderOrder = 999;
            highlightMesh.frustumCulled = false;
            scene.add(highlightMesh);
        }
        
        // ==================== é€‰æ‹©æ“ä½œ ====================
        let selectionBox = null;
        let selectionSvg = null;
        let selectionPathEl = null;
        let lastPathUpdate = 0;
        const PATH_UPDATE_INTERVAL = 16;
        
        function createSelectionBox(x, y, width, height) {
            const overlay = document.getElementById('selection-overlay');
            if (!selectionBox) {
                selectionBox = document.createElement('div');
                selectionBox.className = 'selection-box';
                overlay.appendChild(selectionBox);
            }
            selectionBox.style.left = x + 'px';
            selectionBox.style.top = y + 'px';
            selectionBox.style.width = Math.abs(width) + 'px';
            selectionBox.style.height = Math.abs(height) + 'px';
            selectionBox.style.display = 'block';
        }
        
        function updateSelectionBox(x, y, width, height) {
            if (selectionBox) {
                const left = width < 0 ? x + width : x;
                const top = height < 0 ? y + height : y;
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = Math.abs(width) + 'px';
                selectionBox.style.height = Math.abs(height) + 'px';
            }
        }
        
        function drawSelectionPath() {
            const now = performance.now();
            if (now - lastPathUpdate < PATH_UPDATE_INTERVAL) return;
            lastPathUpdate = now;
            
            if (selectionPath.length < 2) return;
            
            const overlay = document.getElementById('selection-overlay');
            
            if (!selectionSvg) {
                selectionSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                selectionSvg.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;pointer-events:none;';
                selectionPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                selectionSvg.appendChild(selectionPathEl);
                overlay.appendChild(selectionSvg);
            }
            
            const simplifyRate = Math.max(1, Math.floor(selectionPath.length / 200));
            let pathD = `M ${selectionPath[0].x} ${selectionPath[0].y}`;
            for (let i = simplifyRate; i < selectionPath.length; i += simplifyRate) {
                pathD += ` L ${selectionPath[i].x} ${selectionPath[i].y}`;
            }
            if (selectionPath.length > 1) {
                const last = selectionPath[selectionPath.length - 1];
                pathD += ` L ${last.x} ${last.y}`;
            }
            
            if (currentTool === 'lasso') pathD += ' Z';
            
            selectionPathEl.setAttribute('d', pathD);
            selectionPathEl.setAttribute('stroke', '#8b5cf6');
            selectionPathEl.setAttribute('stroke-width', currentTool === 'brush' ? Math.min(brushSize, 30) : '2');
            selectionPathEl.setAttribute('fill', currentTool === 'lasso' ? 'rgba(139, 92, 246, 0.15)' : 'none');
            selectionPathEl.setAttribute('stroke-dasharray', currentTool === 'lasso' ? '5,5' : 'none');
            selectionPathEl.setAttribute('stroke-linecap', 'round');
            selectionPathEl.setAttribute('stroke-linejoin', 'round');
        }
        
        function clearSelectionOverlay() {
            if (selectionBox) selectionBox.style.display = 'none';
            if (selectionSvg) selectionSvg.remove();
            selectionSvg = null;
            selectionPathEl = null;
        }
        
        // è·å–éšè—æ¨¡å‹çš„IDåˆ—è¡¨
        function getHiddenModelIds() {
            const hiddenIds = [];
            sceneModels.forEach((model, id) => {
                if (!model.visible) {
                    hiddenIds.push(id);
                }
            });
            return hiddenIds;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•å¯è§çš„æ¨¡å‹
        function hasVisibleModels() {
            let hasVisible = false;
            sceneModels.forEach((model) => {
                if (model.visible) {
                    hasVisible = true;
                }
            });
            return hasVisible;
        }
        
        function selectByBox(x1, y1, x2, y2, addToSelection, removeFromSelection) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            if (Math.abs(maxX - minX) < 5 && Math.abs(maxY - minY) < 5) return;
            
            // å¦‚æœæ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œä¸æ‰§è¡Œé€‰æ‹©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] æ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œè·³è¿‡é€‰æ‹©');
                return;
            }
            
            saveUndoState();
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByBox',
                data: {
                    minX, minY, maxX, maxY,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectByLasso(path, addToSelection, removeFromSelection) {
            if (path.length < 3) return;
            
            // å¦‚æœæ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œä¸æ‰§è¡Œé€‰æ‹©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] æ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œè·³è¿‡é€‰æ‹©');
                return;
            }
            
            saveUndoState();
            
            const simplifyRate = Math.max(1, Math.floor(path.length / 100));
            const simplifiedPath = path.filter((_, i) => i % simplifyRate === 0);
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByLasso',
                data: {
                    path: simplifiedPath,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectByBrush(path, radius, addToSelection, removeFromSelection) {
            if (path.length < 1) return;
            
            // å¦‚æœæ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œä¸æ‰§è¡Œé€‰æ‹©
            if (!hasVisibleModels()) {
                console.log('[ThreeJS Info] æ²¡æœ‰å¯è§çš„æ¨¡å‹ï¼Œè·³è¿‡é€‰æ‹©');
                return;
            }
            
            saveUndoState();
            
            const simplifyRate = Math.max(1, Math.floor(path.length / 50));
            const simplifiedPath = path.filter((_, i) => i % simplifyRate === 0);
            
            camera.updateMatrixWorld(true);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            
            sendToPython({
                type: 'selectByBrush',
                data: {
                    path: simplifiedPath,
                    radius: radius,
                    screenWidth: renderer.domElement.width,
                    screenHeight: renderer.domElement.height,
                    addToSelection,
                    removeFromSelection,
                    viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                    projMatrix: Array.from(camera.projectionMatrix.elements),
                    hiddenModelIds: getHiddenModelIds()
                }
            });
        }
        
        function selectAll() {
            saveUndoState();
            sendToPython({ type: 'selectAll' });
        }
        
        function selectInverse() {
            saveUndoState();
            sendToPython({ type: 'selectInverse' });
        }
        
        function clearSelection() {
            saveUndoState();
            selectedPointIndices.clear();
            updateSelectionDisplay();
            sendToPython({ type: 'clearSelection' });
        }
        
        // ==================== ç¼–è¾‘æ“ä½œ ====================
        function hideSelected() {
            if (selectedPointIndices.size === 0) return;
            saveUndoState();
            
            selectedPointIndices.forEach(idx => {
                hiddenPointIndices.add(idx);
            });
            
            updateSelectionDisplay();
            sendToPython({ type: 'hideSelected' });
        }
        
        function showAll() {
            saveUndoState();
            hiddenPointIndices.clear();
            updateSelectionDisplay();
            sendToPython({ type: 'showAll' });
        }
        
        function deleteSelected() {
            if (selectedPointIndices.size === 0) return;
            
            const count = selectedPointIndices.size;
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${count} ä¸ªé€‰ä¸­çš„ç‚¹å—ï¼Ÿ`)) return;
            
            saveUndoState();
            sendToPython({ type: 'deleteSelected' });
        }
        
        // ==================== æ’¤é”€/é‡åš ====================
        function saveUndoState() {
            const state = {
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            };
            
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            redoStack = [];
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            redoStack.push({
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            });
            
            const state = undoStack.pop();
            selectedPointIndices = state.selected;
            hiddenPointIndices = state.hidden;
            lockedPointIndices = state.locked;
            
            updateSelectionDisplay();
            sendToPython({ type: 'undo' });
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            undoStack.push({
                selected: new Set(selectedPointIndices),
                hidden: new Set(hiddenPointIndices),
                locked: new Set(lockedPointIndices)
            });
            
            const state = redoStack.pop();
            selectedPointIndices = state.selected;
            hiddenPointIndices = state.hidden;
            lockedPointIndices = state.locked;
            
            updateSelectionDisplay();
            sendToPython({ type: 'redo' });
        }
        
        // ==================== æ˜¾ç¤ºæ›´æ–° ====================
        function updateSelectionDisplay() {
            document.getElementById('selectedCount').textContent = selectedPointIndices.size;
        }
        
        function updatePointCount() {
            let total = 0;
            sceneModels.forEach(model => {
                total += model.pointCount;
            });
            document.getElementById('pointCount').textContent = formatNumber(total);
        }
        
        function updateSelectionFromPython(data) {
            selectedPointIndices.clear();
            hiddenPointIndices.clear();
            lockedPointIndices.clear();
            
            if (data.selected) {
                data.selected.forEach(idx => selectedPointIndices.add(idx));
            }
            if (data.hidden) {
                data.hidden.forEach(idx => hiddenPointIndices.add(idx));
            }
            if (data.locked) {
                data.locked.forEach(idx => lockedPointIndices.add(idx));
            }
            
            updateSelectionDisplay();
        }

        // ==================== è¾…åŠ©åŠŸèƒ½ ====================
        function toggleGrid() {
            if (infiniteGrid) {
                infiniteGrid.visible = !infiniteGrid.visible;
                const btn = document.getElementById('btn-grid');
                btn.classList.toggle('active', infiniteGrid.visible);
            }
        }
        
        function toggleAxes() {
            if (axesHelper) {
                axesHelper.visible = !axesHelper.visible;
                const btn = document.getElementById('btn-axes');
                btn.classList.toggle('active', axesHelper.visible);
            }
        }
        
        function toggleShortcuts() {
            const panel = document.getElementById('shortcuts-panel');
            panel.classList.toggle('visible');
        }
        
        function showLoading(text) {
            document.getElementById('loading-text').textContent = text || 'åŠ è½½ä¸­...';
            document.getElementById('loading-overlay').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }
    </script>

    <script>
        // ==================== æ¸²æŸ“å¾ªç¯ ====================
        let lastTime = performance.now();
        let frameCount = 0;
        let lastAxisUpdate = 0;
        const AXIS_UPDATE_INTERVAL = 50;
        let lastCameraQuaternion = new THREE.Quaternion();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ‰€æœ‰Splat Viewer
            sceneModels.forEach(model => {
                if (model.viewer) {
                    model.viewer.update();
                }
            });
            
            // æ›´æ–°å˜æ¢æ§åˆ¶å™¨ä½ç½®å’Œå¤§å°
            if (transformHelper.visible && selectedModelId) {
                updateTransformHelperPosition();
            }
            
            // æ¸²æŸ“ä¸»åœºæ™¯
            renderer.render(scene, camera);
            
            // å•ç‹¬æ¸²æŸ“å˜æ¢æ§åˆ¶å™¨åœºæ™¯ï¼ˆç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œä¸è¢«æ¨¡å‹é®æŒ¡ï¼‰
            if (transformHelper.visible && transformScene) {
                renderer.autoClear = false;
                renderer.clearDepth();
                renderer.render(transformScene, camera);
                renderer.autoClear = true;
            }
            
            // æ›´æ–°åæ ‡è½´æŒ‡ç¤ºå™¨
            const now = performance.now();
            if (now - lastAxisUpdate > AXIS_UPDATE_INTERVAL) {
                if (!camera.quaternion.equals(lastCameraQuaternion)) {
                    updateAxisIndicator();
                    lastCameraQuaternion.copy(camera.quaternion);
                }
                lastAxisUpdate = now;
            }
            
            // è®¡ç®—FPS
            frameCount++;
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }
        
        // ==================== WebChannelé€šä¿¡ ====================
        function initWebChannel() {
            if (typeof QWebChannel !== 'undefined' && typeof qt !== 'undefined' && qt.webChannelTransport) {
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    if (channel && channel.objects && channel.objects.pyBridge) {
                        pyBridge = channel.objects.pyBridge;
                        window.pyBridge = pyBridge;
                        console.log('[ThreeJS Info] WebChannelå·²è¿æ¥');
                    }
                });
            }
        }
        
        function sendToPython(message) {
            if (pyBridge && pyBridge.receiveMessage) {
                pyBridge.receiveMessage(JSON.stringify(message));
            }
        }
        
        window.receiveMessageFromPython = function(messageStr) {
            if (!isInitialized) {
                messageQueue.push(messageStr);
                return;
            }
            
            const message = JSON.parse(messageStr);
            console.log('[ThreeJS Info] æ”¶åˆ°æ¶ˆæ¯:', message.type);
            
            switch(message.type) {
                case 'loadModel':
                    handleLoadModel(message.data);
                    break;
                case 'captureScreenshot':
                    captureScreenshot();
                    break;
                case 'applySegmentationMask':
                    applySegmentationMask(message.data);
                    break;
                case 'selectPointsByMask':
                    selectPointsByMask(message.data);
                    break;
                case 'deleteUnselectedPoints':
                    deleteUnselectedPoints();
                    break;
                case 'deleteUnselectedPointsPermanently':
                    deleteUnselectedPointsPermanently(message.data);
                    break;
                case 'exportSplitModel':
                    exportSplitModel(message.data);
                    break;
                case 'resetView':
                    resetCamera();
                    break;
                case 'clearModel':
                    clearAllModels();
                    break;
                case 'highlightSelectedPoints':
                    highlightSelectedPoints(message.data);
                    break;
                case 'visualizeContours':
                    visualizeContoursFromData(message.data);
                    break;
                case 'clearVisualization':
                    clearVisualization();
                    break;
                case 'restoreModel':
                    restoreOriginalModel();
                    break;
                case 'clearHighlight':
                    clearHighlightMesh();
                    break;
                case 'hideOriginalModel':
                    hideOriginalModel();
                    break;
                case 'showOriginalModel':
                    showOriginalModel();
                    break;
                case 'previewSplitAsSplat':
                    previewSplitAsSplat(message.data);
                    break;
                case 'previewSplitAsPoints':
                    previewSplitAsPoints(message.data);
                    break;
                case 'clearPreview':
                    clearPreview();
                    break;
                case 'updateSelection':
                    updateSelectionFromPython(message.data);
                    break;
                case 'setRenderMode':
                    document.getElementById('render-mode').value = message.data.mode;
                    setRenderMode(message.data.mode);
                    break;
                case 'createPointCloudFromData':
                    createPointCloudFromData(message.data);
                    break;
                case 'updateHighlightFromData':
                    updateHighlightFromData(message.data);
                    break;
                case 'createPointCloudOverlay':
                    createPointCloudOverlay(message.data);
                    break;
                default:
                    console.log('[ThreeJS Info] æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
            }
        };
        
        function handleLoadModel(data) {
            const url = data.url;
            const name = data.name || url.split('/').pop();
            const flyTo = data.flyTo !== false;
            
            const id = addModel(url, name, 'splat');
            loadModelToScene(id, url);
        }
        
        function clearAllModels() {
            sceneModels.forEach((model, id) => {
                if (model.mesh) {
                    scene.remove(model.mesh);
                }
                if (model.viewer && model.viewer.dispose) {
                    model.viewer.dispose();
                }
            });
            
            sceneModels.clear();
            selectedModelId = null;
            
            if (pointCloudMesh) {
                scene.remove(pointCloudMesh);
                pointCloudMesh.geometry.dispose();
                pointCloudMesh.material.dispose();
                pointCloudMesh = null;
            }
            
            clearHighlightMesh();
            clearVisualization();
            
            selectedPointIndices.clear();
            hiddenPointIndices.clear();
            lockedPointIndices.clear();
            
            updateModelList();
            updatePointCount();
            updateSelectionDisplay();
        }
        
        function clearHighlightMesh() {
            if (highlightMesh) {
                scene.remove(highlightMesh);
                if (highlightMesh.geometry) highlightMesh.geometry.dispose();
                if (highlightMesh.material) highlightMesh.material.dispose();
                highlightMesh = null;
            }
        }
        
        let contourLines = [];
        
        function clearVisualization() {
            contourLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            contourLines = [];
        }
        
        function restoreOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = model.visible;
                }
            });
            clearHighlightMesh();
        }
        
        // ==================== é¢„è§ˆåŠŸèƒ½ ====================
        let previewMesh = null;
        
        function hideOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            // ä¹Ÿéšè—é«˜äº®
            if (highlightMesh) {
                highlightMesh.visible = false;
            }
        }
        
        function showOriginalModel() {
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = model.visible;
                }
            });
            // æ¢å¤é«˜äº®æ˜¾ç¤º
            if (highlightMesh) {
                highlightMesh.visible = true;
            }
        }
        
        // é¢„è§ˆç”¨çš„ä¸´æ—¶viewer
        let previewViewer = null;
        
        function previewSplitAsSplat(data) {
            // Splatæ¸²æŸ“æ¨¡å¼ï¼šåŠ è½½ä¸´æ—¶splatæ–‡ä»¶
            clearPreview();
            
            const splatUrl = data.splatUrl || null;
            
            console.log('[ThreeJS Debug] Splaté¢„è§ˆæ•°æ®:', {
                splatUrl: splatUrl
            });
            
            if (!splatUrl) {
                console.error('[ThreeJS Error] æ²¡æœ‰splat URL');
                return;
            }
            
            // éšè—åŸæ¨¡å‹å’Œé«˜äº®
            hideOriginalModel();
            
            // ä½¿ç”¨GaussianSplats3DåŠ è½½ä¸´æ—¶splatæ–‡ä»¶
            if (typeof GaussianSplats3D !== 'undefined' && GaussianSplats3D.Viewer) {
                try {
                    console.log('[ThreeJS Info] å¼€å§‹åŠ è½½é¢„è§ˆsplat:', splatUrl);
                    
                    // åˆ›å»ºä¸´æ—¶viewerï¼ˆä¸é™„åŠ åˆ°DOMï¼Œåªç”¨äºåŠ è½½splatï¼‰
                    previewViewer = new GaussianSplats3D.Viewer({
                        cameraUp: [0, 1, 0],
                        initialCameraPosition: camera.position.toArray(),
                        initialCameraLookAt: target.toArray(),
                        sharedMemoryForWorkers: false,  // ç¦ç”¨å…±äº«å†…å­˜
                        enableSIMDInSort: false,        // ç¦ç”¨SIMDï¼ˆå…³é”®ï¼ï¼‰
                        gpuAcceleratedSort: false,      // ç¦ç”¨GPUåŠ é€Ÿæ’åº
                        integerBasedSort: false,        // ä½¿ç”¨æµ®ç‚¹æ’åº
                        renderer: renderer,             // ä½¿ç”¨ç°æœ‰çš„renderer
                        camera: camera,                 // ä½¿ç”¨ç°æœ‰çš„camera
                        useBuiltInControls: false,      // ä¸ä½¿ç”¨å†…ç½®æ§åˆ¶
                        rootElement: null               // ä¸é™„åŠ åˆ°DOM
                    });
                    
                    previewViewer.addSplatScene(splatUrl, {
                        splatAlphaRemovalThreshold: 5,
                        showLoadingUI: false,
                        progressiveLoad: false,
                        position: [0, 0, 0],
                        rotation: [0, 0, 0, 1],
                        scale: [1, 1, 1]
                    }).then(() => {
                        console.log('[ThreeJS Info] Splatåœºæ™¯åŠ è½½å®Œæˆ');
                        
                        // è·å–splat meshå¹¶æ·»åŠ åˆ°åœºæ™¯
                        if (previewViewer.splatMesh) {
                            previewMesh = previewViewer.splatMesh;
                            scene.add(previewMesh);
                            console.log('[ThreeJS Info] Splaté¢„è§ˆåŠ è½½æˆåŠŸ');
                        } else {
                            console.error('[ThreeJS Error] æ— æ³•è·å–splat mesh');
                        }
                    }).catch(error => {
                        console.error('[ThreeJS Error] Splaté¢„è§ˆåŠ è½½å¤±è´¥:', error);
                        console.error('[ThreeJS Error] é”™è¯¯è¯¦æƒ…:', error.stack);
                    });
                    
                } catch (error) {
                    console.error('[ThreeJS Error] åˆ›å»ºSplatæŸ¥çœ‹å™¨å¤±è´¥:', error);
                    console.error('[ThreeJS Error] é”™è¯¯è¯¦æƒ…:', error.stack);
                }
            } else {
                console.error('[ThreeJS Error] GaussianSplats3Dåº“æœªåŠ è½½');
            }
            
            console.log('[ThreeJS Info] é¢„è§ˆæ¨¡å¼: Splatæ¸²æŸ“');
        }
        
        function previewSplitAsPoints(data) {
            // ç‚¹äº‘æ¸²æŸ“æ¨¡å¼ï¼šåˆ›å»ºå°ç‚¹çš„ç‚¹äº‘mesh
            clearPreview();
            
            const positions = data.positions || [];
            const colors = data.colors || [];
            
            console.log('[ThreeJS Debug] ç‚¹äº‘é¢„è§ˆæ•°æ®:', {
                positionsLength: positions.length,
                colorsLength: colors.length,
                pointCount: positions.length / 3,
                colorCount: colors.length / 3,
                colorSample: colors.length >= 9 ? [
                    `RGB(${colors[0].toFixed(2)}, ${colors[1].toFixed(2)}, ${colors[2].toFixed(2)})`,
                    `RGB(${colors[3].toFixed(2)}, ${colors[4].toFixed(2)}, ${colors[5].toFixed(2)})`,
                    `RGB(${colors[6].toFixed(2)}, ${colors[7].toFixed(2)}, ${colors[8].toFixed(2)})`
                ] : 'none'
            });
            
            if (positions.length === 0) {
                console.warn('[ThreeJS Warning] æ²¡æœ‰ç‚¹äº‘æ•°æ®');
                return;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            let hasColors = false;
            if (colors.length > 0 && colors.length === positions.length) {
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                hasColors = true;
                console.log('[ThreeJS Info] è®¾ç½®é¡¶ç‚¹é¢œè‰²æˆåŠŸ');
            } else {
                console.warn('[ThreeJS Warning] é¢œè‰²æ•°æ®é•¿åº¦ä¸åŒ¹é…æˆ–ä¸ºç©º:', {
                    positionsLength: positions.length,
                    colorsLength: colors.length
                });
            }
            
            const material = new THREE.PointsMaterial({
                size: 0.08,  // ç¨å¤§ä¸€ç‚¹çš„ç‚¹ï¼Œæ›´å®¹æ˜“çœ‹æ¸…é¢œè‰²
                vertexColors: hasColors,
                color: hasColors ? 0xffffff : 0xaaaaaa,
                sizeAttenuation: true,
                transparent: false,
                opacity: 1.0
            });
            
            console.log('[ThreeJS Debug] æè´¨è®¾ç½®:', {
                vertexColors: material.vertexColors,
                color: material.color.getHexString(),
                size: material.size
            });
            
            previewMesh = new THREE.Points(geometry, material);
            scene.add(previewMesh);
            
            // éšè—åŸæ¨¡å‹å’Œé«˜äº®
            hideOriginalModel();
            
            console.log('[ThreeJS Info] é¢„è§ˆæ¨¡å¼: ç‚¹äº‘æ¸²æŸ“, ç‚¹æ•°:', positions.length / 3, 'é¢œè‰²:', hasColors ? 'æœ‰' : 'æ— ');
        }
        
        function clearPreview() {
            if (previewMesh) {
                scene.remove(previewMesh);
                if (previewMesh.geometry) previewMesh.geometry.dispose();
                if (previewMesh.material) previewMesh.material.dispose();
                previewMesh = null;
            }
            
            // æ¸…ç†é¢„è§ˆviewer
            if (previewViewer) {
                try {
                    if (previewViewer.dispose) {
                        previewViewer.dispose();
                    }
                } catch (e) {
                    console.warn('[ThreeJS Warning] æ¸…ç†é¢„è§ˆviewerå¤±è´¥:', e);
                }
                previewViewer = null;
            }
        }
        
        // ==================== æˆªå›¾å’Œåˆ†å‰² ====================
        function captureScreenshot() {
            try {
                const canvas = renderer.domElement;
                const imageData = canvas.toDataURL('image/png');
                
                camera.updateMatrix();
                camera.updateMatrixWorld(true);
                camera.updateProjectionMatrix();
                camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                
                const cameraPosition = camera.position.clone();
                const cameraDirection = new THREE.Vector3(0, 0, -1);
                cameraDirection.applyQuaternion(camera.quaternion);
                const cameraTarget = cameraPosition.clone().add(cameraDirection);
                
                sendToPython({
                    type: 'screenshotCaptured',
                    data: {
                        imageData: imageData,
                        width: canvas.width,
                        height: canvas.height,
                        cameraPosition: [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                        cameraTarget: [cameraTarget.x, cameraTarget.y, cameraTarget.z],
                        cameraFov: camera.fov,
                        viewMatrix: Array.from(camera.matrixWorldInverse.elements),
                        projMatrix: Array.from(camera.projectionMatrix.elements)
                    }
                });
            } catch (error) {
                console.error('[ThreeJS Error] æˆªå›¾å¤±è´¥:', error);
                sendToPython({
                    type: 'screenshotCaptured',
                    success: false,
                    error: error.message
                });
            }
        }
        
        let segmentationMask = null;
        
        function applySegmentationMask(data) {
            segmentationMask = {
                data: data.mask,
                width: data.width,
                height: data.height
            };
            
            sendToPython({
                type: 'segmentationComplete',
                success: true
            });
        }
        
        function selectPointsByMask(data) {
            const keepSelected = data.keepSelected !== false;
            selectedPointIndices.clear();
            
            // éå†æ‰€æœ‰æ¨¡å‹
            sceneModels.forEach(model => {
                if (!model.viewer || !segmentationMask) return;
                
                try {
                    const splatCount = model.viewer.getSplatCount ? model.viewer.getSplatCount() : 0;
                    
                    for (let i = 0; i < splatCount; i++) {
                        const position = new THREE.Vector3();
                        if (model.viewer.getSplatCenter) {
                            model.viewer.getSplatCenter(i, position);
                        }
                        
                        const screenPos = position.clone().project(camera);
                        
                        const x = Math.floor((screenPos.x + 1) / 2 * segmentationMask.width);
                        const y = Math.floor((1 - screenPos.y) / 2 * segmentationMask.height);
                        
                        if (x >= 0 && x < segmentationMask.width && 
                            y >= 0 && y < segmentationMask.height) {
                            const maskIndex = y * segmentationMask.width + x;
                            const maskValue = segmentationMask.data[maskIndex];
                            
                            if (keepSelected) {
                                if (maskValue > 0) {
                                    selectedPointIndices.add(i);
                                }
                            } else {
                                if (maskValue === 0) {
                                    selectedPointIndices.add(i);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('[ThreeJS Error] é€‰æ‹©ç‚¹å¤±è´¥:', error);
                }
            });
            
            updateSelectionDisplay();
            
            sendToPython({
                type: 'pointsSelected',
                data: {
                    selectedCount: selectedPointIndices.size
                }
            });
        }
        
        function deleteUnselectedPoints() {
            // æ—§çš„åˆ é™¤å‡½æ•° - ä»…ç”¨äºå‘åå…¼å®¹
            if (selectedPointIndices.size === 0) return;
            
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            
            if (highlightMesh) {
                highlightMesh.material.opacity = 1.0;
                highlightMesh.material.size = 0.2;
                highlightMesh.material.needsUpdate = true;
            }
            
            sendToPython({
                type: 'pointsDeleted',
                data: { remainingCount: selectedPointIndices.size }
            });
        }
        
        function deleteUnselectedPointsPermanently(data) {
            // æ°¸ä¹…åˆ é™¤æœªé€‰ä¸­çš„ç‚¹ - åªä¿ç•™é€‰ä¸­çš„ç‚¹
            const selectedIndices = new Set(data.selectedIndices || []);
            
            if (selectedIndices.size === 0) {
                console.warn('[ThreeJS Warning] æ²¡æœ‰é€‰ä¸­çš„ç‚¹');
                return;
            }
            
            // æ¸…é™¤é¢„è§ˆ
            clearPreview();
            
            // éšè—åŸå§‹splatæ¨¡å‹
            sceneModels.forEach(model => {
                if (model.viewer && model.viewer.splatMesh) {
                    model.viewer.splatMesh.visible = false;
                }
            });
            
            // æ¸…é™¤æ—§çš„é«˜äº®
            clearHighlightMesh();
            
            // åªæ˜¾ç¤ºé€‰ä¸­çš„ç‚¹ï¼ˆä½œä¸ºç‚¹äº‘ï¼‰
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬æ— æ³•çœŸæ­£ä¿®æ”¹splatæ•°æ®ï¼Œåªèƒ½é€šè¿‡æ˜¾ç¤º/éšè—æ¥æ¨¡æ‹Ÿ
            // çœŸæ­£çš„åˆ é™¤åœ¨Pythonç«¯å®Œæˆ
            
            console.log('[ThreeJS Info] æ°¸ä¹…åˆ é™¤å®Œæˆï¼Œä¿ç•™', selectedIndices.size, 'ä¸ªç‚¹');
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            selectedPointIndices = selectedIndices;
            updateSelectionDisplay();
            
            sendToPython({
                type: 'pointsDeletedPermanently',
                data: { remainingCount: selectedIndices.size }
            });
        }
        
        function exportSplitModel(data) {
            const outputPath = data.outputPath;
            
            sendToPython({
                type: 'modelSplitComplete',
                success: true,
                data: {
                    outputPath: outputPath,
                    selectedIndices: Array.from(selectedPointIndices)
                }
            });
        }
        
        function highlightSelectedPoints(data) {
            const indices = data.indices || [];
            const count = data.count || indices.length;
            const positions3D = data.positions || null;
            
            clearHighlightMesh();
            
            if (count === 0) {
                document.getElementById('selectedCount').textContent = '0';
                return;
            }
            
            selectedPointIndices.clear();
            indices.forEach(i => selectedPointIndices.add(i));
            
            try {
                let positions = [];
                
                if (positions3D && positions3D.length > 0) {
                    const maxDisplayPoints = 50000;
                    let sampleRate = 1;
                    if (positions3D.length > maxDisplayPoints) {
                        sampleRate = Math.ceil(positions3D.length / maxDisplayPoints);
                    }
                    
                    for (let i = 0; i < positions3D.length; i += sampleRate) {
                        const pt = positions3D[i];
                        positions.push(pt[0], pt[1], pt[2]);
                    }
                }
                
                if (positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    
                    const material = new THREE.PointsMaterial({
                        color: 0xffff00,  // é»„è‰²é«˜äº®
                        size: 0.1,  // è¾ƒå°çš„ç‚¹ï¼Œæ›´æ¸…æ™°
                        transparent: true,
                        opacity: 1.0,  // å®Œå…¨ä¸é€æ˜
                        depthTest: true,  // å¯ç”¨æ·±åº¦æµ‹è¯•ï¼Œæ›´çœŸå®
                        depthWrite: false,
                        sizeAttenuation: true  // å¯ç”¨é€è§†ç¼©æ”¾
                    });
                    
                    highlightMesh = new THREE.Points(geometry, material);
                    highlightMesh.renderOrder = 999;
                    scene.add(highlightMesh);
                    
                    console.log('[ThreeJS Info] é«˜äº®æ˜¾ç¤º', positions.length / 3, 'ä¸ªç‚¹');
                }
            } catch (error) {
                console.error('[ThreeJS Error] åˆ›å»ºé«˜äº®å¤±è´¥:', error);
            }
            
            document.getElementById('selectedCount').textContent = count;
            
            sendToPython({
                type: 'pointsHighlighted',
                data: { highlightedCount: count }
            });
        }
        
        function visualizeContoursFromData(data) {
            try {
                const contours = data.contours || [];
                const imageWidth = data.imageWidth || renderer.domElement.width;
                const imageHeight = data.imageHeight || renderer.domElement.height;
                
                clearVisualization();
                
                if (contours.length === 0) return;
                
                const raycaster = new THREE.Raycaster();
                
                contours.forEach((contour, contourIdx) => {
                    if (!contour || contour.length < 3) return;
                    
                    const contour3D = [];
                    const sampleRate = Math.max(1, Math.floor(contour.length / 100));
                    
                    for (let i = 0; i < contour.length; i += sampleRate) {
                        const point = contour[i];
                        
                        const ndcX = (point[0] / imageWidth) * 2 - 1;
                        const ndcY = -((point[1] / imageHeight) * 2 - 1);
                        
                        raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), camera);
                        
                        const direction = raycaster.ray.direction.clone();
                        const distance = 8;
                        const intersectionPoint = camera.position.clone().add(direction.multiplyScalar(distance));
                        
                        contour3D.push(intersectionPoint);
                    }
                    
                    if (contour3D.length > 2) {
                        contour3D.push(contour3D[0].clone());
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(contour3D);
                        const material = new THREE.LineBasicMaterial({
                            color: 0xff00ff,
                            linewidth: 3,
                            transparent: true,
                            opacity: 0.9
                        });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        contourLines.push(line);
                    }
                });
            } catch (error) {
                console.error('[ThreeJS Error] å¯è§†åŒ–è½®å»“å¤±è´¥:', error);
            }
        }
        
        // ==================== é¡µé¢åŠ è½½ ====================
        window.addEventListener('load', function() {
            function waitForLibraries() {
                if (typeof THREE !== 'undefined') {
                    init();
                } else {
                    setTimeout(waitForLibraries, 100);
                }
            }
            waitForLibraries();
        });
    </script>
</body>
</html>
